/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

/* jshint latedef:false */
/* jshint forin:false */
/* jshint noempty:false */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const ServiceClient = msRestAzure.AzureServiceClient;
const WebResource = msRest.WebResource;

const models = require('./models');


/**
 * @summary Creates a new key, stores it, then returns key parameters and
 * attributes to the client.
 *
 * The create key operation can be used to create any key type in Azure Key
 * Vault. If the named key already exists, Azure Key Vault creates a new
 * version of the key.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name for the new key. The system will generate
 * the version name for the new key.
 *
 * @param {string} kty The type of key to create. For valid values, see
 * JsonWebKeyType. Possible values include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM',
 * 'oct'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.keySize] The key size in bytes. For example, 1024
 * or 2048.
 *
 * @param {array} [options.keyOps]
 *
 * @param {object} [options.keyAttributes]
 *
 * @param {boolean} [options.keyAttributes.enabled] Determines whether the
 * object is enabled.
 *
 * @param {date} [options.keyAttributes.notBefore] Not before date in UTC.
 *
 * @param {date} [options.keyAttributes.expires] Expiry date in UTC.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {string} [options.curve] Elliptic curve name. For valid values, see
 * JsonWebKeyCurveName. Possible values include: 'P-256', 'P-384', 'P-521',
 * 'SECP256K1'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createKey(vaultBaseUrl, keyName, kty, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let keySize = (options && options.keySize !== undefined) ? options.keySize : undefined;
  let keyOps = (options && options.keyOps !== undefined) ? options.keyOps : undefined;
  let keyAttributes = (options && options.keyAttributes !== undefined) ? options.keyAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  let curve = (options && options.curve !== undefined) ? options.curve : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyName !== null && keyName !== undefined) {
      if (keyName.match(/^[0-9a-zA-Z-]+$/) === null)
      {
        throw new Error('"keyName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z-]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (kty === null || kty === undefined || typeof kty.valueOf() !== 'string') {
      throw new Error('kty cannot be null or undefined and it must be of type string.');
    }
    if (kty !== null && kty !== undefined) {
      if (kty.length < 1)
      {
        throw new Error('"kty" should satisfy the constraint - "MinLength": 1');
      }
    }
    if (keySize !== null && keySize !== undefined && typeof keySize !== 'number') {
      throw new Error('keySize must be of type number.');
    }
    if (Array.isArray(keyOps)) {
      for (let i = 0; i < keyOps.length; i++) {
        if (keyOps[i] !== null && keyOps[i] !== undefined && typeof keyOps[i].valueOf() !== 'string') {
          throw new Error('keyOps[i] must be of type string.');
        }
      }
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (curve !== null && curve !== undefined && typeof curve.valueOf() !== 'string') {
      throw new Error('curve must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((kty !== null && kty !== undefined) || (keySize !== null && keySize !== undefined) || (keyOps !== null && keyOps !== undefined) || (keyAttributes !== null && keyAttributes !== undefined) || (tags !== null && tags !== undefined) || (curve !== null && curve !== undefined)) {
    parameters = new client.models['KeyCreateParameters']();
    parameters.kty = kty;
    parameters.keySize = keySize;
    parameters.keyOps = keyOps;
    parameters.keyAttributes = keyAttributes;
    parameters.tags = tags;
    parameters.curve = curve;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/create';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeyCreateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Imports an externally created key, stores it, and returns key
 * parameters and attributes to the client.
 *
 * The import key operation may be used to import any key type into an Azure
 * Key Vault. If the named key already exists, Azure Key Vault creates a new
 * version of the key.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName Name for the imported key.
 *
 * @param {object} key The Json web key
 *
 * @param {string} [key.kid] Key identifier.
 *
 * @param {string} [key.kty] JsonWebKey key type (kty). Possible values
 * include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'
 *
 * @param {array} [key.keyOps]
 *
 * @param {buffer} [key.n] RSA modulus.
 *
 * @param {buffer} [key.e] RSA public exponent.
 *
 * @param {buffer} [key.d] RSA private exponent, or the D component of an EC
 * private key.
 *
 * @param {buffer} [key.dp] RSA private key parameter.
 *
 * @param {buffer} [key.dq] RSA private key parameter.
 *
 * @param {buffer} [key.qi] RSA private key parameter.
 *
 * @param {buffer} [key.p] RSA secret prime.
 *
 * @param {buffer} [key.q] RSA secret prime, with p < q.
 *
 * @param {buffer} [key.k] Symmetric key.
 *
 * @param {buffer} [key.t] HSM Token, used with 'Bring Your Own Key'.
 *
 * @param {string} [key.crv] Elliptic curve name. For valid values, see
 * JsonWebKeyCurveName. Possible values include: 'P-256', 'P-384', 'P-521',
 * 'SECP256K1'
 *
 * @param {buffer} [key.x] X component of an EC public key.
 *
 * @param {buffer} [key.y] Y component of an EC public key.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.hsm] Whether to import as a hardware key (HSM) or
 * software key.
 *
 * @param {object} [options.keyAttributes] The key management attributes.
 *
 * @param {boolean} [options.keyAttributes.enabled] Determines whether the
 * object is enabled.
 *
 * @param {date} [options.keyAttributes.notBefore] Not before date in UTC.
 *
 * @param {date} [options.keyAttributes.expires] Expiry date in UTC.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _importKey(vaultBaseUrl, keyName, key, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let hsm = (options && options.hsm !== undefined) ? options.hsm : undefined;
  let keyAttributes = (options && options.keyAttributes !== undefined) ? options.keyAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyName !== null && keyName !== undefined) {
      if (keyName.match(/^[0-9a-zA-Z-]+$/) === null)
      {
        throw new Error('"keyName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z-]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (hsm !== null && hsm !== undefined && typeof hsm !== 'boolean') {
      throw new Error('hsm must be of type boolean.');
    }
    if (key === null || key === undefined) {
      throw new Error('key cannot be null or undefined.');
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((hsm !== null && hsm !== undefined) || (key !== null && key !== undefined) || (keyAttributes !== null && keyAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters = new client.models['KeyImportParameters']();
    parameters.hsm = hsm;
    parameters.key = key;
    parameters.keyAttributes = keyAttributes;
    parameters.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeyImportParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a key of any type from storage in Azure Key Vault.
 *
 * The delete key operation cannot be used to remove individual versions of a
 * key. This operation removes the cryptographic material associated with the
 * key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or
 * Encrypt/Decrypt operations.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key to delete.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedKeyBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteKey(vaultBaseUrl, keyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedKeyBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary The update key operation changes specified attributes of a stored
 * key and can be applied to any key type and key version stored in Azure Key
 * Vault.
 *
 * In order to perform this operation, the key must already exist in the Key
 * Vault. Note: The cryptographic material of a key itself cannot be changed.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of key to update.
 *
 * @param {string} keyVersion The version of the key to update.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {array} [options.keyOps] Json web key operations. For more
 * information on possible key operations, see JsonWebKeyOperation.
 *
 * @param {object} [options.keyAttributes]
 *
 * @param {boolean} [options.keyAttributes.enabled] Determines whether the
 * object is enabled.
 *
 * @param {date} [options.keyAttributes.notBefore] Not before date in UTC.
 *
 * @param {date} [options.keyAttributes.expires] Expiry date in UTC.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateKey(vaultBaseUrl, keyName, keyVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let keyOps = (options && options.keyOps !== undefined) ? options.keyOps : undefined;
  let keyAttributes = (options && options.keyAttributes !== undefined) ? options.keyAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyVersion === null || keyVersion === undefined || typeof keyVersion.valueOf() !== 'string') {
      throw new Error('keyVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (Array.isArray(keyOps)) {
      for (let i = 0; i < keyOps.length; i++) {
        if (keyOps[i] !== null && keyOps[i] !== undefined && typeof keyOps[i].valueOf() !== 'string') {
          throw new Error('keyOps[i] must be of type string.');
        }
      }
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((keyOps !== null && keyOps !== undefined) || (keyAttributes !== null && keyAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters = new client.models['KeyUpdateParameters']();
    parameters.keyOps = keyOps;
    parameters.keyAttributes = keyAttributes;
    parameters.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/{key-version}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  requestUrl = requestUrl.replace('{key-version}', encodeURIComponent(keyVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeyUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the public part of a stored key.
 *
 * The get key operation is applicable to all key types. If the requested key
 * is symmetric, then no key material is released in the response.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key to get.
 *
 * @param {string} keyVersion Adding the version parameter retrieves a specific
 * version of a key.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getKey(vaultBaseUrl, keyName, keyVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyVersion === null || keyVersion === undefined || typeof keyVersion.valueOf() !== 'string') {
      throw new Error('keyVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/{key-version}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  requestUrl = requestUrl.replace('{key-version}', encodeURIComponent(keyVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves a list of individual key versions with the same key name.
 *
 * The full key identifier, attributes, and tags are provided in the response.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getKeyVersions(vaultBaseUrl, keyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/versions';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List keys in the specified vault.
 *
 * Retrieves a list of the keys in the Key Vault as JSON Web Key structures
 * that contain the public part of a stored key. The LIST operation is
 * applicable to all key types, however only the base key
 * identifier,attributes, and tags are provided in the response. Individual
 * versions of a key are not listed in the response. Authorization: Requires
 * the keys/list permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getKeys(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Requests that a backup of the specified key be downloaded to the
 * client.
 *
 * The Key Backup operation exports a key from Azure Key Vault in a protected
 * form. Note that this operation does NOT return key material in a form that
 * can be used outside the Azure Key Vault system, the returned key material is
 * either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The
 * intent of this operation is to allow a client to GENERATE a key in one Azure
 * Key Vault instance, BACKUP the key, and then RESTORE it into another Azure
 * Key Vault instance. The BACKUP operation may be used to export, in protected
 * form, any key type from Azure Key Vault. Individual versions of a key cannot
 * be backed up. BACKUP / RESTORE can be performed within geographical
 * boundaries only; meaning that a BACKUP from one geographical area cannot be
 * restored to another geographical area. For example, a backup from the US
 * geographical area cannot be restored in an EU geographical area.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupKeyResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _backupKey(vaultBaseUrl, keyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/backup';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupKeyResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restores a backed up key to a vault.
 *
 * Imports a previously backed up key into Azure Key Vault, restoring the key,
 * its key identifier, attributes and access control policies. The RESTORE
 * operation may be used to import a previously backed up key. Individual
 * versions of a key cannot be restored. The key is restored in its entirety
 * with the same key name as it had when it was backed up. If the key name is
 * not available in the target Key Vault, the RESTORE operation will be
 * rejected. While the key name is retained during restore, the final key
 * identifier will change if the key is restored to a different vault. Restore
 * will restore all versions and preserve version identifiers. The RESTORE
 * operation is subject to security constraints: The target Key Vault must be
 * owned by the same Microsoft Azure Subscription as the source Key Vault The
 * user must have RESTORE permission in the target Key Vault.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {buffer} keyBundleBackup The backup blob associated with a key
 * bundle.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restoreKey(vaultBaseUrl, keyBundleBackup, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (!Buffer.isBuffer(keyBundleBackup)) {
      throw new Error('keyBundleBackup cannot be null or undefined and it must be of type buffer.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if (keyBundleBackup !== null && keyBundleBackup !== undefined) {
    parameters = new client.models['KeyRestoreParameters']();
    parameters.keyBundleBackup = keyBundleBackup;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/restore';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeyRestoreParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Encrypts an arbitrary sequence of bytes using an encryption key
 * that is stored in a key vault.
 *
 * The ENCRYPT operation encrypts an arbitrary sequence of bytes using an
 * encryption key that is stored in Azure Key Vault. Note that the ENCRYPT
 * operation only supports a single block of data, the size of which is
 * dependent on the target key and the encryption algorithm to be used. The
 * ENCRYPT operation is only strictly necessary for symmetric keys stored in
 * Azure Key Vault since protection with an asymmetric key can be performed
 * using public portion of the key. This operation is supported for asymmetric
 * keys as a convenience for callers that have a key-reference but do not have
 * access to the public key material.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key.
 *
 * @param {string} keyVersion The version of the key.
 *
 * @param {string} algorithm algorithm identifier. Possible values include:
 * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
 *
 * @param {buffer} value
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyOperationResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _encrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyVersion === null || keyVersion === undefined || typeof keyVersion.valueOf() !== 'string') {
      throw new Error('keyVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (algorithm === null || algorithm === undefined || typeof algorithm.valueOf() !== 'string') {
      throw new Error('algorithm cannot be null or undefined and it must be of type string.');
    }
    if (algorithm !== null && algorithm !== undefined) {
      if (algorithm.length < 1)
      {
        throw new Error('"algorithm" should satisfy the constraint - "MinLength": 1');
      }
    }
    if (!Buffer.isBuffer(value)) {
      throw new Error('value cannot be null or undefined and it must be of type buffer.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((algorithm !== null && algorithm !== undefined) || (value !== null && value !== undefined)) {
    parameters = new client.models['KeyOperationsParameters']();
    parameters.algorithm = algorithm;
    parameters.value = value;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/{key-version}/encrypt';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  requestUrl = requestUrl.replace('{key-version}', encodeURIComponent(keyVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeyOperationsParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyOperationResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Decrypts a single block of encrypted data.
 *
 * The DECRYPT operation decrypts a well-formed block of ciphertext using the
 * target encryption key and specified algorithm. This operation is the reverse
 * of the ENCRYPT operation; only a single block of data may be decrypted, the
 * size of this block is dependent on the target key and the algorithm to be
 * used. The DECRYPT operation applies to asymmetric and symmetric keys stored
 * in Azure Key Vault since it uses the private portion of the key.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key.
 *
 * @param {string} keyVersion The version of the key.
 *
 * @param {string} algorithm algorithm identifier. Possible values include:
 * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
 *
 * @param {buffer} value
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyOperationResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _decrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyVersion === null || keyVersion === undefined || typeof keyVersion.valueOf() !== 'string') {
      throw new Error('keyVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (algorithm === null || algorithm === undefined || typeof algorithm.valueOf() !== 'string') {
      throw new Error('algorithm cannot be null or undefined and it must be of type string.');
    }
    if (algorithm !== null && algorithm !== undefined) {
      if (algorithm.length < 1)
      {
        throw new Error('"algorithm" should satisfy the constraint - "MinLength": 1');
      }
    }
    if (!Buffer.isBuffer(value)) {
      throw new Error('value cannot be null or undefined and it must be of type buffer.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((algorithm !== null && algorithm !== undefined) || (value !== null && value !== undefined)) {
    parameters = new client.models['KeyOperationsParameters']();
    parameters.algorithm = algorithm;
    parameters.value = value;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/{key-version}/decrypt';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  requestUrl = requestUrl.replace('{key-version}', encodeURIComponent(keyVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeyOperationsParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyOperationResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a signature from a digest using the specified key.
 *
 * The SIGN operation is applicable to asymmetric and symmetric keys stored in
 * Azure Key Vault since this operation uses the private portion of the key.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key.
 *
 * @param {string} keyVersion The version of the key.
 *
 * @param {string} algorithm The signing/verification algorithm identifier. For
 * more information on possible algorithm types, see
 * JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',
 * 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512',
 * 'ECDSA256'
 *
 * @param {buffer} value
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyOperationResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _sign(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyVersion === null || keyVersion === undefined || typeof keyVersion.valueOf() !== 'string') {
      throw new Error('keyVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (algorithm === null || algorithm === undefined || typeof algorithm.valueOf() !== 'string') {
      throw new Error('algorithm cannot be null or undefined and it must be of type string.');
    }
    if (algorithm !== null && algorithm !== undefined) {
      if (algorithm.length < 1)
      {
        throw new Error('"algorithm" should satisfy the constraint - "MinLength": 1');
      }
    }
    if (!Buffer.isBuffer(value)) {
      throw new Error('value cannot be null or undefined and it must be of type buffer.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((algorithm !== null && algorithm !== undefined) || (value !== null && value !== undefined)) {
    parameters = new client.models['KeySignParameters']();
    parameters.algorithm = algorithm;
    parameters.value = value;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/{key-version}/sign';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  requestUrl = requestUrl.replace('{key-version}', encodeURIComponent(keyVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeySignParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyOperationResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Verifies a signature using a specified key.
 *
 * The VERIFY operation is applicable to symmetric keys stored in Azure Key
 * Vault. VERIFY is not strictly necessary for asymmetric keys stored in Azure
 * Key Vault since signature verification can be performed using the public
 * portion of the key but this operation is supported as a convenience for
 * callers that only have a key-reference and not the public portion of the
 * key.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key.
 *
 * @param {string} keyVersion The version of the key.
 *
 * @param {string} algorithm The signing/verification algorithm. For more
 * information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
 * Possible values include: 'PS256', 'PS384', 'PS512', 'RS256', 'RS384',
 * 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512', 'ECDSA256'
 *
 * @param {buffer} digest The digest used for signing.
 *
 * @param {buffer} signature The signature to be verified.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyVerifyResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _verify(vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyVersion === null || keyVersion === undefined || typeof keyVersion.valueOf() !== 'string') {
      throw new Error('keyVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (algorithm === null || algorithm === undefined || typeof algorithm.valueOf() !== 'string') {
      throw new Error('algorithm cannot be null or undefined and it must be of type string.');
    }
    if (algorithm !== null && algorithm !== undefined) {
      if (algorithm.length < 1)
      {
        throw new Error('"algorithm" should satisfy the constraint - "MinLength": 1');
      }
    }
    if (!Buffer.isBuffer(digest)) {
      throw new Error('digest cannot be null or undefined and it must be of type buffer.');
    }
    if (!Buffer.isBuffer(signature)) {
      throw new Error('signature cannot be null or undefined and it must be of type buffer.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((algorithm !== null && algorithm !== undefined) || (digest !== null && digest !== undefined) || (signature !== null && signature !== undefined)) {
    parameters = new client.models['KeyVerifyParameters']();
    parameters.algorithm = algorithm;
    parameters.digest = digest;
    parameters.signature = signature;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/{key-version}/verify';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  requestUrl = requestUrl.replace('{key-version}', encodeURIComponent(keyVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeyVerifyParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyVerifyResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Wraps a symmetric key using a specified key.
 *
 * The WRAP operation supports encryption of a symmetric key using a key
 * encryption key that has previously been stored in an Azure Key Vault. The
 * WRAP operation is only strictly necessary for symmetric keys stored in Azure
 * Key Vault since protection with an asymmetric key can be performed using the
 * public portion of the key. This operation is supported for asymmetric keys
 * as a convenience for callers that have a key-reference but do not have
 * access to the public key material.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key.
 *
 * @param {string} keyVersion The version of the key.
 *
 * @param {string} algorithm algorithm identifier. Possible values include:
 * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
 *
 * @param {buffer} value
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyOperationResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _wrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyVersion === null || keyVersion === undefined || typeof keyVersion.valueOf() !== 'string') {
      throw new Error('keyVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (algorithm === null || algorithm === undefined || typeof algorithm.valueOf() !== 'string') {
      throw new Error('algorithm cannot be null or undefined and it must be of type string.');
    }
    if (algorithm !== null && algorithm !== undefined) {
      if (algorithm.length < 1)
      {
        throw new Error('"algorithm" should satisfy the constraint - "MinLength": 1');
      }
    }
    if (!Buffer.isBuffer(value)) {
      throw new Error('value cannot be null or undefined and it must be of type buffer.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((algorithm !== null && algorithm !== undefined) || (value !== null && value !== undefined)) {
    parameters = new client.models['KeyOperationsParameters']();
    parameters.algorithm = algorithm;
    parameters.value = value;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/{key-version}/wrapkey';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  requestUrl = requestUrl.replace('{key-version}', encodeURIComponent(keyVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeyOperationsParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyOperationResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Unwraps a symmetric key using the specified key that was initially
 * used for wrapping that key.
 *
 * The UNWRAP operation supports decryption of a symmetric key using the target
 * key encryption key. This operation is the reverse of the WRAP operation. The
 * UNWRAP operation applies to asymmetric and symmetric keys stored in Azure
 * Key Vault since it uses the private portion of the key.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key.
 *
 * @param {string} keyVersion The version of the key.
 *
 * @param {string} algorithm algorithm identifier. Possible values include:
 * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
 *
 * @param {buffer} value
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyOperationResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _unwrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (keyVersion === null || keyVersion === undefined || typeof keyVersion.valueOf() !== 'string') {
      throw new Error('keyVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (algorithm === null || algorithm === undefined || typeof algorithm.valueOf() !== 'string') {
      throw new Error('algorithm cannot be null or undefined and it must be of type string.');
    }
    if (algorithm !== null && algorithm !== undefined) {
      if (algorithm.length < 1)
      {
        throw new Error('"algorithm" should satisfy the constraint - "MinLength": 1');
      }
    }
    if (!Buffer.isBuffer(value)) {
      throw new Error('value cannot be null or undefined and it must be of type buffer.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((algorithm !== null && algorithm !== undefined) || (value !== null && value !== undefined)) {
    parameters = new client.models['KeyOperationsParameters']();
    parameters.algorithm = algorithm;
    parameters.value = value;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'keys/{key-name}/{key-version}/unwrapkey';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  requestUrl = requestUrl.replace('{key-version}', encodeURIComponent(keyVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['KeyOperationsParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyOperationResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * List deleted keys in the specified vault. Authorization: Requires the
 * keys/list permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedKeyListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeletedKeys(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedkeys';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedKeyListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Retrieves the deleted key information plus its attributes. Authorization:
 * Requires the keys/get permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedKeyBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeletedKey(vaultBaseUrl, keyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedkeys/{key-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedKeyBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Permanently deletes the specified key. aka purges the key. Authorization:
 * Requires the keys/purge permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the key
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _purgeDeletedKey(vaultBaseUrl, keyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedkeys/{key-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Recovers the deleted key back to its current version under /keys.
 * Authorization: Requires the keys/recover permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} keyName The name of the deleted key
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverDeletedKey(vaultBaseUrl, keyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedkeys/{key-name}/recover';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{key-name}', encodeURIComponent(keyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sets a secret in a specified key vault.
 *
 * The SET operation adds a secret to the Azure Key Vault. If the named secret
 * already exists, Azure Key Vault creates a new version of that secret.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} secretName The name of the secret.
 *
 * @param {string} value The value of the secret.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {string} [options.contentType] Type of the secret value such as a
 * password.
 *
 * @param {object} [options.secretAttributes] The secret management attributes.
 *
 * @param {boolean} [options.secretAttributes.enabled] Determines whether the
 * object is enabled.
 *
 * @param {date} [options.secretAttributes.notBefore] Not before date in UTC.
 *
 * @param {date} [options.secretAttributes.expires] Expiry date in UTC.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SecretBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _setSecret(vaultBaseUrl, secretName, value, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  let contentType = (options && options.contentType !== undefined) ? options.contentType : undefined;
  let secretAttributes = (options && options.secretAttributes !== undefined) ? options.secretAttributes : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (secretName === null || secretName === undefined || typeof secretName.valueOf() !== 'string') {
      throw new Error('secretName cannot be null or undefined and it must be of type string.');
    }
    if (secretName !== null && secretName !== undefined) {
      if (secretName.match(/^[0-9a-zA-Z-]+$/) === null)
      {
        throw new Error('"secretName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z-]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (value === null || value === undefined || typeof value.valueOf() !== 'string') {
      throw new Error('value cannot be null or undefined and it must be of type string.');
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (contentType !== null && contentType !== undefined && typeof contentType.valueOf() !== 'string') {
      throw new Error('contentType must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((value !== null && value !== undefined) || (tags !== null && tags !== undefined) || (contentType !== null && contentType !== undefined) || (secretAttributes !== null && secretAttributes !== undefined)) {
    parameters = new client.models['SecretSetParameters']();
    parameters.value = value;
    parameters.tags = tags;
    parameters.contentType = contentType;
    parameters.secretAttributes = secretAttributes;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'secrets/{secret-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{secret-name}', encodeURIComponent(secretName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['SecretSetParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SecretBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a secret from a specified key vault.
 *
 * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE
 * cannot be applied to an individual version of a secret.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} secretName The name of the secret.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedSecretBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSecret(vaultBaseUrl, secretName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (secretName === null || secretName === undefined || typeof secretName.valueOf() !== 'string') {
      throw new Error('secretName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'secrets/{secret-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{secret-name}', encodeURIComponent(secretName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedSecretBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the attributes associated with a specified secret in a
 * given key vault.
 *
 * The UPDATE operation changes specified attributes of an existing stored
 * secret. Attributes that are not specified in the request are left unchanged.
 * The value of a secret itself cannot be changed.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} secretName The name of the secret.
 *
 * @param {string} secretVersion The version of the secret.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.contentType] Type of the secret value such as a
 * password.
 *
 * @param {object} [options.secretAttributes] The secret management attributes.
 *
 * @param {boolean} [options.secretAttributes.enabled] Determines whether the
 * object is enabled.
 *
 * @param {date} [options.secretAttributes.notBefore] Not before date in UTC.
 *
 * @param {date} [options.secretAttributes.expires] Expiry date in UTC.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SecretBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateSecret(vaultBaseUrl, secretName, secretVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let contentType = (options && options.contentType !== undefined) ? options.contentType : undefined;
  let secretAttributes = (options && options.secretAttributes !== undefined) ? options.secretAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (secretName === null || secretName === undefined || typeof secretName.valueOf() !== 'string') {
      throw new Error('secretName cannot be null or undefined and it must be of type string.');
    }
    if (secretVersion === null || secretVersion === undefined || typeof secretVersion.valueOf() !== 'string') {
      throw new Error('secretVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (contentType !== null && contentType !== undefined && typeof contentType.valueOf() !== 'string') {
      throw new Error('contentType must be of type string.');
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((contentType !== null && contentType !== undefined) || (secretAttributes !== null && secretAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters = new client.models['SecretUpdateParameters']();
    parameters.contentType = contentType;
    parameters.secretAttributes = secretAttributes;
    parameters.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'secrets/{secret-name}/{secret-version}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{secret-name}', encodeURIComponent(secretName));
  requestUrl = requestUrl.replace('{secret-version}', encodeURIComponent(secretVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['SecretUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SecretBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get a specified secret from a given key vault.
 *
 * The GET operation is applicable to any secret stored in Azure Key Vault.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} secretName The name of the secret.
 *
 * @param {string} secretVersion The version of the secret.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SecretBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSecret(vaultBaseUrl, secretName, secretVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (secretName === null || secretName === undefined || typeof secretName.valueOf() !== 'string') {
      throw new Error('secretName cannot be null or undefined and it must be of type string.');
    }
    if (secretVersion === null || secretVersion === undefined || typeof secretVersion.valueOf() !== 'string') {
      throw new Error('secretVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'secrets/{secret-name}/{secret-version}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{secret-name}', encodeURIComponent(secretName));
  requestUrl = requestUrl.replace('{secret-version}', encodeURIComponent(secretVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SecretBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List secrets in a specified key vault
 *
 * The LIST operation is applicable to the entire vault, however only the base
 * secret identifier and attributes are provided in the response. Individual
 * secret versions are not listed in the response.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SecretListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSecrets(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'secrets';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SecretListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List the versions of the specified secret.
 *
 * The LIST VERSIONS operation can be applied to all versions having the same
 * secret name in the same key vault. The full secret identifier and attributes
 * are provided in the response. No values are returned for the secrets and
 * only current versions of a secret are listed.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} secretName The name of the secret.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SecretListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSecretVersions(vaultBaseUrl, secretName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (secretName === null || secretName === undefined || typeof secretName.valueOf() !== 'string') {
      throw new Error('secretName cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'secrets/{secret-name}/versions';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{secret-name}', encodeURIComponent(secretName));
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SecretListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * List deleted secrets in the specified vault. Authorization: requires the
 * secrets/list permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedSecretListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeletedSecrets(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedsecrets';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedSecretListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Retrieves the deleted secret information plus its attributes. Authorization:
 * requires the secrets/get permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} secretName The name of the secret
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedSecretBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeletedSecret(vaultBaseUrl, secretName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (secretName === null || secretName === undefined || typeof secretName.valueOf() !== 'string') {
      throw new Error('secretName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedsecrets/{secret-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{secret-name}', encodeURIComponent(secretName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedSecretBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Permanently deletes the specified secret. aka purges the secret.
 * Authorization: requires the secrets/purge permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} secretName The name of the secret
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _purgeDeletedSecret(vaultBaseUrl, secretName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (secretName === null || secretName === undefined || typeof secretName.valueOf() !== 'string') {
      throw new Error('secretName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedsecrets/{secret-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{secret-name}', encodeURIComponent(secretName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Recovers the deleted secret back to its current version under /secrets.
 * Authorization: requires the secrets/recover permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} secretName The name of the deleted secret
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SecretBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverDeletedSecret(vaultBaseUrl, secretName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (secretName === null || secretName === undefined || typeof secretName.valueOf() !== 'string') {
      throw new Error('secretName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedsecrets/{secret-name}/recover';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{secret-name}', encodeURIComponent(secretName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SecretBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Requests that a backup of the specified secret be downloaded to the client.
 * Authorization: requires the secrets/backup permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} secretName The name of the secret.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupSecretResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _backupSecret(vaultBaseUrl, secretName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (secretName === null || secretName === undefined || typeof secretName.valueOf() !== 'string') {
      throw new Error('secretName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'secrets/{secret-name}/backup';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{secret-name}', encodeURIComponent(secretName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupSecretResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Restores a backed up secret to a vault. Authorization: requires the
 * secrets/restore permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {buffer} secretBundleBackup The backup blob associated with a secret
 * bundle.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SecretBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restoreSecret(vaultBaseUrl, secretBundleBackup, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (!Buffer.isBuffer(secretBundleBackup)) {
      throw new Error('secretBundleBackup cannot be null or undefined and it must be of type buffer.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if (secretBundleBackup !== null && secretBundleBackup !== undefined) {
    parameters = new client.models['SecretRestoreParameters']();
    parameters.secretBundleBackup = secretBundleBackup;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'secrets/restore';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['SecretRestoreParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SecretBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List certificates in a specified key vault
 *
 * The GetCertificates operation returns the set of certificates resources in
 * the specified key vault.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificates(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a certificate from a specified key vault.
 *
 * Deletes all versions of a certificate object along with its associated
 * policy. Delete certificate cannot be used to remove individual versions of a
 * certificate object.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedCertificateBundle} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteCertificate(vaultBaseUrl, certificateName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedCertificateBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sets the certificate contacts for the specified key vault.
 *
 * Sets the certificate contacts for the specified key vault. Authorization:
 * requires the certificates/managecontacts permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} contacts The contacts for the key vault certificate.
 *
 * @param {array} [contacts.contactList] The contact list for the vault
 * certificates.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Contacts} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _setCertificateContacts(vaultBaseUrl, contacts, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (contacts === null || contacts === undefined) {
      throw new Error('contacts cannot be null or undefined.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/contacts';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (contacts !== null && contacts !== undefined) {
      let requestModelMapper = new client.models['Contacts']().mapper();
      requestModel = client.serialize(requestModelMapper, contacts, 'contacts');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(contacts, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Contacts']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the certificate contacts for a specified key vault.
 *
 * The GetCertificateContacts operation returns the set of certificate contact
 * resources in the specified key vault.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Contacts} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificateContacts(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/contacts';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Contacts']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes the certificate contacts for a specified key vault.
 *
 * Deletes the certificate contacts for a specified key vault certificate.
 * Authorization: requires the certificates/managecontacts permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Contacts} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteCertificateContacts(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/contacts';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Contacts']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List certificate issuers for a specified key vault.
 *
 * The GetCertificateIssuers operation returns the set of certificate issuer
 * resources in the specified key vault
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateIssuerListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificateIssuers(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/issuers';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateIssuerListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sets the specified certificate issuer.
 *
 * The SetCertificateIssuer operation adds or updates the specified certificate
 * issuer.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} issuerName The name of the issuer.
 *
 * @param {string} provider The issuer provider.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.credentials] The credentials to be used for the
 * issuer.
 *
 * @param {string} [options.credentials.accountId] The user name/account
 * name/account id.
 *
 * @param {string} [options.credentials.password] The password/secret/account
 * key.
 *
 * @param {object} [options.organizationDetails] Details of the organization as
 * provided to the issuer.
 *
 * @param {string} [options.organizationDetails.id] Id of the organization.
 *
 * @param {array} [options.organizationDetails.adminDetails] Details of the
 * organization administrator.
 *
 * @param {object} [options.attributes] Attributes of the issuer object.
 *
 * @param {boolean} [options.attributes.enabled] Determines whether the issuer
 * is enabled.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IssuerBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _setCertificateIssuer(vaultBaseUrl, issuerName, provider, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let credentials = (options && options.credentials !== undefined) ? options.credentials : undefined;
  let organizationDetails = (options && options.organizationDetails !== undefined) ? options.organizationDetails : undefined;
  let attributes = (options && options.attributes !== undefined) ? options.attributes : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (issuerName === null || issuerName === undefined || typeof issuerName.valueOf() !== 'string') {
      throw new Error('issuerName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (provider === null || provider === undefined || typeof provider.valueOf() !== 'string') {
      throw new Error('provider cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameter;
  if ((provider !== null && provider !== undefined) || (credentials !== null && credentials !== undefined) || (organizationDetails !== null && organizationDetails !== undefined) || (attributes !== null && attributes !== undefined)) {
    parameter = new client.models['CertificateIssuerSetParameters']();
    parameter.provider = provider;
    parameter.credentials = credentials;
    parameter.organizationDetails = organizationDetails;
    parameter.attributes = attributes;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/issuers/{issuer-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{issuer-name}', encodeURIComponent(issuerName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameter !== null && parameter !== undefined) {
      let requestModelMapper = new client.models['CertificateIssuerSetParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameter, 'parameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IssuerBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the specified certificate issuer.
 *
 * The UpdateCertificateIssuer operation performs an update on the specified
 * certificate issuer entity.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} issuerName The name of the issuer.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.provider] The issuer provider.
 *
 * @param {object} [options.credentials] The credentials to be used for the
 * issuer.
 *
 * @param {string} [options.credentials.accountId] The user name/account
 * name/account id.
 *
 * @param {string} [options.credentials.password] The password/secret/account
 * key.
 *
 * @param {object} [options.organizationDetails] Details of the organization as
 * provided to the issuer.
 *
 * @param {string} [options.organizationDetails.id] Id of the organization.
 *
 * @param {array} [options.organizationDetails.adminDetails] Details of the
 * organization administrator.
 *
 * @param {object} [options.attributes] Attributes of the issuer object.
 *
 * @param {boolean} [options.attributes.enabled] Determines whether the issuer
 * is enabled.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IssuerBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateCertificateIssuer(vaultBaseUrl, issuerName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let provider = (options && options.provider !== undefined) ? options.provider : undefined;
  let credentials = (options && options.credentials !== undefined) ? options.credentials : undefined;
  let organizationDetails = (options && options.organizationDetails !== undefined) ? options.organizationDetails : undefined;
  let attributes = (options && options.attributes !== undefined) ? options.attributes : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (issuerName === null || issuerName === undefined || typeof issuerName.valueOf() !== 'string') {
      throw new Error('issuerName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (provider !== null && provider !== undefined && typeof provider.valueOf() !== 'string') {
      throw new Error('provider must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameter;
  if ((provider !== null && provider !== undefined) || (credentials !== null && credentials !== undefined) || (organizationDetails !== null && organizationDetails !== undefined) || (attributes !== null && attributes !== undefined)) {
    parameter = new client.models['CertificateIssuerUpdateParameters']();
    parameter.provider = provider;
    parameter.credentials = credentials;
    parameter.organizationDetails = organizationDetails;
    parameter.attributes = attributes;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/issuers/{issuer-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{issuer-name}', encodeURIComponent(issuerName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameter !== null && parameter !== undefined) {
      let requestModelMapper = new client.models['CertificateIssuerUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameter, 'parameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IssuerBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the specified certificate issuer.
 *
 * The GetCertificateIssuer operation returns the specified certificate issuer
 * resources in the specified key vault
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} issuerName The name of the issuer.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IssuerBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificateIssuer(vaultBaseUrl, issuerName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (issuerName === null || issuerName === undefined || typeof issuerName.valueOf() !== 'string') {
      throw new Error('issuerName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/issuers/{issuer-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{issuer-name}', encodeURIComponent(issuerName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IssuerBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes the specified certificate issuer.
 *
 * The DeleteCertificateIssuer operation permanently removes the specified
 * certificate issuer from the vault.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} issuerName The name of the issuer.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IssuerBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteCertificateIssuer(vaultBaseUrl, issuerName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (issuerName === null || issuerName === undefined || typeof issuerName.valueOf() !== 'string') {
      throw new Error('issuerName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/issuers/{issuer-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{issuer-name}', encodeURIComponent(issuerName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IssuerBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new certificate.
 *
 * If this is the first version, the certificate resource is created.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.certificatePolicy] The management policy for the
 * certificate.
 *
 * @param {object} [options.certificatePolicy.keyProperties] Properties of the
 * key backing a certificate.
 *
 * @param {boolean} [options.certificatePolicy.keyProperties.exportable]
 * Indicates if the private key can be exported.
 *
 * @param {string} [options.certificatePolicy.keyProperties.keyType] The key
 * type.
 *
 * @param {number} [options.certificatePolicy.keyProperties.keySize] The key
 * size in bytes. For example;  1024 or 2048.
 *
 * @param {boolean} [options.certificatePolicy.keyProperties.reuseKey]
 * Indicates if the same key pair will be used on certificate renewal.
 *
 * @param {object} [options.certificatePolicy.secretProperties] Properties of
 * the secret backing a certificate.
 *
 * @param {string} [options.certificatePolicy.secretProperties.contentType] The
 * media type (MIME type).
 *
 * @param {object} [options.certificatePolicy.x509CertificateProperties]
 * Properties of the X509 component of a certificate.
 *
 * @param {string}
 * [options.certificatePolicy.x509CertificateProperties.subject] The subject
 * name. Should be a valid X509 distinguished Name.
 *
 * @param {array} [options.certificatePolicy.x509CertificateProperties.ekus]
 * The enhanced key usage.
 *
 * @param {object}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames]
 * The subject alternative names.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
 * Email addresses.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
 * Domain names.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
 * User principal names.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.keyUsage] List of key
 * usages.
 *
 * @param {number}
 * [options.certificatePolicy.x509CertificateProperties.validityInMonths] The
 * duration that the ceritifcate is valid in months.
 *
 * @param {array} [options.certificatePolicy.lifetimeActions] Actions that will
 * be performed by Key Vault over the lifetime of a certificate.
 *
 * @param {object} [options.certificatePolicy.issuerParameters] Parameters for
 * the issuer of the X509 component of a certificate.
 *
 * @param {string} [options.certificatePolicy.issuerParameters.name] Name of
 * the referenced issuer object or reserved names; for example, 'Self' or
 * 'Unknown'.
 *
 * @param {string} [options.certificatePolicy.issuerParameters.certificateType]
 * Type of certificate to be requested from the issuer provider.
 *
 * @param {object} [options.certificatePolicy.attributes] The certificate
 * attributes.
 *
 * @param {object} [options.certificateAttributes] The attributes of the
 * certificate (optional).
 *
 * @param {boolean} [options.certificateAttributes.enabled] Determines whether
 * the object is enabled.
 *
 * @param {date} [options.certificateAttributes.notBefore] Not before date in
 * UTC.
 *
 * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateOperation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createCertificate(vaultBaseUrl, certificateName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let certificatePolicy = (options && options.certificatePolicy !== undefined) ? options.certificatePolicy : undefined;
  let certificateAttributes = (options && options.certificateAttributes !== undefined) ? options.certificateAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (certificateName !== null && certificateName !== undefined) {
      if (certificateName.match(/^[0-9a-zA-Z-]+$/) === null)
      {
        throw new Error('"certificateName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z-]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((certificatePolicy !== null && certificatePolicy !== undefined) || (certificateAttributes !== null && certificateAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters = new client.models['CertificateCreateParameters']();
    parameters.certificatePolicy = certificatePolicy;
    parameters.certificateAttributes = certificateAttributes;
    parameters.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/create';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['CertificateCreateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 202) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateOperation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Imports a certificate into a specified key vault.
 *
 * Imports an existing valid certificate, containing a private key, into Azure
 * Key Vault. The certificate to be imported can be in either PFX or PEM
 * format. If the certificate is in PEM format the PEM file must contain the
 * key as well as x509 certificates.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate.
 *
 * @param {string} base64EncodedCertificate Base64 encoded representation of
 * the certificate object to import. This certificate needs to contain the
 * private key.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.password] If the private key in
 * base64EncodedCertificate is encrypted, the password used for encryption.
 *
 * @param {object} [options.certificatePolicy] The management policy for the
 * certificate.
 *
 * @param {object} [options.certificatePolicy.keyProperties] Properties of the
 * key backing a certificate.
 *
 * @param {boolean} [options.certificatePolicy.keyProperties.exportable]
 * Indicates if the private key can be exported.
 *
 * @param {string} [options.certificatePolicy.keyProperties.keyType] The key
 * type.
 *
 * @param {number} [options.certificatePolicy.keyProperties.keySize] The key
 * size in bytes. For example;  1024 or 2048.
 *
 * @param {boolean} [options.certificatePolicy.keyProperties.reuseKey]
 * Indicates if the same key pair will be used on certificate renewal.
 *
 * @param {object} [options.certificatePolicy.secretProperties] Properties of
 * the secret backing a certificate.
 *
 * @param {string} [options.certificatePolicy.secretProperties.contentType] The
 * media type (MIME type).
 *
 * @param {object} [options.certificatePolicy.x509CertificateProperties]
 * Properties of the X509 component of a certificate.
 *
 * @param {string}
 * [options.certificatePolicy.x509CertificateProperties.subject] The subject
 * name. Should be a valid X509 distinguished Name.
 *
 * @param {array} [options.certificatePolicy.x509CertificateProperties.ekus]
 * The enhanced key usage.
 *
 * @param {object}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames]
 * The subject alternative names.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
 * Email addresses.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
 * Domain names.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
 * User principal names.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.keyUsage] List of key
 * usages.
 *
 * @param {number}
 * [options.certificatePolicy.x509CertificateProperties.validityInMonths] The
 * duration that the ceritifcate is valid in months.
 *
 * @param {array} [options.certificatePolicy.lifetimeActions] Actions that will
 * be performed by Key Vault over the lifetime of a certificate.
 *
 * @param {object} [options.certificatePolicy.issuerParameters] Parameters for
 * the issuer of the X509 component of a certificate.
 *
 * @param {string} [options.certificatePolicy.issuerParameters.name] Name of
 * the referenced issuer object or reserved names; for example, 'Self' or
 * 'Unknown'.
 *
 * @param {string} [options.certificatePolicy.issuerParameters.certificateType]
 * Type of certificate to be requested from the issuer provider.
 *
 * @param {object} [options.certificatePolicy.attributes] The certificate
 * attributes.
 *
 * @param {object} [options.certificateAttributes] The attributes of the
 * certificate (optional).
 *
 * @param {boolean} [options.certificateAttributes.enabled] Determines whether
 * the object is enabled.
 *
 * @param {date} [options.certificateAttributes.notBefore] Not before date in
 * UTC.
 *
 * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _importCertificate(vaultBaseUrl, certificateName, base64EncodedCertificate, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let password = (options && options.password !== undefined) ? options.password : undefined;
  let certificatePolicy = (options && options.certificatePolicy !== undefined) ? options.certificatePolicy : undefined;
  let certificateAttributes = (options && options.certificateAttributes !== undefined) ? options.certificateAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (certificateName !== null && certificateName !== undefined) {
      if (certificateName.match(/^[0-9a-zA-Z-]+$/) === null)
      {
        throw new Error('"certificateName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z-]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (base64EncodedCertificate === null || base64EncodedCertificate === undefined || typeof base64EncodedCertificate.valueOf() !== 'string') {
      throw new Error('base64EncodedCertificate cannot be null or undefined and it must be of type string.');
    }
    if (password !== null && password !== undefined && typeof password.valueOf() !== 'string') {
      throw new Error('password must be of type string.');
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((base64EncodedCertificate !== null && base64EncodedCertificate !== undefined) || (password !== null && password !== undefined) || (certificatePolicy !== null && certificatePolicy !== undefined) || (certificateAttributes !== null && certificateAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters = new client.models['CertificateImportParameters']();
    parameters.base64EncodedCertificate = base64EncodedCertificate;
    parameters.password = password;
    parameters.certificatePolicy = certificatePolicy;
    parameters.certificateAttributes = certificateAttributes;
    parameters.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/import';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['CertificateImportParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List the versions of a certificate.
 *
 * The GetCertificateVersions operation returns the versions of a certificate
 * in the specified key vault
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificateVersions(vaultBaseUrl, certificateName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/versions';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the policy for a certificate.
 *
 * The GetCertificatePolicy operation returns the specified certificate policy
 * resources in the specified key vault
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate in a given key
 * vault.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificatePolicy} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificatePolicy(vaultBaseUrl, certificateName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/policy';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificatePolicy']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the policy for a certificate.
 *
 * Set specified members in the certificate policy. Leave others as null.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate in the given
 * vault.
 *
 * @param {object} certificatePolicy The policy for the certificate.
 *
 * @param {object} [certificatePolicy.keyProperties] Properties of the key
 * backing a certificate.
 *
 * @param {boolean} [certificatePolicy.keyProperties.exportable] Indicates if
 * the private key can be exported.
 *
 * @param {string} [certificatePolicy.keyProperties.keyType] The key type.
 *
 * @param {number} [certificatePolicy.keyProperties.keySize] The key size in
 * bytes. For example;  1024 or 2048.
 *
 * @param {boolean} [certificatePolicy.keyProperties.reuseKey] Indicates if the
 * same key pair will be used on certificate renewal.
 *
 * @param {object} [certificatePolicy.secretProperties] Properties of the
 * secret backing a certificate.
 *
 * @param {string} [certificatePolicy.secretProperties.contentType] The media
 * type (MIME type).
 *
 * @param {object} [certificatePolicy.x509CertificateProperties] Properties of
 * the X509 component of a certificate.
 *
 * @param {string} [certificatePolicy.x509CertificateProperties.subject] The
 * subject name. Should be a valid X509 distinguished Name.
 *
 * @param {array} [certificatePolicy.x509CertificateProperties.ekus] The
 * enhanced key usage.
 *
 * @param {object}
 * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames] The
 * subject alternative names.
 *
 * @param {array}
 * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
 * Email addresses.
 *
 * @param {array}
 * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
 * Domain names.
 *
 * @param {array}
 * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
 * User principal names.
 *
 * @param {array} [certificatePolicy.x509CertificateProperties.keyUsage] List
 * of key usages.
 *
 * @param {number}
 * [certificatePolicy.x509CertificateProperties.validityInMonths] The duration
 * that the ceritifcate is valid in months.
 *
 * @param {array} [certificatePolicy.lifetimeActions] Actions that will be
 * performed by Key Vault over the lifetime of a certificate.
 *
 * @param {object} [certificatePolicy.issuerParameters] Parameters for the
 * issuer of the X509 component of a certificate.
 *
 * @param {string} [certificatePolicy.issuerParameters.name] Name of the
 * referenced issuer object or reserved names; for example, 'Self' or
 * 'Unknown'.
 *
 * @param {string} [certificatePolicy.issuerParameters.certificateType] Type of
 * certificate to be requested from the issuer provider.
 *
 * @param {object} [certificatePolicy.attributes] The certificate attributes.
 *
 * @param {boolean} [certificatePolicy.attributes.enabled] Determines whether
 * the object is enabled.
 *
 * @param {date} [certificatePolicy.attributes.notBefore] Not before date in
 * UTC.
 *
 * @param {date} [certificatePolicy.attributes.expires] Expiry date in UTC.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificatePolicy} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateCertificatePolicy(vaultBaseUrl, certificateName, certificatePolicy, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (certificatePolicy === null || certificatePolicy === undefined) {
      throw new Error('certificatePolicy cannot be null or undefined.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/policy';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (certificatePolicy !== null && certificatePolicy !== undefined) {
      let requestModelMapper = new client.models['CertificatePolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, certificatePolicy, 'certificatePolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(certificatePolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificatePolicy']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the specified attributes associated with the given
 * certificate.
 *
 * The UpdateCertificate operation applies the specified update on the given
 * certificate; note the only elements being updated are the certificate's
 * attributes.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate in the given key
 * vault.
 *
 * @param {string} certificateVersion The version of the certificate.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.certificatePolicy] The management policy for the
 * certificate.
 *
 * @param {object} [options.certificatePolicy.keyProperties] Properties of the
 * key backing a certificate.
 *
 * @param {boolean} [options.certificatePolicy.keyProperties.exportable]
 * Indicates if the private key can be exported.
 *
 * @param {string} [options.certificatePolicy.keyProperties.keyType] The key
 * type.
 *
 * @param {number} [options.certificatePolicy.keyProperties.keySize] The key
 * size in bytes. For example;  1024 or 2048.
 *
 * @param {boolean} [options.certificatePolicy.keyProperties.reuseKey]
 * Indicates if the same key pair will be used on certificate renewal.
 *
 * @param {object} [options.certificatePolicy.secretProperties] Properties of
 * the secret backing a certificate.
 *
 * @param {string} [options.certificatePolicy.secretProperties.contentType] The
 * media type (MIME type).
 *
 * @param {object} [options.certificatePolicy.x509CertificateProperties]
 * Properties of the X509 component of a certificate.
 *
 * @param {string}
 * [options.certificatePolicy.x509CertificateProperties.subject] The subject
 * name. Should be a valid X509 distinguished Name.
 *
 * @param {array} [options.certificatePolicy.x509CertificateProperties.ekus]
 * The enhanced key usage.
 *
 * @param {object}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames]
 * The subject alternative names.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
 * Email addresses.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
 * Domain names.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
 * User principal names.
 *
 * @param {array}
 * [options.certificatePolicy.x509CertificateProperties.keyUsage] List of key
 * usages.
 *
 * @param {number}
 * [options.certificatePolicy.x509CertificateProperties.validityInMonths] The
 * duration that the ceritifcate is valid in months.
 *
 * @param {array} [options.certificatePolicy.lifetimeActions] Actions that will
 * be performed by Key Vault over the lifetime of a certificate.
 *
 * @param {object} [options.certificatePolicy.issuerParameters] Parameters for
 * the issuer of the X509 component of a certificate.
 *
 * @param {string} [options.certificatePolicy.issuerParameters.name] Name of
 * the referenced issuer object or reserved names; for example, 'Self' or
 * 'Unknown'.
 *
 * @param {string} [options.certificatePolicy.issuerParameters.certificateType]
 * Type of certificate to be requested from the issuer provider.
 *
 * @param {object} [options.certificatePolicy.attributes] The certificate
 * attributes.
 *
 * @param {object} [options.certificateAttributes] The attributes of the
 * certificate (optional).
 *
 * @param {boolean} [options.certificateAttributes.enabled] Determines whether
 * the object is enabled.
 *
 * @param {date} [options.certificateAttributes.notBefore] Not before date in
 * UTC.
 *
 * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateCertificate(vaultBaseUrl, certificateName, certificateVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let certificatePolicy = (options && options.certificatePolicy !== undefined) ? options.certificatePolicy : undefined;
  let certificateAttributes = (options && options.certificateAttributes !== undefined) ? options.certificateAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (certificateVersion === null || certificateVersion === undefined || typeof certificateVersion.valueOf() !== 'string') {
      throw new Error('certificateVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((certificatePolicy !== null && certificatePolicy !== undefined) || (certificateAttributes !== null && certificateAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters = new client.models['CertificateUpdateParameters']();
    parameters.certificatePolicy = certificatePolicy;
    parameters.certificateAttributes = certificateAttributes;
    parameters.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/{certificate-version}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  requestUrl = requestUrl.replace('{certificate-version}', encodeURIComponent(certificateVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['CertificateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets information about a specified certificate. Authorization: requires the
 * certificates/get permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate in the given
 * vault.
 *
 * @param {string} certificateVersion The version of the certificate.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificate(vaultBaseUrl, certificateName, certificateVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (certificateVersion === null || certificateVersion === undefined || typeof certificateVersion.valueOf() !== 'string') {
      throw new Error('certificateVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/{certificate-version}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  requestUrl = requestUrl.replace('{certificate-version}', encodeURIComponent(certificateVersion));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Updates a certificate operation. Authorization: requires the
 * certificates/update permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate.
 *
 * @param {boolean} cancellationRequested Indicates if cancellation was
 * requested on the certificate operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateOperation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateCertificateOperation(vaultBaseUrl, certificateName, cancellationRequested, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (cancellationRequested === null || cancellationRequested === undefined || typeof cancellationRequested !== 'boolean') {
      throw new Error('cancellationRequested cannot be null or undefined and it must be of type boolean.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let certificateOperation;
  if (cancellationRequested !== null && cancellationRequested !== undefined) {
    certificateOperation = new client.models['CertificateOperationUpdateParameter']();
    certificateOperation.cancellationRequested = cancellationRequested;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/pending';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (certificateOperation !== null && certificateOperation !== undefined) {
      let requestModelMapper = new client.models['CertificateOperationUpdateParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, certificateOperation, 'certificateOperation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(certificateOperation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateOperation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the operation associated with a specified certificate. Authorization:
 * requires the certificates/get permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateOperation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificateOperation(vaultBaseUrl, certificateName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/pending';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateOperation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes the operation for a specified certificate. Authorization: requires
 * the certificates/update permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateOperation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteCertificateOperation(vaultBaseUrl, certificateName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/pending';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateOperation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Merges a certificate or a certificate chain with a key pair
 * existing on the server.
 *
 * The MergeCertificate operation performs the merging of a certificate or
 * certificate chain with a key pair currently available in the service.
 * Authorization: requires the certificates/update permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate.
 *
 * @param {array} x509Certificates The certificate or the certificate chain to
 * merge.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.certificateAttributes] The attributes of the
 * certificate (optional).
 *
 * @param {boolean} [options.certificateAttributes.enabled] Determines whether
 * the object is enabled.
 *
 * @param {date} [options.certificateAttributes.notBefore] Not before date in
 * UTC.
 *
 * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _mergeCertificate(vaultBaseUrl, certificateName, x509Certificates, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let certificateAttributes = (options && options.certificateAttributes !== undefined) ? options.certificateAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (!Array.isArray(x509Certificates)) {
      throw new Error('x509Certificates cannot be null or undefined and it must be of type array.');
    }
    for (let i = 0; i < x509Certificates.length; i++) {
      if (x509Certificates[i] && !Buffer.isBuffer(x509Certificates[i])) {
        throw new Error('x509Certificates[i] must be of type buffer.');
      }
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((x509Certificates !== null && x509Certificates !== undefined) || (certificateAttributes !== null && certificateAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters = new client.models['CertificateMergeParameters']();
    parameters.x509Certificates = x509Certificates;
    parameters.certificateAttributes = certificateAttributes;
    parameters.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates/{certificate-name}/pending/merge';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['CertificateMergeParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the deleted certificates in the specified vault, currently
 * available for recovery.
 *
 * The GetDeletedCertificates operation retrieves the certificates in the
 * current vault which are in a deleted state and ready for recovery or
 * purging.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedCertificateListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeletedCertificates(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedcertificates';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedCertificateListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves information about the specified deleted certificate.
 *
 * The GetDeletedCertificate operation retrieves the deleted certificate
 * information plus its attributes, such as retention interval, scheduled
 * permanent deletion and the current deletion recovery level.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedCertificateBundle} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeletedCertificate(vaultBaseUrl, certificateName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedcertificates/{certificate-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedCertificateBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Permanently deletes the specified deleted certificate.
 *
 * The PurgeDeletedCertificate operation performs an irreversible deletion of
 * the specified certificate, without possibility for recovery. The operation
 * is not available if the recovery level does not specify 'Purgeable'.
 * Requires the explicit granting of the 'purge' permission.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the certificate
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _purgeDeletedCertificate(vaultBaseUrl, certificateName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedcertificates/{certificate-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Recovers the deleted certificate back to its current version under
 * /certificates.
 *
 * The RecoverDeletedCertificate operation performs the reversal of the Delete
 * operation. The operation is applicable in vaults enabled for soft-delete,
 * and must be issued during the retention interval (available in the deleted
 * certificate's attributes).
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} certificateName The name of the deleted certificate
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverDeletedCertificate(vaultBaseUrl, certificateName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (certificateName === null || certificateName === undefined || typeof certificateName.valueOf() !== 'string') {
      throw new Error('certificateName cannot be null or undefined and it must be of type string.');
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'deletedcertificates/{certificate-name}/recover';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{certificate-name}', encodeURIComponent(certificateName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * List storage accounts managed by specified key vault
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getStorageAccounts(vaultBaseUrl, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes a storage account.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteStorageAccount(vaultBaseUrl, storageAccountName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets information about a specified storage account.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getStorageAccount(vaultBaseUrl, storageAccountName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Creates or updates a new storage account.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {string} resourceId Storage account resource id.
 *
 * @param {string} activeKeyName Current active storage account key name.
 *
 * @param {boolean} autoRegenerateKey whether keyvault should manage the
 * storage account for the user.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.regenerationPeriod] The key regeneration time
 * duration specified in ISO-8601 format.
 *
 * @param {object} [options.storageAccountAttributes] The attributes of the
 * storage account.
 *
 * @param {boolean} [options.storageAccountAttributes.enabled] the enabled
 * state of the object.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _setStorageAccount(vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let regenerationPeriod = (options && options.regenerationPeriod !== undefined) ? options.regenerationPeriod : undefined;
  let storageAccountAttributes = (options && options.storageAccountAttributes !== undefined) ? options.storageAccountAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (resourceId === null || resourceId === undefined || typeof resourceId.valueOf() !== 'string') {
      throw new Error('resourceId cannot be null or undefined and it must be of type string.');
    }
    if (activeKeyName === null || activeKeyName === undefined || typeof activeKeyName.valueOf() !== 'string') {
      throw new Error('activeKeyName cannot be null or undefined and it must be of type string.');
    }
    if (autoRegenerateKey === null || autoRegenerateKey === undefined || typeof autoRegenerateKey !== 'boolean') {
      throw new Error('autoRegenerateKey cannot be null or undefined and it must be of type boolean.');
    }
    if (regenerationPeriod !== null && regenerationPeriod !== undefined && typeof regenerationPeriod.valueOf() !== 'string') {
      throw new Error('regenerationPeriod must be of type string.');
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((resourceId !== null && resourceId !== undefined) || (activeKeyName !== null && activeKeyName !== undefined) || (autoRegenerateKey !== null && autoRegenerateKey !== undefined) || (regenerationPeriod !== null && regenerationPeriod !== undefined) || (storageAccountAttributes !== null && storageAccountAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters = new client.models['StorageAccountCreateParameters']();
    parameters.resourceId = resourceId;
    parameters.activeKeyName = activeKeyName;
    parameters.autoRegenerateKey = autoRegenerateKey;
    parameters.regenerationPeriod = regenerationPeriod;
    parameters.storageAccountAttributes = storageAccountAttributes;
    parameters.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['StorageAccountCreateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Updates the specified attributes associated with the given storage account.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.activeKeyName] The current active storage account
 * key name.
 *
 * @param {boolean} [options.autoRegenerateKey] whether keyvault should manage
 * the storage account for the user.
 *
 * @param {string} [options.regenerationPeriod] The key regeneration time
 * duration specified in ISO-8601 format.
 *
 * @param {object} [options.storageAccountAttributes] The attributes of the
 * storage account.
 *
 * @param {boolean} [options.storageAccountAttributes.enabled] the enabled
 * state of the object.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateStorageAccount(vaultBaseUrl, storageAccountName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let activeKeyName = (options && options.activeKeyName !== undefined) ? options.activeKeyName : undefined;
  let autoRegenerateKey = (options && options.autoRegenerateKey !== undefined) ? options.autoRegenerateKey : undefined;
  let regenerationPeriod = (options && options.regenerationPeriod !== undefined) ? options.regenerationPeriod : undefined;
  let storageAccountAttributes = (options && options.storageAccountAttributes !== undefined) ? options.storageAccountAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (activeKeyName !== null && activeKeyName !== undefined && typeof activeKeyName.valueOf() !== 'string') {
      throw new Error('activeKeyName must be of type string.');
    }
    if (autoRegenerateKey !== null && autoRegenerateKey !== undefined && typeof autoRegenerateKey !== 'boolean') {
      throw new Error('autoRegenerateKey must be of type boolean.');
    }
    if (regenerationPeriod !== null && regenerationPeriod !== undefined && typeof regenerationPeriod.valueOf() !== 'string') {
      throw new Error('regenerationPeriod must be of type string.');
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement in tags) {
        if (tags[valueElement] !== null && tags[valueElement] !== undefined && typeof tags[valueElement].valueOf() !== 'string') {
          throw new Error('tags[valueElement] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if ((activeKeyName !== null && activeKeyName !== undefined) || (autoRegenerateKey !== null && autoRegenerateKey !== undefined) || (regenerationPeriod !== null && regenerationPeriod !== undefined) || (storageAccountAttributes !== null && storageAccountAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters = new client.models['StorageAccountUpdateParameters']();
    parameters.activeKeyName = activeKeyName;
    parameters.autoRegenerateKey = autoRegenerateKey;
    parameters.regenerationPeriod = regenerationPeriod;
    parameters.storageAccountAttributes = storageAccountAttributes;
    parameters.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['StorageAccountUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Regenerates the specified key value for the given storage account.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {string} keyName The storage account key name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _regenerateStorageAccountKey(vaultBaseUrl, storageAccountName, keyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (keyName === null || keyName === undefined || typeof keyName.valueOf() !== 'string') {
      throw new Error('keyName cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters;
  if (keyName !== null && keyName !== undefined) {
    parameters = new client.models['StorageAccountRegenerteKeyParameters']();
    parameters.keyName = keyName;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}/regeneratekey';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['StorageAccountRegenerteKeyParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * List storage SAS definitions for the given storage account.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.maxresults] Maximum number of results to return in
 * a page. If not specified the service will return up to 25 results.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SasDefinitionListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSasDefinitions(vaultBaseUrl, storageAccountName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
      throw new Error('maxresults must be of type number.');
    }
    if (maxresults !== null && maxresults !== undefined) {
      if (maxresults > 25)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMaximum": 25');
      }
      if (maxresults < 1)
      {
        throw new Error('"maxresults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}/sas';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  let queryParameters = [];
  if (maxresults !== null && maxresults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxresults.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SasDefinitionListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes a SAS definition from a specified storage account.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {string} sasDefinitionName The name of the SAS definition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SasDefinitionBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (sasDefinitionName === null || sasDefinitionName === undefined || typeof sasDefinitionName.valueOf() !== 'string') {
      throw new Error('sasDefinitionName cannot be null or undefined and it must be of type string.');
    }
    if (sasDefinitionName !== null && sasDefinitionName !== undefined) {
      if (sasDefinitionName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"sasDefinitionName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}/sas/{sas-definition-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  requestUrl = requestUrl.replace('{sas-definition-name}', encodeURIComponent(sasDefinitionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SasDefinitionBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets information about a SAS definition for the specified storage account.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {string} sasDefinitionName The name of the SAS definition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SasDefinitionBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (sasDefinitionName === null || sasDefinitionName === undefined || typeof sasDefinitionName.valueOf() !== 'string') {
      throw new Error('sasDefinitionName cannot be null or undefined and it must be of type string.');
    }
    if (sasDefinitionName !== null && sasDefinitionName !== undefined) {
      if (sasDefinitionName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"sasDefinitionName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}/sas/{sas-definition-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  requestUrl = requestUrl.replace('{sas-definition-name}', encodeURIComponent(sasDefinitionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SasDefinitionBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Creates or updates a new SAS definition for the specified storage account.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {string} sasDefinitionName The name of the SAS definition.
 *
 * @param {object} parameters Sas definition creation metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.sasDefinitionAttributes] The attributes of the SAS
 * definition.
 *
 * @param {boolean} [options.sasDefinitionAttributes.enabled] the enabled state
 * of the object.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SasDefinitionBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _setSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, parameters, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let sasDefinitionAttributes = (options && options.sasDefinitionAttributes !== undefined) ? options.sasDefinitionAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (sasDefinitionName === null || sasDefinitionName === undefined || typeof sasDefinitionName.valueOf() !== 'string') {
      throw new Error('sasDefinitionName cannot be null or undefined and it must be of type string.');
    }
    if (sasDefinitionName !== null && sasDefinitionName !== undefined) {
      if (sasDefinitionName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"sasDefinitionName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (parameters === null || parameters === undefined || typeof parameters !== 'object') {
      throw new Error('parameters cannot be null or undefined and it must be of type object.');
    }
    for(let valueElement in parameters) {
      if (parameters[valueElement] !== null && parameters[valueElement] !== undefined && typeof parameters[valueElement].valueOf() !== 'string') {
        throw new Error('parameters[valueElement] must be of type string.');
      }
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement1 in tags) {
        if (tags[valueElement1] !== null && tags[valueElement1] !== undefined && typeof tags[valueElement1].valueOf() !== 'string') {
          throw new Error('tags[valueElement1] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters1;
  if ((parameters !== null && parameters !== undefined) || (sasDefinitionAttributes !== null && sasDefinitionAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters1 = new client.models['SasDefinitionCreateParameters']();
    parameters1.parameters = parameters;
    parameters1.sasDefinitionAttributes = sasDefinitionAttributes;
    parameters1.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}/sas/{sas-definition-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  requestUrl = requestUrl.replace('{sas-definition-name}', encodeURIComponent(sasDefinitionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters1 !== null && parameters1 !== undefined) {
      let requestModelMapper = new client.models['SasDefinitionCreateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters1, 'parameters1');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters1, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SasDefinitionBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Updates the specified attributes associated with the given SAS definition.
 *
 * @param {string} vaultBaseUrl The vault name, for example
 * https://myvault.vault.azure.net.
 *
 * @param {string} storageAccountName The name of the storage account.
 *
 * @param {string} sasDefinitionName The name of the SAS definition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.parameters] Sas definition update metadata in the
 * form of key-value pairs.
 *
 * @param {object} [options.sasDefinitionAttributes] The attributes of the SAS
 * definition.
 *
 * @param {boolean} [options.sasDefinitionAttributes.enabled] the enabled state
 * of the object.
 *
 * @param {object} [options.tags] Application specific metadata in the form of
 * key-value pairs.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SasDefinitionBundle} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let parameters = (options && options.parameters !== undefined) ? options.parameters : undefined;
  let sasDefinitionAttributes = (options && options.sasDefinitionAttributes !== undefined) ? options.sasDefinitionAttributes : undefined;
  let tags = (options && options.tags !== undefined) ? options.tags : undefined;
  // Validate
  try {
    if (vaultBaseUrl === null || vaultBaseUrl === undefined || typeof vaultBaseUrl.valueOf() !== 'string') {
      throw new Error('vaultBaseUrl cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName === null || storageAccountName === undefined || typeof storageAccountName.valueOf() !== 'string') {
      throw new Error('storageAccountName cannot be null or undefined and it must be of type string.');
    }
    if (storageAccountName !== null && storageAccountName !== undefined) {
      if (storageAccountName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"storageAccountName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (sasDefinitionName === null || sasDefinitionName === undefined || typeof sasDefinitionName.valueOf() !== 'string') {
      throw new Error('sasDefinitionName cannot be null or undefined and it must be of type string.');
    }
    if (sasDefinitionName !== null && sasDefinitionName !== undefined) {
      if (sasDefinitionName.match(/^[0-9a-zA-Z]+$/) === null)
      {
        throw new Error('"sasDefinitionName" should satisfy the constraint - "Pattern": /^[0-9a-zA-Z]+$/');
      }
    }
    if (this.apiVersion === null || this.apiVersion === undefined || typeof this.apiVersion.valueOf() !== 'string') {
      throw new Error('this.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (parameters && typeof parameters === 'object') {
      for(let valueElement in parameters) {
        if (parameters[valueElement] !== null && parameters[valueElement] !== undefined && typeof parameters[valueElement].valueOf() !== 'string') {
          throw new Error('parameters[valueElement] must be of type string.');
        }
      }
    }
    if (tags && typeof tags === 'object') {
      for(let valueElement1 in tags) {
        if (tags[valueElement1] !== null && tags[valueElement1] !== undefined && typeof tags[valueElement1].valueOf() !== 'string') {
          throw new Error('tags[valueElement1] must be of type string.');
        }
      }
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let parameters1;
  if ((parameters !== null && parameters !== undefined) || (sasDefinitionAttributes !== null && sasDefinitionAttributes !== undefined) || (tags !== null && tags !== undefined)) {
    parameters1 = new client.models['SasDefinitionUpdateParameters']();
    parameters1.parameters = parameters;
    parameters1.sasDefinitionAttributes = sasDefinitionAttributes;
    parameters1.tags = tags;
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'storage/{storage-account-name}/sas/{sas-definition-name}';
  requestUrl = requestUrl.replace('{vaultBaseUrl}', vaultBaseUrl);
  requestUrl = requestUrl.replace('{storage-account-name}', encodeURIComponent(storageAccountName));
  requestUrl = requestUrl.replace('{sas-definition-name}', encodeURIComponent(sasDefinitionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters1 !== null && parameters1 !== undefined) {
      let requestModelMapper = new client.models['SasDefinitionUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters1, 'parameters1');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters1, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SasDefinitionBundle']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves a list of individual key versions with the same key name.
 *
 * The full key identifier, attributes, and tags are provided in the response.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getKeyVersionsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List keys in the specified vault.
 *
 * Retrieves a list of the keys in the Key Vault as JSON Web Key structures
 * that contain the public part of a stored key. The LIST operation is
 * applicable to all key types, however only the base key
 * identifier,attributes, and tags are provided in the response. Individual
 * versions of a key are not listed in the response. Authorization: Requires
 * the keys/list permission.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link KeyListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getKeysNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * List deleted keys in the specified vault. Authorization: Requires the
 * keys/list permission.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedKeyListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeletedKeysNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedKeyListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List secrets in a specified key vault
 *
 * The LIST operation is applicable to the entire vault, however only the base
 * secret identifier and attributes are provided in the response. Individual
 * secret versions are not listed in the response.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SecretListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSecretsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SecretListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List the versions of the specified secret.
 *
 * The LIST VERSIONS operation can be applied to all versions having the same
 * secret name in the same key vault. The full secret identifier and attributes
 * are provided in the response. No values are returned for the secrets and
 * only current versions of a secret are listed.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SecretListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSecretVersionsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SecretListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * List deleted secrets in the specified vault. Authorization: requires the
 * secrets/list permission.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedSecretListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeletedSecretsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedSecretListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List certificates in a specified key vault
 *
 * The GetCertificates operation returns the set of certificates resources in
 * the specified key vault.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificatesNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List certificate issuers for a specified key vault.
 *
 * The GetCertificateIssuers operation returns the set of certificate issuer
 * resources in the specified key vault
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateIssuerListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificateIssuersNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateIssuerListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List the versions of a certificate.
 *
 * The GetCertificateVersions operation returns the versions of a certificate
 * in the specified key vault
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CertificateListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCertificateVersionsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CertificateListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the deleted certificates in the specified vault, currently
 * available for recovery.
 *
 * The GetDeletedCertificates operation retrieves the certificates in the
 * current vault which are in a deleted state and ready for recovery or
 * purging.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeletedCertificateListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeletedCertificatesNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletedCertificateListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * List storage accounts managed by specified key vault
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getStorageAccountsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * List storage SAS definitions for the given storage account.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SasDefinitionListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSasDefinitionsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.acceptLanguage !== null && this.acceptLanguage !== undefined && typeof this.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.acceptLanguage !== undefined && this.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['KeyVaultError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SasDefinitionListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a KeyVaultClient. */
class KeyVaultClient extends ServiceClient {
  /**
   * Create a KeyVaultClient.
   * @param {credentials} credentials - Credentials needed for the client to connect to Azure.
   * @param {object} [options] - The parameter options
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   * @param {string} [options.acceptLanguage] - Gets or sets the preferred language for the response.
   * @param {number} [options.longRunningOperationRetryTimeout] - Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
   * @param {boolean} [options.generateClientRequestId] - When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
   */
  constructor(credentials, options) {
    if (credentials === null || credentials === undefined) {
      throw new Error('\'credentials\' cannot be null.');
    }

    if (!options) options = {};

    super(credentials, options);

    this.apiVersion = '2016-10-01';
    this.acceptLanguage = 'en-US';
    this.longRunningOperationRetryTimeout = 30;
    this.generateClientRequestId = true;
    this.baseUri = '{vaultBaseUrl}';
    this.credentials = credentials;

    let packageInfo = this.getPackageJsonInfo(__dirname);
    this.addUserAgentInfo(`${packageInfo.name}/${packageInfo.version}`);
    if(options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
      this.acceptLanguage = options.acceptLanguage;
    }
    if(options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
      this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
    }
    if(options.generateClientRequestId !== null && options.generateClientRequestId !== undefined) {
      this.generateClientRequestId = options.generateClientRequestId;
    }
    this.models = models;
    this._createKey = _createKey;
    this._importKey = _importKey;
    this._deleteKey = _deleteKey;
    this._updateKey = _updateKey;
    this._getKey = _getKey;
    this._getKeyVersions = _getKeyVersions;
    this._getKeys = _getKeys;
    this._backupKey = _backupKey;
    this._restoreKey = _restoreKey;
    this._encrypt = _encrypt;
    this._decrypt = _decrypt;
    this._sign = _sign;
    this._verify = _verify;
    this._wrapKey = _wrapKey;
    this._unwrapKey = _unwrapKey;
    this._getDeletedKeys = _getDeletedKeys;
    this._getDeletedKey = _getDeletedKey;
    this._purgeDeletedKey = _purgeDeletedKey;
    this._recoverDeletedKey = _recoverDeletedKey;
    this._setSecret = _setSecret;
    this._deleteSecret = _deleteSecret;
    this._updateSecret = _updateSecret;
    this._getSecret = _getSecret;
    this._getSecrets = _getSecrets;
    this._getSecretVersions = _getSecretVersions;
    this._getDeletedSecrets = _getDeletedSecrets;
    this._getDeletedSecret = _getDeletedSecret;
    this._purgeDeletedSecret = _purgeDeletedSecret;
    this._recoverDeletedSecret = _recoverDeletedSecret;
    this._backupSecret = _backupSecret;
    this._restoreSecret = _restoreSecret;
    this._getCertificates = _getCertificates;
    this._deleteCertificate = _deleteCertificate;
    this._setCertificateContacts = _setCertificateContacts;
    this._getCertificateContacts = _getCertificateContacts;
    this._deleteCertificateContacts = _deleteCertificateContacts;
    this._getCertificateIssuers = _getCertificateIssuers;
    this._setCertificateIssuer = _setCertificateIssuer;
    this._updateCertificateIssuer = _updateCertificateIssuer;
    this._getCertificateIssuer = _getCertificateIssuer;
    this._deleteCertificateIssuer = _deleteCertificateIssuer;
    this._createCertificate = _createCertificate;
    this._importCertificate = _importCertificate;
    this._getCertificateVersions = _getCertificateVersions;
    this._getCertificatePolicy = _getCertificatePolicy;
    this._updateCertificatePolicy = _updateCertificatePolicy;
    this._updateCertificate = _updateCertificate;
    this._getCertificate = _getCertificate;
    this._updateCertificateOperation = _updateCertificateOperation;
    this._getCertificateOperation = _getCertificateOperation;
    this._deleteCertificateOperation = _deleteCertificateOperation;
    this._mergeCertificate = _mergeCertificate;
    this._getDeletedCertificates = _getDeletedCertificates;
    this._getDeletedCertificate = _getDeletedCertificate;
    this._purgeDeletedCertificate = _purgeDeletedCertificate;
    this._recoverDeletedCertificate = _recoverDeletedCertificate;
    this._getStorageAccounts = _getStorageAccounts;
    this._deleteStorageAccount = _deleteStorageAccount;
    this._getStorageAccount = _getStorageAccount;
    this._setStorageAccount = _setStorageAccount;
    this._updateStorageAccount = _updateStorageAccount;
    this._regenerateStorageAccountKey = _regenerateStorageAccountKey;
    this._getSasDefinitions = _getSasDefinitions;
    this._deleteSasDefinition = _deleteSasDefinition;
    this._getSasDefinition = _getSasDefinition;
    this._setSasDefinition = _setSasDefinition;
    this._updateSasDefinition = _updateSasDefinition;
    this._getKeyVersionsNext = _getKeyVersionsNext;
    this._getKeysNext = _getKeysNext;
    this._getDeletedKeysNext = _getDeletedKeysNext;
    this._getSecretsNext = _getSecretsNext;
    this._getSecretVersionsNext = _getSecretVersionsNext;
    this._getDeletedSecretsNext = _getDeletedSecretsNext;
    this._getCertificatesNext = _getCertificatesNext;
    this._getCertificateIssuersNext = _getCertificateIssuersNext;
    this._getCertificateVersionsNext = _getCertificateVersionsNext;
    this._getDeletedCertificatesNext = _getDeletedCertificatesNext;
    this._getStorageAccountsNext = _getStorageAccountsNext;
    this._getSasDefinitionsNext = _getSasDefinitionsNext;
    msRest.addSerializationMixin(this);
  }

  /**
   * @summary Creates a new key, stores it, then returns key parameters and
   * attributes to the client.
   *
   * The create key operation can be used to create any key type in Azure Key
   * Vault. If the named key already exists, Azure Key Vault creates a new
   * version of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name for the new key. The system will generate
   * the version name for the new key.
   *
   * @param {string} kty The type of key to create. For valid values, see
   * JsonWebKeyType. Possible values include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM',
   * 'oct'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.keySize] The key size in bytes. For example, 1024
   * or 2048.
   *
   * @param {array} [options.keyOps]
   *
   * @param {object} [options.keyAttributes]
   *
   * @param {boolean} [options.keyAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.keyAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.keyAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {string} [options.curve] Elliptic curve name. For valid values, see
   * JsonWebKeyCurveName. Possible values include: 'P-256', 'P-384', 'P-521',
   * 'SECP256K1'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createKeyWithHttpOperationResponse(vaultBaseUrl, keyName, kty, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createKey(vaultBaseUrl, keyName, kty, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new key, stores it, then returns key parameters and
   * attributes to the client.
   *
   * The create key operation can be used to create any key type in Azure Key
   * Vault. If the named key already exists, Azure Key Vault creates a new
   * version of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name for the new key. The system will generate
   * the version name for the new key.
   *
   * @param {string} kty The type of key to create. For valid values, see
   * JsonWebKeyType. Possible values include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM',
   * 'oct'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.keySize] The key size in bytes. For example, 1024
   * or 2048.
   *
   * @param {array} [options.keyOps]
   *
   * @param {object} [options.keyAttributes]
   *
   * @param {boolean} [options.keyAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.keyAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.keyAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {string} [options.curve] Elliptic curve name. For valid values, see
   * JsonWebKeyCurveName. Possible values include: 'P-256', 'P-384', 'P-521',
   * 'SECP256K1'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createKey(vaultBaseUrl, keyName, kty, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createKey(vaultBaseUrl, keyName, kty, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createKey(vaultBaseUrl, keyName, kty, options, optionalCallback);
    }
  }

  /**
   * @summary Imports an externally created key, stores it, and returns key
   * parameters and attributes to the client.
   *
   * The import key operation may be used to import any key type into an Azure
   * Key Vault. If the named key already exists, Azure Key Vault creates a new
   * version of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName Name for the imported key.
   *
   * @param {object} key The Json web key
   *
   * @param {string} [key.kid] Key identifier.
   *
   * @param {string} [key.kty] JsonWebKey key type (kty). Possible values
   * include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'
   *
   * @param {array} [key.keyOps]
   *
   * @param {buffer} [key.n] RSA modulus.
   *
   * @param {buffer} [key.e] RSA public exponent.
   *
   * @param {buffer} [key.d] RSA private exponent, or the D component of an EC
   * private key.
   *
   * @param {buffer} [key.dp] RSA private key parameter.
   *
   * @param {buffer} [key.dq] RSA private key parameter.
   *
   * @param {buffer} [key.qi] RSA private key parameter.
   *
   * @param {buffer} [key.p] RSA secret prime.
   *
   * @param {buffer} [key.q] RSA secret prime, with p < q.
   *
   * @param {buffer} [key.k] Symmetric key.
   *
   * @param {buffer} [key.t] HSM Token, used with 'Bring Your Own Key'.
   *
   * @param {string} [key.crv] Elliptic curve name. For valid values, see
   * JsonWebKeyCurveName. Possible values include: 'P-256', 'P-384', 'P-521',
   * 'SECP256K1'
   *
   * @param {buffer} [key.x] X component of an EC public key.
   *
   * @param {buffer} [key.y] Y component of an EC public key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.hsm] Whether to import as a hardware key (HSM) or
   * software key.
   *
   * @param {object} [options.keyAttributes] The key management attributes.
   *
   * @param {boolean} [options.keyAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.keyAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.keyAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  importKeyWithHttpOperationResponse(vaultBaseUrl, keyName, key, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._importKey(vaultBaseUrl, keyName, key, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Imports an externally created key, stores it, and returns key
   * parameters and attributes to the client.
   *
   * The import key operation may be used to import any key type into an Azure
   * Key Vault. If the named key already exists, Azure Key Vault creates a new
   * version of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName Name for the imported key.
   *
   * @param {object} key The Json web key
   *
   * @param {string} [key.kid] Key identifier.
   *
   * @param {string} [key.kty] JsonWebKey key type (kty). Possible values
   * include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'
   *
   * @param {array} [key.keyOps]
   *
   * @param {buffer} [key.n] RSA modulus.
   *
   * @param {buffer} [key.e] RSA public exponent.
   *
   * @param {buffer} [key.d] RSA private exponent, or the D component of an EC
   * private key.
   *
   * @param {buffer} [key.dp] RSA private key parameter.
   *
   * @param {buffer} [key.dq] RSA private key parameter.
   *
   * @param {buffer} [key.qi] RSA private key parameter.
   *
   * @param {buffer} [key.p] RSA secret prime.
   *
   * @param {buffer} [key.q] RSA secret prime, with p < q.
   *
   * @param {buffer} [key.k] Symmetric key.
   *
   * @param {buffer} [key.t] HSM Token, used with 'Bring Your Own Key'.
   *
   * @param {string} [key.crv] Elliptic curve name. For valid values, see
   * JsonWebKeyCurveName. Possible values include: 'P-256', 'P-384', 'P-521',
   * 'SECP256K1'
   *
   * @param {buffer} [key.x] X component of an EC public key.
   *
   * @param {buffer} [key.y] Y component of an EC public key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.hsm] Whether to import as a hardware key (HSM) or
   * software key.
   *
   * @param {object} [options.keyAttributes] The key management attributes.
   *
   * @param {boolean} [options.keyAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.keyAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.keyAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  importKey(vaultBaseUrl, keyName, key, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._importKey(vaultBaseUrl, keyName, key, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._importKey(vaultBaseUrl, keyName, key, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a key of any type from storage in Azure Key Vault.
   *
   * The delete key operation cannot be used to remove individual versions of a
   * key. This operation removes the cryptographic material associated with the
   * key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or
   * Encrypt/Decrypt operations.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedKeyBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteKeyWithHttpOperationResponse(vaultBaseUrl, keyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a key of any type from storage in Azure Key Vault.
   *
   * The delete key operation cannot be used to remove individual versions of a
   * key. This operation removes the cryptographic material associated with the
   * key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or
   * Encrypt/Decrypt operations.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedKeyBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedKeyBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteKey(vaultBaseUrl, keyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteKey(vaultBaseUrl, keyName, options, optionalCallback);
    }
  }

  /**
   * @summary The update key operation changes specified attributes of a stored
   * key and can be applied to any key type and key version stored in Azure Key
   * Vault.
   *
   * In order to perform this operation, the key must already exist in the Key
   * Vault. Note: The cryptographic material of a key itself cannot be changed.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of key to update.
   *
   * @param {string} keyVersion The version of the key to update.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.keyOps] Json web key operations. For more
   * information on possible key operations, see JsonWebKeyOperation.
   *
   * @param {object} [options.keyAttributes]
   *
   * @param {boolean} [options.keyAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.keyAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.keyAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateKeyWithHttpOperationResponse(vaultBaseUrl, keyName, keyVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateKey(vaultBaseUrl, keyName, keyVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary The update key operation changes specified attributes of a stored
   * key and can be applied to any key type and key version stored in Azure Key
   * Vault.
   *
   * In order to perform this operation, the key must already exist in the Key
   * Vault. Note: The cryptographic material of a key itself cannot be changed.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of key to update.
   *
   * @param {string} keyVersion The version of the key to update.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.keyOps] Json web key operations. For more
   * information on possible key operations, see JsonWebKeyOperation.
   *
   * @param {object} [options.keyAttributes]
   *
   * @param {boolean} [options.keyAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.keyAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.keyAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateKey(vaultBaseUrl, keyName, keyVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateKey(vaultBaseUrl, keyName, keyVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateKey(vaultBaseUrl, keyName, keyVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the public part of a stored key.
   *
   * The get key operation is applicable to all key types. If the requested key
   * is symmetric, then no key material is released in the response.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key to get.
   *
   * @param {string} keyVersion Adding the version parameter retrieves a specific
   * version of a key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getKeyWithHttpOperationResponse(vaultBaseUrl, keyName, keyVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getKey(vaultBaseUrl, keyName, keyVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the public part of a stored key.
   *
   * The get key operation is applicable to all key types. If the requested key
   * is symmetric, then no key material is released in the response.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key to get.
   *
   * @param {string} keyVersion Adding the version parameter retrieves a specific
   * version of a key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getKey(vaultBaseUrl, keyName, keyVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getKey(vaultBaseUrl, keyName, keyVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getKey(vaultBaseUrl, keyName, keyVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves a list of individual key versions with the same key name.
   *
   * The full key identifier, attributes, and tags are provided in the response.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getKeyVersionsWithHttpOperationResponse(vaultBaseUrl, keyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getKeyVersions(vaultBaseUrl, keyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves a list of individual key versions with the same key name.
   *
   * The full key identifier, attributes, and tags are provided in the response.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getKeyVersions(vaultBaseUrl, keyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getKeyVersions(vaultBaseUrl, keyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getKeyVersions(vaultBaseUrl, keyName, options, optionalCallback);
    }
  }

  /**
   * @summary List keys in the specified vault.
   *
   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures
   * that contain the public part of a stored key. The LIST operation is
   * applicable to all key types, however only the base key
   * identifier,attributes, and tags are provided in the response. Individual
   * versions of a key are not listed in the response. Authorization: Requires
   * the keys/list permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getKeysWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getKeys(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List keys in the specified vault.
   *
   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures
   * that contain the public part of a stored key. The LIST operation is
   * applicable to all key types, however only the base key
   * identifier,attributes, and tags are provided in the response. Individual
   * versions of a key are not listed in the response. Authorization: Requires
   * the keys/list permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getKeys(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getKeys(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getKeys(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * @summary Requests that a backup of the specified key be downloaded to the
   * client.
   *
   * The Key Backup operation exports a key from Azure Key Vault in a protected
   * form. Note that this operation does NOT return key material in a form that
   * can be used outside the Azure Key Vault system, the returned key material is
   * either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The
   * intent of this operation is to allow a client to GENERATE a key in one Azure
   * Key Vault instance, BACKUP the key, and then RESTORE it into another Azure
   * Key Vault instance. The BACKUP operation may be used to export, in protected
   * form, any key type from Azure Key Vault. Individual versions of a key cannot
   * be backed up. BACKUP / RESTORE can be performed within geographical
   * boundaries only; meaning that a BACKUP from one geographical area cannot be
   * restored to another geographical area. For example, a backup from the US
   * geographical area cannot be restored in an EU geographical area.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupKeyResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  backupKeyWithHttpOperationResponse(vaultBaseUrl, keyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._backupKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Requests that a backup of the specified key be downloaded to the
   * client.
   *
   * The Key Backup operation exports a key from Azure Key Vault in a protected
   * form. Note that this operation does NOT return key material in a form that
   * can be used outside the Azure Key Vault system, the returned key material is
   * either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The
   * intent of this operation is to allow a client to GENERATE a key in one Azure
   * Key Vault instance, BACKUP the key, and then RESTORE it into another Azure
   * Key Vault instance. The BACKUP operation may be used to export, in protected
   * form, any key type from Azure Key Vault. Individual versions of a key cannot
   * be backed up. BACKUP / RESTORE can be performed within geographical
   * boundaries only; meaning that a BACKUP from one geographical area cannot be
   * restored to another geographical area. For example, a backup from the US
   * geographical area cannot be restored in an EU geographical area.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupKeyResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupKeyResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  backupKey(vaultBaseUrl, keyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._backupKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._backupKey(vaultBaseUrl, keyName, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a backed up key to a vault.
   *
   * Imports a previously backed up key into Azure Key Vault, restoring the key,
   * its key identifier, attributes and access control policies. The RESTORE
   * operation may be used to import a previously backed up key. Individual
   * versions of a key cannot be restored. The key is restored in its entirety
   * with the same key name as it had when it was backed up. If the key name is
   * not available in the target Key Vault, the RESTORE operation will be
   * rejected. While the key name is retained during restore, the final key
   * identifier will change if the key is restored to a different vault. Restore
   * will restore all versions and preserve version identifiers. The RESTORE
   * operation is subject to security constraints: The target Key Vault must be
   * owned by the same Microsoft Azure Subscription as the source Key Vault The
   * user must have RESTORE permission in the target Key Vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {buffer} keyBundleBackup The backup blob associated with a key
   * bundle.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restoreKeyWithHttpOperationResponse(vaultBaseUrl, keyBundleBackup, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restoreKey(vaultBaseUrl, keyBundleBackup, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a backed up key to a vault.
   *
   * Imports a previously backed up key into Azure Key Vault, restoring the key,
   * its key identifier, attributes and access control policies. The RESTORE
   * operation may be used to import a previously backed up key. Individual
   * versions of a key cannot be restored. The key is restored in its entirety
   * with the same key name as it had when it was backed up. If the key name is
   * not available in the target Key Vault, the RESTORE operation will be
   * rejected. While the key name is retained during restore, the final key
   * identifier will change if the key is restored to a different vault. Restore
   * will restore all versions and preserve version identifiers. The RESTORE
   * operation is subject to security constraints: The target Key Vault must be
   * owned by the same Microsoft Azure Subscription as the source Key Vault The
   * user must have RESTORE permission in the target Key Vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {buffer} keyBundleBackup The backup blob associated with a key
   * bundle.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restoreKey(vaultBaseUrl, keyBundleBackup, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restoreKey(vaultBaseUrl, keyBundleBackup, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restoreKey(vaultBaseUrl, keyBundleBackup, options, optionalCallback);
    }
  }

  /**
   * @summary Encrypts an arbitrary sequence of bytes using an encryption key
   * that is stored in a key vault.
   *
   * The ENCRYPT operation encrypts an arbitrary sequence of bytes using an
   * encryption key that is stored in Azure Key Vault. Note that the ENCRYPT
   * operation only supports a single block of data, the size of which is
   * dependent on the target key and the encryption algorithm to be used. The
   * ENCRYPT operation is only strictly necessary for symmetric keys stored in
   * Azure Key Vault since protection with an asymmetric key can be performed
   * using public portion of the key. This operation is supported for asymmetric
   * keys as a convenience for callers that have a key-reference but do not have
   * access to the public key material.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm algorithm identifier. Possible values include:
   * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyOperationResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  encryptWithHttpOperationResponse(vaultBaseUrl, keyName, keyVersion, algorithm, value, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._encrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Encrypts an arbitrary sequence of bytes using an encryption key
   * that is stored in a key vault.
   *
   * The ENCRYPT operation encrypts an arbitrary sequence of bytes using an
   * encryption key that is stored in Azure Key Vault. Note that the ENCRYPT
   * operation only supports a single block of data, the size of which is
   * dependent on the target key and the encryption algorithm to be used. The
   * ENCRYPT operation is only strictly necessary for symmetric keys stored in
   * Azure Key Vault since protection with an asymmetric key can be performed
   * using public portion of the key. This operation is supported for asymmetric
   * keys as a convenience for callers that have a key-reference but do not have
   * access to the public key material.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm algorithm identifier. Possible values include:
   * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyOperationResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyOperationResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  encrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._encrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._encrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback);
    }
  }

  /**
   * @summary Decrypts a single block of encrypted data.
   *
   * The DECRYPT operation decrypts a well-formed block of ciphertext using the
   * target encryption key and specified algorithm. This operation is the reverse
   * of the ENCRYPT operation; only a single block of data may be decrypted, the
   * size of this block is dependent on the target key and the algorithm to be
   * used. The DECRYPT operation applies to asymmetric and symmetric keys stored
   * in Azure Key Vault since it uses the private portion of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm algorithm identifier. Possible values include:
   * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyOperationResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  decryptWithHttpOperationResponse(vaultBaseUrl, keyName, keyVersion, algorithm, value, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._decrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Decrypts a single block of encrypted data.
   *
   * The DECRYPT operation decrypts a well-formed block of ciphertext using the
   * target encryption key and specified algorithm. This operation is the reverse
   * of the ENCRYPT operation; only a single block of data may be decrypted, the
   * size of this block is dependent on the target key and the algorithm to be
   * used. The DECRYPT operation applies to asymmetric and symmetric keys stored
   * in Azure Key Vault since it uses the private portion of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm algorithm identifier. Possible values include:
   * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyOperationResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyOperationResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  decrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._decrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._decrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a signature from a digest using the specified key.
   *
   * The SIGN operation is applicable to asymmetric and symmetric keys stored in
   * Azure Key Vault since this operation uses the private portion of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm The signing/verification algorithm identifier. For
   * more information on possible algorithm types, see
   * JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',
   * 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512',
   * 'ECDSA256'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyOperationResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  signWithHttpOperationResponse(vaultBaseUrl, keyName, keyVersion, algorithm, value, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._sign(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a signature from a digest using the specified key.
   *
   * The SIGN operation is applicable to asymmetric and symmetric keys stored in
   * Azure Key Vault since this operation uses the private portion of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm The signing/verification algorithm identifier. For
   * more information on possible algorithm types, see
   * JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',
   * 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512',
   * 'ECDSA256'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyOperationResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyOperationResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  sign(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._sign(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._sign(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback);
    }
  }

  /**
   * @summary Verifies a signature using a specified key.
   *
   * The VERIFY operation is applicable to symmetric keys stored in Azure Key
   * Vault. VERIFY is not strictly necessary for asymmetric keys stored in Azure
   * Key Vault since signature verification can be performed using the public
   * portion of the key but this operation is supported as a convenience for
   * callers that only have a key-reference and not the public portion of the
   * key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm The signing/verification algorithm. For more
   * information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
   * Possible values include: 'PS256', 'PS384', 'PS512', 'RS256', 'RS384',
   * 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512', 'ECDSA256'
   *
   * @param {buffer} digest The digest used for signing.
   *
   * @param {buffer} signature The signature to be verified.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyVerifyResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  verifyWithHttpOperationResponse(vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._verify(vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Verifies a signature using a specified key.
   *
   * The VERIFY operation is applicable to symmetric keys stored in Azure Key
   * Vault. VERIFY is not strictly necessary for asymmetric keys stored in Azure
   * Key Vault since signature verification can be performed using the public
   * portion of the key but this operation is supported as a convenience for
   * callers that only have a key-reference and not the public portion of the
   * key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm The signing/verification algorithm. For more
   * information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
   * Possible values include: 'PS256', 'PS384', 'PS512', 'RS256', 'RS384',
   * 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512', 'ECDSA256'
   *
   * @param {buffer} digest The digest used for signing.
   *
   * @param {buffer} signature The signature to be verified.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyVerifyResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyVerifyResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  verify(vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._verify(vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._verify(vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, optionalCallback);
    }
  }

  /**
   * @summary Wraps a symmetric key using a specified key.
   *
   * The WRAP operation supports encryption of a symmetric key using a key
   * encryption key that has previously been stored in an Azure Key Vault. The
   * WRAP operation is only strictly necessary for symmetric keys stored in Azure
   * Key Vault since protection with an asymmetric key can be performed using the
   * public portion of the key. This operation is supported for asymmetric keys
   * as a convenience for callers that have a key-reference but do not have
   * access to the public key material.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm algorithm identifier. Possible values include:
   * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyOperationResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  wrapKeyWithHttpOperationResponse(vaultBaseUrl, keyName, keyVersion, algorithm, value, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._wrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Wraps a symmetric key using a specified key.
   *
   * The WRAP operation supports encryption of a symmetric key using a key
   * encryption key that has previously been stored in an Azure Key Vault. The
   * WRAP operation is only strictly necessary for symmetric keys stored in Azure
   * Key Vault since protection with an asymmetric key can be performed using the
   * public portion of the key. This operation is supported for asymmetric keys
   * as a convenience for callers that have a key-reference but do not have
   * access to the public key material.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm algorithm identifier. Possible values include:
   * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyOperationResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyOperationResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  wrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._wrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._wrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback);
    }
  }

  /**
   * @summary Unwraps a symmetric key using the specified key that was initially
   * used for wrapping that key.
   *
   * The UNWRAP operation supports decryption of a symmetric key using the target
   * key encryption key. This operation is the reverse of the WRAP operation. The
   * UNWRAP operation applies to asymmetric and symmetric keys stored in Azure
   * Key Vault since it uses the private portion of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm algorithm identifier. Possible values include:
   * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyOperationResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  unwrapKeyWithHttpOperationResponse(vaultBaseUrl, keyName, keyVersion, algorithm, value, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._unwrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Unwraps a symmetric key using the specified key that was initially
   * used for wrapping that key.
   *
   * The UNWRAP operation supports decryption of a symmetric key using the target
   * key encryption key. This operation is the reverse of the WRAP operation. The
   * UNWRAP operation applies to asymmetric and symmetric keys stored in Azure
   * Key Vault since it uses the private portion of the key.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key.
   *
   * @param {string} keyVersion The version of the key.
   *
   * @param {string} algorithm algorithm identifier. Possible values include:
   * 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
   *
   * @param {buffer} value
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyOperationResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyOperationResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  unwrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._unwrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._unwrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, optionalCallback);
    }
  }

  /**
   * List deleted keys in the specified vault. Authorization: Requires the
   * keys/list permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedKeyListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeletedKeysWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeletedKeys(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * List deleted keys in the specified vault. Authorization: Requires the
   * keys/list permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedKeyListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedKeyListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeletedKeys(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeletedKeys(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeletedKeys(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * Retrieves the deleted key information plus its attributes. Authorization:
   * Requires the keys/get permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedKeyBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeletedKeyWithHttpOperationResponse(vaultBaseUrl, keyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeletedKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Retrieves the deleted key information plus its attributes. Authorization:
   * Requires the keys/get permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedKeyBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedKeyBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeletedKey(vaultBaseUrl, keyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeletedKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeletedKey(vaultBaseUrl, keyName, options, optionalCallback);
    }
  }

  /**
   * Permanently deletes the specified key. aka purges the key. Authorization:
   * Requires the keys/purge permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  purgeDeletedKeyWithHttpOperationResponse(vaultBaseUrl, keyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._purgeDeletedKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Permanently deletes the specified key. aka purges the key. Authorization:
   * Requires the keys/purge permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the key
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  purgeDeletedKey(vaultBaseUrl, keyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._purgeDeletedKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._purgeDeletedKey(vaultBaseUrl, keyName, options, optionalCallback);
    }
  }

  /**
   * Recovers the deleted key back to its current version under /keys.
   * Authorization: Requires the keys/recover permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the deleted key
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverDeletedKeyWithHttpOperationResponse(vaultBaseUrl, keyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverDeletedKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Recovers the deleted key back to its current version under /keys.
   * Authorization: Requires the keys/recover permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} keyName The name of the deleted key
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverDeletedKey(vaultBaseUrl, keyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverDeletedKey(vaultBaseUrl, keyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverDeletedKey(vaultBaseUrl, keyName, options, optionalCallback);
    }
  }

  /**
   * @summary Sets a secret in a specified key vault.
   *
   * The SET operation adds a secret to the Azure Key Vault. If the named secret
   * already exists, Azure Key Vault creates a new version of that secret.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {string} value The value of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {string} [options.contentType] Type of the secret value such as a
   * password.
   *
   * @param {object} [options.secretAttributes] The secret management attributes.
   *
   * @param {boolean} [options.secretAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.secretAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.secretAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SecretBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  setSecretWithHttpOperationResponse(vaultBaseUrl, secretName, value, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._setSecret(vaultBaseUrl, secretName, value, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sets a secret in a specified key vault.
   *
   * The SET operation adds a secret to the Azure Key Vault. If the named secret
   * already exists, Azure Key Vault creates a new version of that secret.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {string} value The value of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {string} [options.contentType] Type of the secret value such as a
   * password.
   *
   * @param {object} [options.secretAttributes] The secret management attributes.
   *
   * @param {boolean} [options.secretAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.secretAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.secretAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SecretBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SecretBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  setSecret(vaultBaseUrl, secretName, value, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._setSecret(vaultBaseUrl, secretName, value, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._setSecret(vaultBaseUrl, secretName, value, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a secret from a specified key vault.
   *
   * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE
   * cannot be applied to an individual version of a secret.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedSecretBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSecretWithHttpOperationResponse(vaultBaseUrl, secretName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a secret from a specified key vault.
   *
   * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE
   * cannot be applied to an individual version of a secret.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedSecretBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedSecretBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSecret(vaultBaseUrl, secretName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSecret(vaultBaseUrl, secretName, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the attributes associated with a specified secret in a
   * given key vault.
   *
   * The UPDATE operation changes specified attributes of an existing stored
   * secret. Attributes that are not specified in the request are left unchanged.
   * The value of a secret itself cannot be changed.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {string} secretVersion The version of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.contentType] Type of the secret value such as a
   * password.
   *
   * @param {object} [options.secretAttributes] The secret management attributes.
   *
   * @param {boolean} [options.secretAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.secretAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.secretAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SecretBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateSecretWithHttpOperationResponse(vaultBaseUrl, secretName, secretVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateSecret(vaultBaseUrl, secretName, secretVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the attributes associated with a specified secret in a
   * given key vault.
   *
   * The UPDATE operation changes specified attributes of an existing stored
   * secret. Attributes that are not specified in the request are left unchanged.
   * The value of a secret itself cannot be changed.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {string} secretVersion The version of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.contentType] Type of the secret value such as a
   * password.
   *
   * @param {object} [options.secretAttributes] The secret management attributes.
   *
   * @param {boolean} [options.secretAttributes.enabled] Determines whether the
   * object is enabled.
   *
   * @param {date} [options.secretAttributes.notBefore] Not before date in UTC.
   *
   * @param {date} [options.secretAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SecretBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SecretBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSecret(vaultBaseUrl, secretName, secretVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateSecret(vaultBaseUrl, secretName, secretVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateSecret(vaultBaseUrl, secretName, secretVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Get a specified secret from a given key vault.
   *
   * The GET operation is applicable to any secret stored in Azure Key Vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {string} secretVersion The version of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SecretBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSecretWithHttpOperationResponse(vaultBaseUrl, secretName, secretVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSecret(vaultBaseUrl, secretName, secretVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get a specified secret from a given key vault.
   *
   * The GET operation is applicable to any secret stored in Azure Key Vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {string} secretVersion The version of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SecretBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SecretBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSecret(vaultBaseUrl, secretName, secretVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSecret(vaultBaseUrl, secretName, secretVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSecret(vaultBaseUrl, secretName, secretVersion, options, optionalCallback);
    }
  }

  /**
   * @summary List secrets in a specified key vault
   *
   * The LIST operation is applicable to the entire vault, however only the base
   * secret identifier and attributes are provided in the response. Individual
   * secret versions are not listed in the response.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SecretListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSecretsWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSecrets(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List secrets in a specified key vault
   *
   * The LIST operation is applicable to the entire vault, however only the base
   * secret identifier and attributes are provided in the response. Individual
   * secret versions are not listed in the response.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SecretListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SecretListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSecrets(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSecrets(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSecrets(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * @summary List the versions of the specified secret.
   *
   * The LIST VERSIONS operation can be applied to all versions having the same
   * secret name in the same key vault. The full secret identifier and attributes
   * are provided in the response. No values are returned for the secrets and
   * only current versions of a secret are listed.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SecretListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSecretVersionsWithHttpOperationResponse(vaultBaseUrl, secretName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSecretVersions(vaultBaseUrl, secretName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List the versions of the specified secret.
   *
   * The LIST VERSIONS operation can be applied to all versions having the same
   * secret name in the same key vault. The full secret identifier and attributes
   * are provided in the response. No values are returned for the secrets and
   * only current versions of a secret are listed.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SecretListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SecretListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSecretVersions(vaultBaseUrl, secretName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSecretVersions(vaultBaseUrl, secretName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSecretVersions(vaultBaseUrl, secretName, options, optionalCallback);
    }
  }

  /**
   * List deleted secrets in the specified vault. Authorization: requires the
   * secrets/list permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedSecretListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeletedSecretsWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeletedSecrets(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * List deleted secrets in the specified vault. Authorization: requires the
   * secrets/list permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedSecretListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedSecretListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeletedSecrets(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeletedSecrets(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeletedSecrets(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * Retrieves the deleted secret information plus its attributes. Authorization:
   * requires the secrets/get permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedSecretBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeletedSecretWithHttpOperationResponse(vaultBaseUrl, secretName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeletedSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Retrieves the deleted secret information plus its attributes. Authorization:
   * requires the secrets/get permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedSecretBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedSecretBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeletedSecret(vaultBaseUrl, secretName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeletedSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeletedSecret(vaultBaseUrl, secretName, options, optionalCallback);
    }
  }

  /**
   * Permanently deletes the specified secret. aka purges the secret.
   * Authorization: requires the secrets/purge permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  purgeDeletedSecretWithHttpOperationResponse(vaultBaseUrl, secretName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._purgeDeletedSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Permanently deletes the specified secret. aka purges the secret.
   * Authorization: requires the secrets/purge permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  purgeDeletedSecret(vaultBaseUrl, secretName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._purgeDeletedSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._purgeDeletedSecret(vaultBaseUrl, secretName, options, optionalCallback);
    }
  }

  /**
   * Recovers the deleted secret back to its current version under /secrets.
   * Authorization: requires the secrets/recover permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the deleted secret
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SecretBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverDeletedSecretWithHttpOperationResponse(vaultBaseUrl, secretName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverDeletedSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Recovers the deleted secret back to its current version under /secrets.
   * Authorization: requires the secrets/recover permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the deleted secret
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SecretBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SecretBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverDeletedSecret(vaultBaseUrl, secretName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverDeletedSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverDeletedSecret(vaultBaseUrl, secretName, options, optionalCallback);
    }
  }

  /**
   * Requests that a backup of the specified secret be downloaded to the client.
   * Authorization: requires the secrets/backup permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupSecretResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  backupSecretWithHttpOperationResponse(vaultBaseUrl, secretName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._backupSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Requests that a backup of the specified secret be downloaded to the client.
   * Authorization: requires the secrets/backup permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} secretName The name of the secret.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupSecretResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupSecretResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  backupSecret(vaultBaseUrl, secretName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._backupSecret(vaultBaseUrl, secretName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._backupSecret(vaultBaseUrl, secretName, options, optionalCallback);
    }
  }

  /**
   * Restores a backed up secret to a vault. Authorization: requires the
   * secrets/restore permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {buffer} secretBundleBackup The backup blob associated with a secret
   * bundle.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SecretBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restoreSecretWithHttpOperationResponse(vaultBaseUrl, secretBundleBackup, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restoreSecret(vaultBaseUrl, secretBundleBackup, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Restores a backed up secret to a vault. Authorization: requires the
   * secrets/restore permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {buffer} secretBundleBackup The backup blob associated with a secret
   * bundle.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SecretBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SecretBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restoreSecret(vaultBaseUrl, secretBundleBackup, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restoreSecret(vaultBaseUrl, secretBundleBackup, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restoreSecret(vaultBaseUrl, secretBundleBackup, options, optionalCallback);
    }
  }

  /**
   * @summary List certificates in a specified key vault
   *
   * The GetCertificates operation returns the set of certificates resources in
   * the specified key vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificatesWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificates(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List certificates in a specified key vault
   *
   * The GetCertificates operation returns the set of certificates resources in
   * the specified key vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificates(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificates(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificates(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a certificate from a specified key vault.
   *
   * Deletes all versions of a certificate object along with its associated
   * policy. Delete certificate cannot be used to remove individual versions of a
   * certificate object.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedCertificateBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteCertificateWithHttpOperationResponse(vaultBaseUrl, certificateName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a certificate from a specified key vault.
   *
   * Deletes all versions of a certificate object along with its associated
   * policy. Delete certificate cannot be used to remove individual versions of a
   * certificate object.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedCertificateBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedCertificateBundle} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCertificate(vaultBaseUrl, certificateName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteCertificate(vaultBaseUrl, certificateName, options, optionalCallback);
    }
  }

  /**
   * @summary Sets the certificate contacts for the specified key vault.
   *
   * Sets the certificate contacts for the specified key vault. Authorization:
   * requires the certificates/managecontacts permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} contacts The contacts for the key vault certificate.
   *
   * @param {array} [contacts.contactList] The contact list for the vault
   * certificates.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Contacts>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  setCertificateContactsWithHttpOperationResponse(vaultBaseUrl, contacts, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._setCertificateContacts(vaultBaseUrl, contacts, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sets the certificate contacts for the specified key vault.
   *
   * Sets the certificate contacts for the specified key vault. Authorization:
   * requires the certificates/managecontacts permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} contacts The contacts for the key vault certificate.
   *
   * @param {array} [contacts.contactList] The contact list for the vault
   * certificates.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Contacts} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Contacts} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  setCertificateContacts(vaultBaseUrl, contacts, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._setCertificateContacts(vaultBaseUrl, contacts, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._setCertificateContacts(vaultBaseUrl, contacts, options, optionalCallback);
    }
  }

  /**
   * @summary Lists the certificate contacts for a specified key vault.
   *
   * The GetCertificateContacts operation returns the set of certificate contact
   * resources in the specified key vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Contacts>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificateContactsWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificateContacts(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the certificate contacts for a specified key vault.
   *
   * The GetCertificateContacts operation returns the set of certificate contact
   * resources in the specified key vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Contacts} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Contacts} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificateContacts(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificateContacts(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificateContacts(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the certificate contacts for a specified key vault.
   *
   * Deletes the certificate contacts for a specified key vault certificate.
   * Authorization: requires the certificates/managecontacts permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Contacts>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteCertificateContactsWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteCertificateContacts(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the certificate contacts for a specified key vault.
   *
   * Deletes the certificate contacts for a specified key vault certificate.
   * Authorization: requires the certificates/managecontacts permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Contacts} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Contacts} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCertificateContacts(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteCertificateContacts(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteCertificateContacts(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * @summary List certificate issuers for a specified key vault.
   *
   * The GetCertificateIssuers operation returns the set of certificate issuer
   * resources in the specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateIssuerListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificateIssuersWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificateIssuers(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List certificate issuers for a specified key vault.
   *
   * The GetCertificateIssuers operation returns the set of certificate issuer
   * resources in the specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateIssuerListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateIssuerListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificateIssuers(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificateIssuers(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificateIssuers(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * @summary Sets the specified certificate issuer.
   *
   * The SetCertificateIssuer operation adds or updates the specified certificate
   * issuer.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} issuerName The name of the issuer.
   *
   * @param {string} provider The issuer provider.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.credentials] The credentials to be used for the
   * issuer.
   *
   * @param {string} [options.credentials.accountId] The user name/account
   * name/account id.
   *
   * @param {string} [options.credentials.password] The password/secret/account
   * key.
   *
   * @param {object} [options.organizationDetails] Details of the organization as
   * provided to the issuer.
   *
   * @param {string} [options.organizationDetails.id] Id of the organization.
   *
   * @param {array} [options.organizationDetails.adminDetails] Details of the
   * organization administrator.
   *
   * @param {object} [options.attributes] Attributes of the issuer object.
   *
   * @param {boolean} [options.attributes.enabled] Determines whether the issuer
   * is enabled.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IssuerBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  setCertificateIssuerWithHttpOperationResponse(vaultBaseUrl, issuerName, provider, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._setCertificateIssuer(vaultBaseUrl, issuerName, provider, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sets the specified certificate issuer.
   *
   * The SetCertificateIssuer operation adds or updates the specified certificate
   * issuer.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} issuerName The name of the issuer.
   *
   * @param {string} provider The issuer provider.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.credentials] The credentials to be used for the
   * issuer.
   *
   * @param {string} [options.credentials.accountId] The user name/account
   * name/account id.
   *
   * @param {string} [options.credentials.password] The password/secret/account
   * key.
   *
   * @param {object} [options.organizationDetails] Details of the organization as
   * provided to the issuer.
   *
   * @param {string} [options.organizationDetails.id] Id of the organization.
   *
   * @param {array} [options.organizationDetails.adminDetails] Details of the
   * organization administrator.
   *
   * @param {object} [options.attributes] Attributes of the issuer object.
   *
   * @param {boolean} [options.attributes.enabled] Determines whether the issuer
   * is enabled.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IssuerBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IssuerBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  setCertificateIssuer(vaultBaseUrl, issuerName, provider, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._setCertificateIssuer(vaultBaseUrl, issuerName, provider, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._setCertificateIssuer(vaultBaseUrl, issuerName, provider, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the specified certificate issuer.
   *
   * The UpdateCertificateIssuer operation performs an update on the specified
   * certificate issuer entity.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} issuerName The name of the issuer.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.provider] The issuer provider.
   *
   * @param {object} [options.credentials] The credentials to be used for the
   * issuer.
   *
   * @param {string} [options.credentials.accountId] The user name/account
   * name/account id.
   *
   * @param {string} [options.credentials.password] The password/secret/account
   * key.
   *
   * @param {object} [options.organizationDetails] Details of the organization as
   * provided to the issuer.
   *
   * @param {string} [options.organizationDetails.id] Id of the organization.
   *
   * @param {array} [options.organizationDetails.adminDetails] Details of the
   * organization administrator.
   *
   * @param {object} [options.attributes] Attributes of the issuer object.
   *
   * @param {boolean} [options.attributes.enabled] Determines whether the issuer
   * is enabled.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IssuerBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateCertificateIssuerWithHttpOperationResponse(vaultBaseUrl, issuerName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateCertificateIssuer(vaultBaseUrl, issuerName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the specified certificate issuer.
   *
   * The UpdateCertificateIssuer operation performs an update on the specified
   * certificate issuer entity.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} issuerName The name of the issuer.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.provider] The issuer provider.
   *
   * @param {object} [options.credentials] The credentials to be used for the
   * issuer.
   *
   * @param {string} [options.credentials.accountId] The user name/account
   * name/account id.
   *
   * @param {string} [options.credentials.password] The password/secret/account
   * key.
   *
   * @param {object} [options.organizationDetails] Details of the organization as
   * provided to the issuer.
   *
   * @param {string} [options.organizationDetails.id] Id of the organization.
   *
   * @param {array} [options.organizationDetails.adminDetails] Details of the
   * organization administrator.
   *
   * @param {object} [options.attributes] Attributes of the issuer object.
   *
   * @param {boolean} [options.attributes.enabled] Determines whether the issuer
   * is enabled.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IssuerBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IssuerBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateCertificateIssuer(vaultBaseUrl, issuerName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateCertificateIssuer(vaultBaseUrl, issuerName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateCertificateIssuer(vaultBaseUrl, issuerName, options, optionalCallback);
    }
  }

  /**
   * @summary Lists the specified certificate issuer.
   *
   * The GetCertificateIssuer operation returns the specified certificate issuer
   * resources in the specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} issuerName The name of the issuer.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IssuerBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificateIssuerWithHttpOperationResponse(vaultBaseUrl, issuerName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificateIssuer(vaultBaseUrl, issuerName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the specified certificate issuer.
   *
   * The GetCertificateIssuer operation returns the specified certificate issuer
   * resources in the specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} issuerName The name of the issuer.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IssuerBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IssuerBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificateIssuer(vaultBaseUrl, issuerName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificateIssuer(vaultBaseUrl, issuerName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificateIssuer(vaultBaseUrl, issuerName, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the specified certificate issuer.
   *
   * The DeleteCertificateIssuer operation permanently removes the specified
   * certificate issuer from the vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} issuerName The name of the issuer.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IssuerBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteCertificateIssuerWithHttpOperationResponse(vaultBaseUrl, issuerName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteCertificateIssuer(vaultBaseUrl, issuerName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the specified certificate issuer.
   *
   * The DeleteCertificateIssuer operation permanently removes the specified
   * certificate issuer from the vault.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} issuerName The name of the issuer.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IssuerBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IssuerBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCertificateIssuer(vaultBaseUrl, issuerName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteCertificateIssuer(vaultBaseUrl, issuerName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteCertificateIssuer(vaultBaseUrl, issuerName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new certificate.
   *
   * If this is the first version, the certificate resource is created.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.certificatePolicy] The management policy for the
   * certificate.
   *
   * @param {object} [options.certificatePolicy.keyProperties] Properties of the
   * key backing a certificate.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.exportable]
   * Indicates if the private key can be exported.
   *
   * @param {string} [options.certificatePolicy.keyProperties.keyType] The key
   * type.
   *
   * @param {number} [options.certificatePolicy.keyProperties.keySize] The key
   * size in bytes. For example;  1024 or 2048.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.reuseKey]
   * Indicates if the same key pair will be used on certificate renewal.
   *
   * @param {object} [options.certificatePolicy.secretProperties] Properties of
   * the secret backing a certificate.
   *
   * @param {string} [options.certificatePolicy.secretProperties.contentType] The
   * media type (MIME type).
   *
   * @param {object} [options.certificatePolicy.x509CertificateProperties]
   * Properties of the X509 component of a certificate.
   *
   * @param {string}
   * [options.certificatePolicy.x509CertificateProperties.subject] The subject
   * name. Should be a valid X509 distinguished Name.
   *
   * @param {array} [options.certificatePolicy.x509CertificateProperties.ekus]
   * The enhanced key usage.
   *
   * @param {object}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames]
   * The subject alternative names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
   * Email addresses.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
   * Domain names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
   * User principal names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.keyUsage] List of key
   * usages.
   *
   * @param {number}
   * [options.certificatePolicy.x509CertificateProperties.validityInMonths] The
   * duration that the ceritifcate is valid in months.
   *
   * @param {array} [options.certificatePolicy.lifetimeActions] Actions that will
   * be performed by Key Vault over the lifetime of a certificate.
   *
   * @param {object} [options.certificatePolicy.issuerParameters] Parameters for
   * the issuer of the X509 component of a certificate.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.name] Name of
   * the referenced issuer object or reserved names; for example, 'Self' or
   * 'Unknown'.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.certificateType]
   * Type of certificate to be requested from the issuer provider.
   *
   * @param {object} [options.certificatePolicy.attributes] The certificate
   * attributes.
   *
   * @param {object} [options.certificateAttributes] The attributes of the
   * certificate (optional).
   *
   * @param {boolean} [options.certificateAttributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [options.certificateAttributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateOperation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createCertificateWithHttpOperationResponse(vaultBaseUrl, certificateName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new certificate.
   *
   * If this is the first version, the certificate resource is created.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.certificatePolicy] The management policy for the
   * certificate.
   *
   * @param {object} [options.certificatePolicy.keyProperties] Properties of the
   * key backing a certificate.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.exportable]
   * Indicates if the private key can be exported.
   *
   * @param {string} [options.certificatePolicy.keyProperties.keyType] The key
   * type.
   *
   * @param {number} [options.certificatePolicy.keyProperties.keySize] The key
   * size in bytes. For example;  1024 or 2048.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.reuseKey]
   * Indicates if the same key pair will be used on certificate renewal.
   *
   * @param {object} [options.certificatePolicy.secretProperties] Properties of
   * the secret backing a certificate.
   *
   * @param {string} [options.certificatePolicy.secretProperties.contentType] The
   * media type (MIME type).
   *
   * @param {object} [options.certificatePolicy.x509CertificateProperties]
   * Properties of the X509 component of a certificate.
   *
   * @param {string}
   * [options.certificatePolicy.x509CertificateProperties.subject] The subject
   * name. Should be a valid X509 distinguished Name.
   *
   * @param {array} [options.certificatePolicy.x509CertificateProperties.ekus]
   * The enhanced key usage.
   *
   * @param {object}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames]
   * The subject alternative names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
   * Email addresses.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
   * Domain names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
   * User principal names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.keyUsage] List of key
   * usages.
   *
   * @param {number}
   * [options.certificatePolicy.x509CertificateProperties.validityInMonths] The
   * duration that the ceritifcate is valid in months.
   *
   * @param {array} [options.certificatePolicy.lifetimeActions] Actions that will
   * be performed by Key Vault over the lifetime of a certificate.
   *
   * @param {object} [options.certificatePolicy.issuerParameters] Parameters for
   * the issuer of the X509 component of a certificate.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.name] Name of
   * the referenced issuer object or reserved names; for example, 'Self' or
   * 'Unknown'.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.certificateType]
   * Type of certificate to be requested from the issuer provider.
   *
   * @param {object} [options.certificatePolicy.attributes] The certificate
   * attributes.
   *
   * @param {object} [options.certificateAttributes] The attributes of the
   * certificate (optional).
   *
   * @param {boolean} [options.certificateAttributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [options.certificateAttributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateOperation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateOperation} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createCertificate(vaultBaseUrl, certificateName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createCertificate(vaultBaseUrl, certificateName, options, optionalCallback);
    }
  }

  /**
   * @summary Imports a certificate into a specified key vault.
   *
   * Imports an existing valid certificate, containing a private key, into Azure
   * Key Vault. The certificate to be imported can be in either PFX or PEM
   * format. If the certificate is in PEM format the PEM file must contain the
   * key as well as x509 certificates.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {string} base64EncodedCertificate Base64 encoded representation of
   * the certificate object to import. This certificate needs to contain the
   * private key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.password] If the private key in
   * base64EncodedCertificate is encrypted, the password used for encryption.
   *
   * @param {object} [options.certificatePolicy] The management policy for the
   * certificate.
   *
   * @param {object} [options.certificatePolicy.keyProperties] Properties of the
   * key backing a certificate.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.exportable]
   * Indicates if the private key can be exported.
   *
   * @param {string} [options.certificatePolicy.keyProperties.keyType] The key
   * type.
   *
   * @param {number} [options.certificatePolicy.keyProperties.keySize] The key
   * size in bytes. For example;  1024 or 2048.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.reuseKey]
   * Indicates if the same key pair will be used on certificate renewal.
   *
   * @param {object} [options.certificatePolicy.secretProperties] Properties of
   * the secret backing a certificate.
   *
   * @param {string} [options.certificatePolicy.secretProperties.contentType] The
   * media type (MIME type).
   *
   * @param {object} [options.certificatePolicy.x509CertificateProperties]
   * Properties of the X509 component of a certificate.
   *
   * @param {string}
   * [options.certificatePolicy.x509CertificateProperties.subject] The subject
   * name. Should be a valid X509 distinguished Name.
   *
   * @param {array} [options.certificatePolicy.x509CertificateProperties.ekus]
   * The enhanced key usage.
   *
   * @param {object}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames]
   * The subject alternative names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
   * Email addresses.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
   * Domain names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
   * User principal names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.keyUsage] List of key
   * usages.
   *
   * @param {number}
   * [options.certificatePolicy.x509CertificateProperties.validityInMonths] The
   * duration that the ceritifcate is valid in months.
   *
   * @param {array} [options.certificatePolicy.lifetimeActions] Actions that will
   * be performed by Key Vault over the lifetime of a certificate.
   *
   * @param {object} [options.certificatePolicy.issuerParameters] Parameters for
   * the issuer of the X509 component of a certificate.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.name] Name of
   * the referenced issuer object or reserved names; for example, 'Self' or
   * 'Unknown'.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.certificateType]
   * Type of certificate to be requested from the issuer provider.
   *
   * @param {object} [options.certificatePolicy.attributes] The certificate
   * attributes.
   *
   * @param {object} [options.certificateAttributes] The attributes of the
   * certificate (optional).
   *
   * @param {boolean} [options.certificateAttributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [options.certificateAttributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  importCertificateWithHttpOperationResponse(vaultBaseUrl, certificateName, base64EncodedCertificate, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._importCertificate(vaultBaseUrl, certificateName, base64EncodedCertificate, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Imports a certificate into a specified key vault.
   *
   * Imports an existing valid certificate, containing a private key, into Azure
   * Key Vault. The certificate to be imported can be in either PFX or PEM
   * format. If the certificate is in PEM format the PEM file must contain the
   * key as well as x509 certificates.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {string} base64EncodedCertificate Base64 encoded representation of
   * the certificate object to import. This certificate needs to contain the
   * private key.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.password] If the private key in
   * base64EncodedCertificate is encrypted, the password used for encryption.
   *
   * @param {object} [options.certificatePolicy] The management policy for the
   * certificate.
   *
   * @param {object} [options.certificatePolicy.keyProperties] Properties of the
   * key backing a certificate.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.exportable]
   * Indicates if the private key can be exported.
   *
   * @param {string} [options.certificatePolicy.keyProperties.keyType] The key
   * type.
   *
   * @param {number} [options.certificatePolicy.keyProperties.keySize] The key
   * size in bytes. For example;  1024 or 2048.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.reuseKey]
   * Indicates if the same key pair will be used on certificate renewal.
   *
   * @param {object} [options.certificatePolicy.secretProperties] Properties of
   * the secret backing a certificate.
   *
   * @param {string} [options.certificatePolicy.secretProperties.contentType] The
   * media type (MIME type).
   *
   * @param {object} [options.certificatePolicy.x509CertificateProperties]
   * Properties of the X509 component of a certificate.
   *
   * @param {string}
   * [options.certificatePolicy.x509CertificateProperties.subject] The subject
   * name. Should be a valid X509 distinguished Name.
   *
   * @param {array} [options.certificatePolicy.x509CertificateProperties.ekus]
   * The enhanced key usage.
   *
   * @param {object}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames]
   * The subject alternative names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
   * Email addresses.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
   * Domain names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
   * User principal names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.keyUsage] List of key
   * usages.
   *
   * @param {number}
   * [options.certificatePolicy.x509CertificateProperties.validityInMonths] The
   * duration that the ceritifcate is valid in months.
   *
   * @param {array} [options.certificatePolicy.lifetimeActions] Actions that will
   * be performed by Key Vault over the lifetime of a certificate.
   *
   * @param {object} [options.certificatePolicy.issuerParameters] Parameters for
   * the issuer of the X509 component of a certificate.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.name] Name of
   * the referenced issuer object or reserved names; for example, 'Self' or
   * 'Unknown'.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.certificateType]
   * Type of certificate to be requested from the issuer provider.
   *
   * @param {object} [options.certificatePolicy.attributes] The certificate
   * attributes.
   *
   * @param {object} [options.certificateAttributes] The attributes of the
   * certificate (optional).
   *
   * @param {boolean} [options.certificateAttributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [options.certificateAttributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  importCertificate(vaultBaseUrl, certificateName, base64EncodedCertificate, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._importCertificate(vaultBaseUrl, certificateName, base64EncodedCertificate, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._importCertificate(vaultBaseUrl, certificateName, base64EncodedCertificate, options, optionalCallback);
    }
  }

  /**
   * @summary List the versions of a certificate.
   *
   * The GetCertificateVersions operation returns the versions of a certificate
   * in the specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificateVersionsWithHttpOperationResponse(vaultBaseUrl, certificateName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificateVersions(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List the versions of a certificate.
   *
   * The GetCertificateVersions operation returns the versions of a certificate
   * in the specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificateVersions(vaultBaseUrl, certificateName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificateVersions(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificateVersions(vaultBaseUrl, certificateName, options, optionalCallback);
    }
  }

  /**
   * @summary Lists the policy for a certificate.
   *
   * The GetCertificatePolicy operation returns the specified certificate policy
   * resources in the specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate in a given key
   * vault.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificatePolicy>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificatePolicyWithHttpOperationResponse(vaultBaseUrl, certificateName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificatePolicy(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the policy for a certificate.
   *
   * The GetCertificatePolicy operation returns the specified certificate policy
   * resources in the specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate in a given key
   * vault.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificatePolicy} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificatePolicy} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificatePolicy(vaultBaseUrl, certificateName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificatePolicy(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificatePolicy(vaultBaseUrl, certificateName, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the policy for a certificate.
   *
   * Set specified members in the certificate policy. Leave others as null.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate in the given
   * vault.
   *
   * @param {object} certificatePolicy The policy for the certificate.
   *
   * @param {object} [certificatePolicy.keyProperties] Properties of the key
   * backing a certificate.
   *
   * @param {boolean} [certificatePolicy.keyProperties.exportable] Indicates if
   * the private key can be exported.
   *
   * @param {string} [certificatePolicy.keyProperties.keyType] The key type.
   *
   * @param {number} [certificatePolicy.keyProperties.keySize] The key size in
   * bytes. For example;  1024 or 2048.
   *
   * @param {boolean} [certificatePolicy.keyProperties.reuseKey] Indicates if the
   * same key pair will be used on certificate renewal.
   *
   * @param {object} [certificatePolicy.secretProperties] Properties of the
   * secret backing a certificate.
   *
   * @param {string} [certificatePolicy.secretProperties.contentType] The media
   * type (MIME type).
   *
   * @param {object} [certificatePolicy.x509CertificateProperties] Properties of
   * the X509 component of a certificate.
   *
   * @param {string} [certificatePolicy.x509CertificateProperties.subject] The
   * subject name. Should be a valid X509 distinguished Name.
   *
   * @param {array} [certificatePolicy.x509CertificateProperties.ekus] The
   * enhanced key usage.
   *
   * @param {object}
   * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames] The
   * subject alternative names.
   *
   * @param {array}
   * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
   * Email addresses.
   *
   * @param {array}
   * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
   * Domain names.
   *
   * @param {array}
   * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
   * User principal names.
   *
   * @param {array} [certificatePolicy.x509CertificateProperties.keyUsage] List
   * of key usages.
   *
   * @param {number}
   * [certificatePolicy.x509CertificateProperties.validityInMonths] The duration
   * that the ceritifcate is valid in months.
   *
   * @param {array} [certificatePolicy.lifetimeActions] Actions that will be
   * performed by Key Vault over the lifetime of a certificate.
   *
   * @param {object} [certificatePolicy.issuerParameters] Parameters for the
   * issuer of the X509 component of a certificate.
   *
   * @param {string} [certificatePolicy.issuerParameters.name] Name of the
   * referenced issuer object or reserved names; for example, 'Self' or
   * 'Unknown'.
   *
   * @param {string} [certificatePolicy.issuerParameters.certificateType] Type of
   * certificate to be requested from the issuer provider.
   *
   * @param {object} [certificatePolicy.attributes] The certificate attributes.
   *
   * @param {boolean} [certificatePolicy.attributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [certificatePolicy.attributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [certificatePolicy.attributes.expires] Expiry date in UTC.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificatePolicy>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateCertificatePolicyWithHttpOperationResponse(vaultBaseUrl, certificateName, certificatePolicy, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateCertificatePolicy(vaultBaseUrl, certificateName, certificatePolicy, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the policy for a certificate.
   *
   * Set specified members in the certificate policy. Leave others as null.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate in the given
   * vault.
   *
   * @param {object} certificatePolicy The policy for the certificate.
   *
   * @param {object} [certificatePolicy.keyProperties] Properties of the key
   * backing a certificate.
   *
   * @param {boolean} [certificatePolicy.keyProperties.exportable] Indicates if
   * the private key can be exported.
   *
   * @param {string} [certificatePolicy.keyProperties.keyType] The key type.
   *
   * @param {number} [certificatePolicy.keyProperties.keySize] The key size in
   * bytes. For example;  1024 or 2048.
   *
   * @param {boolean} [certificatePolicy.keyProperties.reuseKey] Indicates if the
   * same key pair will be used on certificate renewal.
   *
   * @param {object} [certificatePolicy.secretProperties] Properties of the
   * secret backing a certificate.
   *
   * @param {string} [certificatePolicy.secretProperties.contentType] The media
   * type (MIME type).
   *
   * @param {object} [certificatePolicy.x509CertificateProperties] Properties of
   * the X509 component of a certificate.
   *
   * @param {string} [certificatePolicy.x509CertificateProperties.subject] The
   * subject name. Should be a valid X509 distinguished Name.
   *
   * @param {array} [certificatePolicy.x509CertificateProperties.ekus] The
   * enhanced key usage.
   *
   * @param {object}
   * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames] The
   * subject alternative names.
   *
   * @param {array}
   * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
   * Email addresses.
   *
   * @param {array}
   * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
   * Domain names.
   *
   * @param {array}
   * [certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
   * User principal names.
   *
   * @param {array} [certificatePolicy.x509CertificateProperties.keyUsage] List
   * of key usages.
   *
   * @param {number}
   * [certificatePolicy.x509CertificateProperties.validityInMonths] The duration
   * that the ceritifcate is valid in months.
   *
   * @param {array} [certificatePolicy.lifetimeActions] Actions that will be
   * performed by Key Vault over the lifetime of a certificate.
   *
   * @param {object} [certificatePolicy.issuerParameters] Parameters for the
   * issuer of the X509 component of a certificate.
   *
   * @param {string} [certificatePolicy.issuerParameters.name] Name of the
   * referenced issuer object or reserved names; for example, 'Self' or
   * 'Unknown'.
   *
   * @param {string} [certificatePolicy.issuerParameters.certificateType] Type of
   * certificate to be requested from the issuer provider.
   *
   * @param {object} [certificatePolicy.attributes] The certificate attributes.
   *
   * @param {boolean} [certificatePolicy.attributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [certificatePolicy.attributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [certificatePolicy.attributes.expires] Expiry date in UTC.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificatePolicy} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificatePolicy} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateCertificatePolicy(vaultBaseUrl, certificateName, certificatePolicy, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateCertificatePolicy(vaultBaseUrl, certificateName, certificatePolicy, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateCertificatePolicy(vaultBaseUrl, certificateName, certificatePolicy, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the specified attributes associated with the given
   * certificate.
   *
   * The UpdateCertificate operation applies the specified update on the given
   * certificate; note the only elements being updated are the certificate's
   * attributes.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate in the given key
   * vault.
   *
   * @param {string} certificateVersion The version of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.certificatePolicy] The management policy for the
   * certificate.
   *
   * @param {object} [options.certificatePolicy.keyProperties] Properties of the
   * key backing a certificate.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.exportable]
   * Indicates if the private key can be exported.
   *
   * @param {string} [options.certificatePolicy.keyProperties.keyType] The key
   * type.
   *
   * @param {number} [options.certificatePolicy.keyProperties.keySize] The key
   * size in bytes. For example;  1024 or 2048.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.reuseKey]
   * Indicates if the same key pair will be used on certificate renewal.
   *
   * @param {object} [options.certificatePolicy.secretProperties] Properties of
   * the secret backing a certificate.
   *
   * @param {string} [options.certificatePolicy.secretProperties.contentType] The
   * media type (MIME type).
   *
   * @param {object} [options.certificatePolicy.x509CertificateProperties]
   * Properties of the X509 component of a certificate.
   *
   * @param {string}
   * [options.certificatePolicy.x509CertificateProperties.subject] The subject
   * name. Should be a valid X509 distinguished Name.
   *
   * @param {array} [options.certificatePolicy.x509CertificateProperties.ekus]
   * The enhanced key usage.
   *
   * @param {object}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames]
   * The subject alternative names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
   * Email addresses.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
   * Domain names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
   * User principal names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.keyUsage] List of key
   * usages.
   *
   * @param {number}
   * [options.certificatePolicy.x509CertificateProperties.validityInMonths] The
   * duration that the ceritifcate is valid in months.
   *
   * @param {array} [options.certificatePolicy.lifetimeActions] Actions that will
   * be performed by Key Vault over the lifetime of a certificate.
   *
   * @param {object} [options.certificatePolicy.issuerParameters] Parameters for
   * the issuer of the X509 component of a certificate.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.name] Name of
   * the referenced issuer object or reserved names; for example, 'Self' or
   * 'Unknown'.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.certificateType]
   * Type of certificate to be requested from the issuer provider.
   *
   * @param {object} [options.certificatePolicy.attributes] The certificate
   * attributes.
   *
   * @param {object} [options.certificateAttributes] The attributes of the
   * certificate (optional).
   *
   * @param {boolean} [options.certificateAttributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [options.certificateAttributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateCertificateWithHttpOperationResponse(vaultBaseUrl, certificateName, certificateVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateCertificate(vaultBaseUrl, certificateName, certificateVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the specified attributes associated with the given
   * certificate.
   *
   * The UpdateCertificate operation applies the specified update on the given
   * certificate; note the only elements being updated are the certificate's
   * attributes.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate in the given key
   * vault.
   *
   * @param {string} certificateVersion The version of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.certificatePolicy] The management policy for the
   * certificate.
   *
   * @param {object} [options.certificatePolicy.keyProperties] Properties of the
   * key backing a certificate.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.exportable]
   * Indicates if the private key can be exported.
   *
   * @param {string} [options.certificatePolicy.keyProperties.keyType] The key
   * type.
   *
   * @param {number} [options.certificatePolicy.keyProperties.keySize] The key
   * size in bytes. For example;  1024 or 2048.
   *
   * @param {boolean} [options.certificatePolicy.keyProperties.reuseKey]
   * Indicates if the same key pair will be used on certificate renewal.
   *
   * @param {object} [options.certificatePolicy.secretProperties] Properties of
   * the secret backing a certificate.
   *
   * @param {string} [options.certificatePolicy.secretProperties.contentType] The
   * media type (MIME type).
   *
   * @param {object} [options.certificatePolicy.x509CertificateProperties]
   * Properties of the X509 component of a certificate.
   *
   * @param {string}
   * [options.certificatePolicy.x509CertificateProperties.subject] The subject
   * name. Should be a valid X509 distinguished Name.
   *
   * @param {array} [options.certificatePolicy.x509CertificateProperties.ekus]
   * The enhanced key usage.
   *
   * @param {object}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames]
   * The subject alternative names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.emails]
   * Email addresses.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.dnsNames]
   * Domain names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.subjectAlternativeNames.upns]
   * User principal names.
   *
   * @param {array}
   * [options.certificatePolicy.x509CertificateProperties.keyUsage] List of key
   * usages.
   *
   * @param {number}
   * [options.certificatePolicy.x509CertificateProperties.validityInMonths] The
   * duration that the ceritifcate is valid in months.
   *
   * @param {array} [options.certificatePolicy.lifetimeActions] Actions that will
   * be performed by Key Vault over the lifetime of a certificate.
   *
   * @param {object} [options.certificatePolicy.issuerParameters] Parameters for
   * the issuer of the X509 component of a certificate.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.name] Name of
   * the referenced issuer object or reserved names; for example, 'Self' or
   * 'Unknown'.
   *
   * @param {string} [options.certificatePolicy.issuerParameters.certificateType]
   * Type of certificate to be requested from the issuer provider.
   *
   * @param {object} [options.certificatePolicy.attributes] The certificate
   * attributes.
   *
   * @param {object} [options.certificateAttributes] The attributes of the
   * certificate (optional).
   *
   * @param {boolean} [options.certificateAttributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [options.certificateAttributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateCertificate(vaultBaseUrl, certificateName, certificateVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateCertificate(vaultBaseUrl, certificateName, certificateVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateCertificate(vaultBaseUrl, certificateName, certificateVersion, options, optionalCallback);
    }
  }

  /**
   * Gets information about a specified certificate. Authorization: requires the
   * certificates/get permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate in the given
   * vault.
   *
   * @param {string} certificateVersion The version of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificateWithHttpOperationResponse(vaultBaseUrl, certificateName, certificateVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificate(vaultBaseUrl, certificateName, certificateVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets information about a specified certificate. Authorization: requires the
   * certificates/get permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate in the given
   * vault.
   *
   * @param {string} certificateVersion The version of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificate(vaultBaseUrl, certificateName, certificateVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificate(vaultBaseUrl, certificateName, certificateVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificate(vaultBaseUrl, certificateName, certificateVersion, options, optionalCallback);
    }
  }

  /**
   * Updates a certificate operation. Authorization: requires the
   * certificates/update permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {boolean} cancellationRequested Indicates if cancellation was
   * requested on the certificate operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateOperation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateCertificateOperationWithHttpOperationResponse(vaultBaseUrl, certificateName, cancellationRequested, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateCertificateOperation(vaultBaseUrl, certificateName, cancellationRequested, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Updates a certificate operation. Authorization: requires the
   * certificates/update permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {boolean} cancellationRequested Indicates if cancellation was
   * requested on the certificate operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateOperation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateOperation} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateCertificateOperation(vaultBaseUrl, certificateName, cancellationRequested, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateCertificateOperation(vaultBaseUrl, certificateName, cancellationRequested, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateCertificateOperation(vaultBaseUrl, certificateName, cancellationRequested, options, optionalCallback);
    }
  }

  /**
   * Gets the operation associated with a specified certificate. Authorization:
   * requires the certificates/get permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateOperation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificateOperationWithHttpOperationResponse(vaultBaseUrl, certificateName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificateOperation(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the operation associated with a specified certificate. Authorization:
   * requires the certificates/get permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateOperation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateOperation} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificateOperation(vaultBaseUrl, certificateName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificateOperation(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificateOperation(vaultBaseUrl, certificateName, options, optionalCallback);
    }
  }

  /**
   * Deletes the operation for a specified certificate. Authorization: requires
   * the certificates/update permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateOperation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteCertificateOperationWithHttpOperationResponse(vaultBaseUrl, certificateName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteCertificateOperation(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes the operation for a specified certificate. Authorization: requires
   * the certificates/update permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateOperation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateOperation} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCertificateOperation(vaultBaseUrl, certificateName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteCertificateOperation(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteCertificateOperation(vaultBaseUrl, certificateName, options, optionalCallback);
    }
  }

  /**
   * @summary Merges a certificate or a certificate chain with a key pair
   * existing on the server.
   *
   * The MergeCertificate operation performs the merging of a certificate or
   * certificate chain with a key pair currently available in the service.
   * Authorization: requires the certificates/update permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {array} x509Certificates The certificate or the certificate chain to
   * merge.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.certificateAttributes] The attributes of the
   * certificate (optional).
   *
   * @param {boolean} [options.certificateAttributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [options.certificateAttributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  mergeCertificateWithHttpOperationResponse(vaultBaseUrl, certificateName, x509Certificates, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._mergeCertificate(vaultBaseUrl, certificateName, x509Certificates, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Merges a certificate or a certificate chain with a key pair
   * existing on the server.
   *
   * The MergeCertificate operation performs the merging of a certificate or
   * certificate chain with a key pair currently available in the service.
   * Authorization: requires the certificates/update permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate.
   *
   * @param {array} x509Certificates The certificate or the certificate chain to
   * merge.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.certificateAttributes] The attributes of the
   * certificate (optional).
   *
   * @param {boolean} [options.certificateAttributes.enabled] Determines whether
   * the object is enabled.
   *
   * @param {date} [options.certificateAttributes.notBefore] Not before date in
   * UTC.
   *
   * @param {date} [options.certificateAttributes.expires] Expiry date in UTC.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  mergeCertificate(vaultBaseUrl, certificateName, x509Certificates, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._mergeCertificate(vaultBaseUrl, certificateName, x509Certificates, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._mergeCertificate(vaultBaseUrl, certificateName, x509Certificates, options, optionalCallback);
    }
  }

  /**
   * @summary Lists the deleted certificates in the specified vault, currently
   * available for recovery.
   *
   * The GetDeletedCertificates operation retrieves the certificates in the
   * current vault which are in a deleted state and ready for recovery or
   * purging.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedCertificateListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeletedCertificatesWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeletedCertificates(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the deleted certificates in the specified vault, currently
   * available for recovery.
   *
   * The GetDeletedCertificates operation retrieves the certificates in the
   * current vault which are in a deleted state and ready for recovery or
   * purging.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedCertificateListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedCertificateListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeletedCertificates(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeletedCertificates(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeletedCertificates(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves information about the specified deleted certificate.
   *
   * The GetDeletedCertificate operation retrieves the deleted certificate
   * information plus its attributes, such as retention interval, scheduled
   * permanent deletion and the current deletion recovery level.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedCertificateBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeletedCertificateWithHttpOperationResponse(vaultBaseUrl, certificateName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeletedCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves information about the specified deleted certificate.
   *
   * The GetDeletedCertificate operation retrieves the deleted certificate
   * information plus its attributes, such as retention interval, scheduled
   * permanent deletion and the current deletion recovery level.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedCertificateBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedCertificateBundle} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeletedCertificate(vaultBaseUrl, certificateName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeletedCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeletedCertificate(vaultBaseUrl, certificateName, options, optionalCallback);
    }
  }

  /**
   * @summary Permanently deletes the specified deleted certificate.
   *
   * The PurgeDeletedCertificate operation performs an irreversible deletion of
   * the specified certificate, without possibility for recovery. The operation
   * is not available if the recovery level does not specify 'Purgeable'.
   * Requires the explicit granting of the 'purge' permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  purgeDeletedCertificateWithHttpOperationResponse(vaultBaseUrl, certificateName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._purgeDeletedCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Permanently deletes the specified deleted certificate.
   *
   * The PurgeDeletedCertificate operation performs an irreversible deletion of
   * the specified certificate, without possibility for recovery. The operation
   * is not available if the recovery level does not specify 'Purgeable'.
   * Requires the explicit granting of the 'purge' permission.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the certificate
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  purgeDeletedCertificate(vaultBaseUrl, certificateName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._purgeDeletedCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._purgeDeletedCertificate(vaultBaseUrl, certificateName, options, optionalCallback);
    }
  }

  /**
   * @summary Recovers the deleted certificate back to its current version under
   * /certificates.
   *
   * The RecoverDeletedCertificate operation performs the reversal of the Delete
   * operation. The operation is applicable in vaults enabled for soft-delete,
   * and must be issued during the retention interval (available in the deleted
   * certificate's attributes).
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the deleted certificate
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverDeletedCertificateWithHttpOperationResponse(vaultBaseUrl, certificateName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverDeletedCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Recovers the deleted certificate back to its current version under
   * /certificates.
   *
   * The RecoverDeletedCertificate operation performs the reversal of the Delete
   * operation. The operation is applicable in vaults enabled for soft-delete,
   * and must be issued during the retention interval (available in the deleted
   * certificate's attributes).
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} certificateName The name of the deleted certificate
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverDeletedCertificate(vaultBaseUrl, certificateName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverDeletedCertificate(vaultBaseUrl, certificateName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverDeletedCertificate(vaultBaseUrl, certificateName, options, optionalCallback);
    }
  }

  /**
   * List storage accounts managed by specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StorageListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getStorageAccountsWithHttpOperationResponse(vaultBaseUrl, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getStorageAccounts(vaultBaseUrl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * List storage accounts managed by specified key vault
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getStorageAccounts(vaultBaseUrl, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getStorageAccounts(vaultBaseUrl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getStorageAccounts(vaultBaseUrl, options, optionalCallback);
    }
  }

  /**
   * Deletes a storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StorageBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteStorageAccountWithHttpOperationResponse(vaultBaseUrl, storageAccountName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteStorageAccount(vaultBaseUrl, storageAccountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes a storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteStorageAccount(vaultBaseUrl, storageAccountName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteStorageAccount(vaultBaseUrl, storageAccountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteStorageAccount(vaultBaseUrl, storageAccountName, options, optionalCallback);
    }
  }

  /**
   * Gets information about a specified storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StorageBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getStorageAccountWithHttpOperationResponse(vaultBaseUrl, storageAccountName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getStorageAccount(vaultBaseUrl, storageAccountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets information about a specified storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getStorageAccount(vaultBaseUrl, storageAccountName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getStorageAccount(vaultBaseUrl, storageAccountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getStorageAccount(vaultBaseUrl, storageAccountName, options, optionalCallback);
    }
  }

  /**
   * Creates or updates a new storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} resourceId Storage account resource id.
   *
   * @param {string} activeKeyName Current active storage account key name.
   *
   * @param {boolean} autoRegenerateKey whether keyvault should manage the
   * storage account for the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.regenerationPeriod] The key regeneration time
   * duration specified in ISO-8601 format.
   *
   * @param {object} [options.storageAccountAttributes] The attributes of the
   * storage account.
   *
   * @param {boolean} [options.storageAccountAttributes.enabled] the enabled
   * state of the object.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StorageBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  setStorageAccountWithHttpOperationResponse(vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._setStorageAccount(vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Creates or updates a new storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} resourceId Storage account resource id.
   *
   * @param {string} activeKeyName Current active storage account key name.
   *
   * @param {boolean} autoRegenerateKey whether keyvault should manage the
   * storage account for the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.regenerationPeriod] The key regeneration time
   * duration specified in ISO-8601 format.
   *
   * @param {object} [options.storageAccountAttributes] The attributes of the
   * storage account.
   *
   * @param {boolean} [options.storageAccountAttributes.enabled] the enabled
   * state of the object.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  setStorageAccount(vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._setStorageAccount(vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._setStorageAccount(vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options, optionalCallback);
    }
  }

  /**
   * Updates the specified attributes associated with the given storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.activeKeyName] The current active storage account
   * key name.
   *
   * @param {boolean} [options.autoRegenerateKey] whether keyvault should manage
   * the storage account for the user.
   *
   * @param {string} [options.regenerationPeriod] The key regeneration time
   * duration specified in ISO-8601 format.
   *
   * @param {object} [options.storageAccountAttributes] The attributes of the
   * storage account.
   *
   * @param {boolean} [options.storageAccountAttributes.enabled] the enabled
   * state of the object.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StorageBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateStorageAccountWithHttpOperationResponse(vaultBaseUrl, storageAccountName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateStorageAccount(vaultBaseUrl, storageAccountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Updates the specified attributes associated with the given storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.activeKeyName] The current active storage account
   * key name.
   *
   * @param {boolean} [options.autoRegenerateKey] whether keyvault should manage
   * the storage account for the user.
   *
   * @param {string} [options.regenerationPeriod] The key regeneration time
   * duration specified in ISO-8601 format.
   *
   * @param {object} [options.storageAccountAttributes] The attributes of the
   * storage account.
   *
   * @param {boolean} [options.storageAccountAttributes.enabled] the enabled
   * state of the object.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateStorageAccount(vaultBaseUrl, storageAccountName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateStorageAccount(vaultBaseUrl, storageAccountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateStorageAccount(vaultBaseUrl, storageAccountName, options, optionalCallback);
    }
  }

  /**
   * Regenerates the specified key value for the given storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} keyName The storage account key name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StorageBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  regenerateStorageAccountKeyWithHttpOperationResponse(vaultBaseUrl, storageAccountName, keyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._regenerateStorageAccountKey(vaultBaseUrl, storageAccountName, keyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Regenerates the specified key value for the given storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} keyName The storage account key name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  regenerateStorageAccountKey(vaultBaseUrl, storageAccountName, keyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._regenerateStorageAccountKey(vaultBaseUrl, storageAccountName, keyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._regenerateStorageAccountKey(vaultBaseUrl, storageAccountName, keyName, options, optionalCallback);
    }
  }

  /**
   * List storage SAS definitions for the given storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SasDefinitionListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSasDefinitionsWithHttpOperationResponse(vaultBaseUrl, storageAccountName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSasDefinitions(vaultBaseUrl, storageAccountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * List storage SAS definitions for the given storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.maxresults] Maximum number of results to return in
   * a page. If not specified the service will return up to 25 results.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SasDefinitionListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SasDefinitionListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSasDefinitions(vaultBaseUrl, storageAccountName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSasDefinitions(vaultBaseUrl, storageAccountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSasDefinitions(vaultBaseUrl, storageAccountName, options, optionalCallback);
    }
  }

  /**
   * Deletes a SAS definition from a specified storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} sasDefinitionName The name of the SAS definition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SasDefinitionBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSasDefinitionWithHttpOperationResponse(vaultBaseUrl, storageAccountName, sasDefinitionName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes a SAS definition from a specified storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} sasDefinitionName The name of the SAS definition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SasDefinitionBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SasDefinitionBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, optionalCallback);
    }
  }

  /**
   * Gets information about a SAS definition for the specified storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} sasDefinitionName The name of the SAS definition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SasDefinitionBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSasDefinitionWithHttpOperationResponse(vaultBaseUrl, storageAccountName, sasDefinitionName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets information about a SAS definition for the specified storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} sasDefinitionName The name of the SAS definition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SasDefinitionBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SasDefinitionBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, optionalCallback);
    }
  }

  /**
   * Creates or updates a new SAS definition for the specified storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} sasDefinitionName The name of the SAS definition.
   *
   * @param {object} parameters Sas definition creation metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.sasDefinitionAttributes] The attributes of the SAS
   * definition.
   *
   * @param {boolean} [options.sasDefinitionAttributes.enabled] the enabled state
   * of the object.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SasDefinitionBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  setSasDefinitionWithHttpOperationResponse(vaultBaseUrl, storageAccountName, sasDefinitionName, parameters, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._setSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, parameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Creates or updates a new SAS definition for the specified storage account.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} sasDefinitionName The name of the SAS definition.
   *
   * @param {object} parameters Sas definition creation metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.sasDefinitionAttributes] The attributes of the SAS
   * definition.
   *
   * @param {boolean} [options.sasDefinitionAttributes.enabled] the enabled state
   * of the object.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SasDefinitionBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SasDefinitionBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  setSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, parameters, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._setSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, parameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._setSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, parameters, options, optionalCallback);
    }
  }

  /**
   * Updates the specified attributes associated with the given SAS definition.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} sasDefinitionName The name of the SAS definition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.parameters] Sas definition update metadata in the
   * form of key-value pairs.
   *
   * @param {object} [options.sasDefinitionAttributes] The attributes of the SAS
   * definition.
   *
   * @param {boolean} [options.sasDefinitionAttributes.enabled] the enabled state
   * of the object.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SasDefinitionBundle>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateSasDefinitionWithHttpOperationResponse(vaultBaseUrl, storageAccountName, sasDefinitionName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Updates the specified attributes associated with the given SAS definition.
   *
   * @param {string} vaultBaseUrl The vault name, for example
   * https://myvault.vault.azure.net.
   *
   * @param {string} storageAccountName The name of the storage account.
   *
   * @param {string} sasDefinitionName The name of the SAS definition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.parameters] Sas definition update metadata in the
   * form of key-value pairs.
   *
   * @param {object} [options.sasDefinitionAttributes] The attributes of the SAS
   * definition.
   *
   * @param {boolean} [options.sasDefinitionAttributes.enabled] the enabled state
   * of the object.
   *
   * @param {object} [options.tags] Application specific metadata in the form of
   * key-value pairs.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SasDefinitionBundle} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SasDefinitionBundle} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateSasDefinition(vaultBaseUrl, storageAccountName, sasDefinitionName, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves a list of individual key versions with the same key name.
   *
   * The full key identifier, attributes, and tags are provided in the response.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getKeyVersionsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getKeyVersionsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves a list of individual key versions with the same key name.
   *
   * The full key identifier, attributes, and tags are provided in the response.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getKeyVersionsNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getKeyVersionsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getKeyVersionsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List keys in the specified vault.
   *
   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures
   * that contain the public part of a stored key. The LIST operation is
   * applicable to all key types, however only the base key
   * identifier,attributes, and tags are provided in the response. Individual
   * versions of a key are not listed in the response. Authorization: Requires
   * the keys/list permission.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeyListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getKeysNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getKeysNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List keys in the specified vault.
   *
   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures
   * that contain the public part of a stored key. The LIST operation is
   * applicable to all key types, however only the base key
   * identifier,attributes, and tags are provided in the response. Individual
   * versions of a key are not listed in the response. Authorization: Requires
   * the keys/list permission.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {KeyListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeyListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getKeysNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getKeysNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getKeysNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * List deleted keys in the specified vault. Authorization: Requires the
   * keys/list permission.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedKeyListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeletedKeysNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeletedKeysNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * List deleted keys in the specified vault. Authorization: Requires the
   * keys/list permission.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedKeyListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedKeyListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeletedKeysNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeletedKeysNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeletedKeysNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List secrets in a specified key vault
   *
   * The LIST operation is applicable to the entire vault, however only the base
   * secret identifier and attributes are provided in the response. Individual
   * secret versions are not listed in the response.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SecretListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSecretsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSecretsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List secrets in a specified key vault
   *
   * The LIST operation is applicable to the entire vault, however only the base
   * secret identifier and attributes are provided in the response. Individual
   * secret versions are not listed in the response.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SecretListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SecretListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSecretsNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSecretsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSecretsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List the versions of the specified secret.
   *
   * The LIST VERSIONS operation can be applied to all versions having the same
   * secret name in the same key vault. The full secret identifier and attributes
   * are provided in the response. No values are returned for the secrets and
   * only current versions of a secret are listed.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SecretListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSecretVersionsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSecretVersionsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List the versions of the specified secret.
   *
   * The LIST VERSIONS operation can be applied to all versions having the same
   * secret name in the same key vault. The full secret identifier and attributes
   * are provided in the response. No values are returned for the secrets and
   * only current versions of a secret are listed.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SecretListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SecretListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSecretVersionsNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSecretVersionsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSecretVersionsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * List deleted secrets in the specified vault. Authorization: requires the
   * secrets/list permission.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedSecretListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeletedSecretsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeletedSecretsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * List deleted secrets in the specified vault. Authorization: requires the
   * secrets/list permission.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedSecretListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedSecretListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeletedSecretsNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeletedSecretsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeletedSecretsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List certificates in a specified key vault
   *
   * The GetCertificates operation returns the set of certificates resources in
   * the specified key vault.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificatesNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificatesNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List certificates in a specified key vault
   *
   * The GetCertificates operation returns the set of certificates resources in
   * the specified key vault.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificatesNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificatesNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificatesNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List certificate issuers for a specified key vault.
   *
   * The GetCertificateIssuers operation returns the set of certificate issuer
   * resources in the specified key vault
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateIssuerListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificateIssuersNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificateIssuersNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List certificate issuers for a specified key vault.
   *
   * The GetCertificateIssuers operation returns the set of certificate issuer
   * resources in the specified key vault
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateIssuerListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateIssuerListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificateIssuersNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificateIssuersNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificateIssuersNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List the versions of a certificate.
   *
   * The GetCertificateVersions operation returns the versions of a certificate
   * in the specified key vault
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CertificateListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCertificateVersionsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCertificateVersionsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List the versions of a certificate.
   *
   * The GetCertificateVersions operation returns the versions of a certificate
   * in the specified key vault
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CertificateListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CertificateListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCertificateVersionsNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCertificateVersionsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCertificateVersionsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Lists the deleted certificates in the specified vault, currently
   * available for recovery.
   *
   * The GetDeletedCertificates operation retrieves the certificates in the
   * current vault which are in a deleted state and ready for recovery or
   * purging.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeletedCertificateListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeletedCertificatesNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeletedCertificatesNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the deleted certificates in the specified vault, currently
   * available for recovery.
   *
   * The GetDeletedCertificates operation retrieves the certificates in the
   * current vault which are in a deleted state and ready for recovery or
   * purging.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeletedCertificateListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeletedCertificateListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeletedCertificatesNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeletedCertificatesNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeletedCertificatesNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * List storage accounts managed by specified key vault
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StorageListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getStorageAccountsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getStorageAccountsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * List storage accounts managed by specified key vault
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getStorageAccountsNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getStorageAccountsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getStorageAccountsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * List storage SAS definitions for the given storage account.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SasDefinitionListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSasDefinitionsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSasDefinitionsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * List storage SAS definitions for the given storage account.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SasDefinitionListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SasDefinitionListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSasDefinitionsNext(nextPageLink, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSasDefinitionsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSasDefinitionsNext(nextPageLink, options, optionalCallback);
    }
  }

}

module.exports = KeyVaultClient;
