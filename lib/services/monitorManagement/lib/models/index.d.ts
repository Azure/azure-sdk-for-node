/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { BaseResource, CloudError } from "ms-rest-azure";
import * as moment from "moment";

export {

  BaseResource,
  CloudError
};

/**
 * An azure resource object
 */
export interface Resource extends BaseResource {
  /**
   * Azure resource Id
   */
  readonly id?: string;
  /**
   * Azure resource name
   */
  readonly name?: string;
  /**
   * Azure resource type
   */
  readonly type?: string;
  /**
   * Resource location
   */
  location: string;
  /**
   * Resource tags
   */
  tags?: { [propertyName: string]: string };
}

/**
 * The number of instances that can be used during this profile.
 */
export interface ScaleCapacity {
  /**
   * the minimum number of instances for the resource.
   */
  minimum: string;
  /**
   * the maximum number of instances for the resource. The actual maximum number of instances is
   * limited by the cores that are available in the subscription.
   */
  maximum: string;
  /**
   * the number of instances that will be set if metrics are not available for evaluation. The
   * default is only used if the current instance count is lower than the default.
   */
  default: string;
}

/**
 * The trigger that results in a scaling action.
 */
export interface MetricTrigger {
  /**
   * the name of the metric that defines what the rule monitors.
   */
  metricName: string;
  /**
   * the resource identifier of the resource the rule monitors.
   */
  metricResourceUri: string;
  /**
   * the granularity of metrics the rule monitors. Must be one of the predefined values returned
   * from metric definitions for the metric. Must be between 12 hours and 1 minute.
   */
  timeGrain: moment.Duration;
  /**
   * the metric statistic type. How the metrics from multiple instances are combined. Possible
   * values include: 'Average', 'Min', 'Max', 'Sum'
   */
  statistic: string;
  /**
   * the range of time in which instance data is collected. This value must be greater than the
   * delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours
   * and 5 minutes.
   */
  timeWindow: moment.Duration;
  /**
   * time aggregation type. How the data that is collected should be combined over time. The
   * default value is Average. Possible values include: 'Average', 'Minimum', 'Maximum', 'Total',
   * 'Count', 'Last'
   */
  timeAggregation: string;
  /**
   * the operator that is used to compare the metric data and the threshold. Possible values
   * include: 'Equals', 'NotEquals', 'GreaterThan', 'GreaterThanOrEqual', 'LessThan',
   * 'LessThanOrEqual'
   */
  operator: string;
  /**
   * the threshold of the metric that triggers the scale action.
   */
  threshold: number;
}

/**
 * The parameters for the scaling action.
 */
export interface ScaleAction {
  /**
   * the scale direction. Whether the scaling action increases or decreases the number of
   * instances. Possible values include: 'None', 'Increase', 'Decrease'
   */
  direction: string;
  /**
   * the type of action that should occur when the scale rule fires. Possible values include:
   * 'ChangeCount', 'PercentChangeCount', 'ExactCount'
   */
  type: string;
  /**
   * the number of instances that are involved in the scaling action. This value must be 1 or
   * greater. The default value is 1.
   */
  value?: string;
  /**
   * the amount of time to wait since the last scaling action before this action occurs. It must be
   * between 1 week and 1 minute in ISO 8601 format.
   */
  cooldown: moment.Duration;
}

/**
 * A rule that provide the triggers and parameters for the scaling action.
 */
export interface ScaleRule {
  /**
   * the trigger that results in a scaling action.
   */
  metricTrigger: MetricTrigger;
  /**
   * the parameters for the scaling action.
   */
  scaleAction: ScaleAction;
}

/**
 * A specific date-time for the profile.
 */
export interface TimeWindow {
  /**
   * the timezone of the start and end times for the profile. Some examples of valid time zones
   * are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific
   * Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard
   * Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time,
   * Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time,
   * Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard
   * Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time,
   * Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time,
   * Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo
   * Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time,
   * Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard
   * Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central
   * European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan
   * Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria
   * Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey
   * Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic
   * Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa
   * Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia
   * Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time,
   * Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan
   * Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia
   * Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time,
   * SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard
   * Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar
   * Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia
   * Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard
   * Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok
   * Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New
   * Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard
   * Time, Samoa Standard Time, Line Islands Standard Time
   */
  timeZone?: string;
  /**
   * the start time for the profile in ISO 8601 format.
   */
  start: Date;
  /**
   * the end time for the profile in ISO 8601 format.
   */
  end: Date;
}

/**
 * The scheduling constraints for when the profile begins.
 */
export interface RecurrentSchedule {
  /**
   * the timezone for the hours of the profile. Some examples of valid time zones are: Dateline
   * Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time
   * (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico),
   * Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard
   * Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time,
   * US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard
   * Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time,
   * Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA
   * Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time,
   * UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco
   * Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time,
   * Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W.
   * Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time,
   * Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time,
   * South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time,
   * Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time,
   * Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time,
   * Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time,
   * Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard
   * Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka
   * Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N.
   * Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard
   * Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W.
   * Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time,
   * Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard
   * Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time,
   * Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10,
   * Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji
   * Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands
   * Standard Time
   */
  timeZone: string;
  /**
   * the collection of days that the profile takes effect on. Possible values are Sunday through
   * Saturday.
   */
  days: string[];
  /**
   * A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the
   * 24-hour clock (AM/PM times are not supported).
   */
  hours: number[];
  /**
   * A collection of minutes at which the profile takes effect at.
   */
  minutes: number[];
}

/**
 * The repeating times at which this profile begins. This element is not used if the FixedDate
 * element is used.
 */
export interface Recurrence {
  /**
   * the recurrence frequency. How often the schedule profile should take effect. This value must
   * be Week, meaning each week will have the same set of profiles. For example, to set a daily
   * schedule, set **schedule** to every day of the week. The frequency property specifies that the
   * schedule is repeated weekly. Possible values include: 'None', 'Second', 'Minute', 'Hour',
   * 'Day', 'Week', 'Month', 'Year'
   */
  frequency: string;
  /**
   * the scheduling constraints for when the profile begins.
   */
  schedule: RecurrentSchedule;
}

/**
 * Autoscale profile.
 */
export interface AutoscaleProfile {
  /**
   * the name of the profile.
   */
  name: string;
  /**
   * the number of instances that can be used during this profile.
   */
  capacity: ScaleCapacity;
  /**
   * the collection of rules that provide the triggers and parameters for the scaling action. A
   * maximum of 10 rules can be specified.
   */
  rules: ScaleRule[];
  /**
   * the specific date-time for the profile. This element is not used if the Recurrence element is
   * used.
   */
  fixedDate?: TimeWindow;
  /**
   * the repeating times at which this profile begins. This element is not used if the FixedDate
   * element is used.
   */
  recurrence?: Recurrence;
}

/**
 * Email notification of an autoscale event.
 */
export interface EmailNotification {
  /**
   * a value indicating whether to send email to subscription administrator.
   */
  sendToSubscriptionAdministrator?: boolean;
  /**
   * a value indicating whether to send email to subscription co-administrators.
   */
  sendToSubscriptionCoAdministrators?: boolean;
  /**
   * the custom e-mails list. This value can be null or empty, in which case this attribute will be
   * ignored.
   */
  customEmails?: string[];
}

/**
 * Webhook notification of an autoscale event.
 */
export interface WebhookNotification {
  /**
   * the service address to receive the notification.
   */
  serviceUri?: string;
  /**
   * a property bag of settings. This value can be empty.
   */
  properties?: { [propertyName: string]: string };
}

/**
 * Autoscale notification.
 */
export interface AutoscaleNotification {
  /**
   * the email notification.
   */
  email?: EmailNotification;
  /**
   * the collection of webhook notifications.
   */
  webhooks?: WebhookNotification[];
}

/**
 * The autoscale setting resource.
 */
export interface AutoscaleSettingResource extends Resource {
  /**
   * the collection of automatic scaling profiles that specify different scaling parameters for
   * different time periods. A maximum of 20 profiles can be specified.
   */
  profiles: AutoscaleProfile[];
  /**
   * the collection of notifications.
   */
  notifications?: AutoscaleNotification[];
  /**
   * the enabled flag. Specifies whether automatic scaling is enabled for the resource. The default
   * value is 'true'.
   */
  enabled?: boolean;
  /**
   * the name of the autoscale setting.
   */
  autoscaleSettingResourceName?: string;
  /**
   * the resource identifier of the resource that the autoscale setting should be added to.
   */
  targetResourceUri?: string;
}

/**
 * The autoscale setting object for patch operations.
 */
export interface AutoscaleSettingResourcePatch {
  /**
   * Resource tags
   */
  tags?: { [propertyName: string]: string };
  /**
   * the collection of automatic scaling profiles that specify different scaling parameters for
   * different time periods. A maximum of 20 profiles can be specified.
   */
  profiles: AutoscaleProfile[];
  /**
   * the collection of notifications.
   */
  notifications?: AutoscaleNotification[];
  /**
   * the enabled flag. Specifies whether automatic scaling is enabled for the resource. The default
   * value is 'true'.
   */
  enabled?: boolean;
  /**
   * the name of the autoscale setting.
   */
  name?: string;
  /**
   * the resource identifier of the resource that the autoscale setting should be added to.
   */
  targetResourceUri?: string;
}

/**
 * Describes the format of Error response.
 */
export interface ErrorResponse {
  /**
   * Error code
   */
  code?: string;
  /**
   * Error message indicating why the operation failed.
   */
  message?: string;
}

/**
 * Display metadata associated with the operation.
 */
export interface OperationDisplay {
  /**
   * Service provider: Microsoft.Insights
   */
  provider?: string;
  /**
   * Resource on which the operation is performed: AlertRules, Autoscale, etc.
   */
  resource?: string;
  /**
   * Operation type: Read, write, delete, etc.
   */
  operation?: string;
}

/**
 * Microsoft Insights API operation definition.
 */
export interface Operation {
  /**
   * Operation name: {provider}/{resource}/{operation}
   */
  name?: string;
  /**
   * Display metadata associated with the operation.
   */
  display?: OperationDisplay;
}

/**
 * Result of the request to list Microsoft.Insights operations. It contains a list of operations
 * and a URL link to get the next set of results.
 */
export interface OperationListResult {
  /**
   * List of operations supported by the Microsoft.Insights provider.
   */
  value?: Operation[];
  /**
   * URL to get the next set of operation list results if there are any.
   */
  nextLink?: string;
}

/**
 * An alert incident indicates the activation status of an alert rule.
 */
export interface Incident {
  /**
   * Incident name.
   */
  readonly name?: string;
  /**
   * Rule name that is associated with the incident.
   */
  readonly ruleName?: string;
  /**
   * A boolean to indicate whether the incident is active or resolved.
   */
  readonly isActive?: boolean;
  /**
   * The time at which the incident was activated in ISO8601 format.
   */
  readonly activatedTime?: Date;
  /**
   * The time at which the incident was resolved in ISO8601 format. If null, it means the incident
   * is still active.
   */
  readonly resolvedTime?: Date;
}

/**
 * The resource from which the rule collects its data.
 */
export interface RuleDataSource {
  /**
   * the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be
   * updated for an existing rule.
   */
  resourceUri?: string;
  /**
   * Polymorphic Discriminator
   */
  odatatype: string;
}

/**
 * The condition that results in the alert rule being activated.
 */
export interface RuleCondition {
  /**
   * the resource from which the rule collects its data. For this type dataSource will always be of
   * type RuleMetricDataSource.
   */
  dataSource?: RuleDataSource;
  /**
   * Polymorphic Discriminator
   */
  odatatype: string;
}

/**
 * A rule metric data source. The discriminator value is always RuleMetricDataSource in this case.
 */
export interface RuleMetricDataSource extends RuleDataSource {
  /**
   * the name of the metric that defines what the rule monitors.
   */
  metricName?: string;
}

/**
 * The claims for a rule management event data source.
 */
export interface RuleManagementEventClaimsDataSource {
  /**
   * the email address.
   */
  emailAddress?: string;
}

/**
 * A rule management event data source. The discriminator fields is always
 * RuleManagementEventDataSource in this case.
 */
export interface RuleManagementEventDataSource extends RuleDataSource {
  /**
   * the event name.
   */
  eventName?: string;
  /**
   * the event source.
   */
  eventSource?: string;
  /**
   * the level.
   */
  level?: string;
  /**
   * The name of the operation that should be checked for. If no name is provided, any operation
   * will match.
   */
  operationName?: string;
  /**
   * the resource group name.
   */
  resourceGroupName?: string;
  /**
   * the resource provider name.
   */
  resourceProviderName?: string;
  /**
   * The status of the operation that should be checked for. If no status is provided, any status
   * will match.
   */
  status?: string;
  /**
   * the substatus.
   */
  subStatus?: string;
  /**
   * the claims.
   */
  claims?: RuleManagementEventClaimsDataSource;
}

/**
 * A rule condition based on a metric crossing a threshold.
 */
export interface ThresholdRuleCondition extends RuleCondition {
  /**
   * the operator used to compare the data and the threshold. Possible values include:
   * 'GreaterThan', 'GreaterThanOrEqual', 'LessThan', 'LessThanOrEqual'
   */
  operator: string;
  /**
   * the threshold value that activates the alert.
   */
  threshold: number;
  /**
   * the period of time (in ISO 8601 duration format) that is used to monitor alert activity based
   * on the threshold. If specified then it must be between 5 minutes and 1 day.
   */
  windowSize?: moment.Duration;
  /**
   * the time aggregation operator. How the data that are collected should be combined over time.
   * The default value is the PrimaryAggregationType of the Metric. Possible values include:
   * 'Average', 'Minimum', 'Maximum', 'Total', 'Last'
   */
  timeAggregation?: string;
}

/**
 * A rule condition based on a certain number of locations failing.
 */
export interface LocationThresholdRuleCondition extends RuleCondition {
  /**
   * the period of time (in ISO 8601 duration format) that is used to monitor alert activity based
   * on the threshold. If specified then it must be between 5 minutes and 1 day.
   */
  windowSize?: moment.Duration;
  /**
   * the number of locations that must fail to activate the alert.
   */
  failedLocationCount: number;
}

/**
 * How the data that is collected should be combined over time.
 */
export interface ManagementEventAggregationCondition {
  /**
   * the condition operator. Possible values include: 'GreaterThan', 'GreaterThanOrEqual',
   * 'LessThan', 'LessThanOrEqual'
   */
  operator?: string;
  /**
   * The threshold value that activates the alert.
   */
  threshold?: number;
  /**
   * the period of time (in ISO 8601 duration format) that is used to monitor alert activity based
   * on the threshold. If specified then it must be between 5 minutes and 1 day.
   */
  windowSize?: moment.Duration;
}

/**
 * A management event rule condition.
 */
export interface ManagementEventRuleCondition extends RuleCondition {
  /**
   * How the data that is collected should be combined over time and when the alert is activated.
   * Note that for management event alerts aggregation is optional – if it is not provided then any
   * event will cause the alert to activate.
   */
  aggregation?: ManagementEventAggregationCondition;
}

/**
 * The action that is performed when the alert rule becomes active, and when an alert condition is
 * resolved.
 */
export interface RuleAction {
  /**
   * Polymorphic Discriminator
   */
  odatatype: string;
}

/**
 * Specifies the action to send email when the rule condition is evaluated. The discriminator is
 * always RuleEmailAction in this case.
 */
export interface RuleEmailAction extends RuleAction {
  /**
   * Whether the administrators (service and co-administrators) of the service should be notified
   * when the alert is activated.
   */
  sendToServiceOwners?: boolean;
  /**
   * the list of administrator's custom email addresses to notify of the activation of the alert.
   */
  customEmails?: string[];
}

/**
 * Specifies the action to post to service when the rule condition is evaluated. The discriminator
 * is always RuleWebhookAction in this case.
 */
export interface RuleWebhookAction extends RuleAction {
  /**
   * the service uri to Post the notification when the alert activates or resolves.
   */
  serviceUri?: string;
  /**
   * the dictionary of custom properties to include with the post operation. These data are
   * appended to the webhook payload.
   */
  properties?: { [propertyName: string]: string };
}

/**
 * The alert rule resource.
 */
export interface AlertRuleResource extends Resource {
  /**
   * the name of the alert rule.
   */
  alertRuleResourceName: string;
  /**
   * the description of the alert rule that will be included in the alert email.
   */
  description?: string;
  /**
   * the flag that indicates whether the alert rule is enabled.
   */
  isEnabled: boolean;
  /**
   * the condition that results in the alert rule being activated.
   */
  condition: RuleCondition;
  /**
   * the array of actions that are performed when the alert rule becomes active, and when an alert
   * condition is resolved.
   */
  actions?: RuleAction[];
  /**
   * Last time the rule was updated in ISO8601 format.
   */
  readonly lastUpdatedTime?: Date;
}

/**
 * The alert rule object for patch operations.
 */
export interface AlertRuleResourcePatch {
  /**
   * Resource tags
   */
  tags?: { [propertyName: string]: string };
  /**
   * the name of the alert rule.
   */
  name: string;
  /**
   * the description of the alert rule that will be included in the alert email.
   */
  description?: string;
  /**
   * the flag that indicates whether the alert rule is enabled.
   */
  isEnabled: boolean;
  /**
   * the condition that results in the alert rule being activated.
   */
  condition: RuleCondition;
  /**
   * the array of actions that are performed when the alert rule becomes active, and when an alert
   * condition is resolved.
   */
  actions?: RuleAction[];
  /**
   * Last time the rule was updated in ISO8601 format.
   */
  readonly lastUpdatedTime?: Date;
}

/**
 * Specifies the retention policy for the log.
 */
export interface RetentionPolicy {
  /**
   * a value indicating whether the retention policy is enabled.
   */
  enabled: boolean;
  /**
   * the number of days for the retention in days. A value of 0 will retain the events
   * indefinitely.
   */
  days: number;
}

/**
 * The log profile resource.
 */
export interface LogProfileResource extends Resource {
  /**
   * the resource id of the storage account to which you would like to send the Activity Log.
   */
  storageAccountId?: string;
  /**
   * The service bus rule ID of the service bus namespace in which you would like to have Event
   * Hubs created for streaming the Activity Log. The rule ID is of the format: '{service bus
   * resource ID}/authorizationrules/{key name}'.
   */
  serviceBusRuleId?: string;
  /**
   * List of regions for which Activity Log events should be stored or streamed. It is a comma
   * separated list of valid ARM locations including the 'global' location.
   */
  locations: string[];
  /**
   * the categories of the logs. These categories are created as is convenient to the user. Some
   * values are: 'Write', 'Delete', and/or 'Action.'
   */
  categories: string[];
  /**
   * the retention policy for the events in the log.
   */
  retentionPolicy: RetentionPolicy;
}

/**
 * The log profile resource for patch operations.
 */
export interface LogProfileResourcePatch {
  /**
   * Resource tags
   */
  tags?: { [propertyName: string]: string };
  /**
   * the resource id of the storage account to which you would like to send the Activity Log.
   */
  storageAccountId?: string;
  /**
   * The service bus rule ID of the service bus namespace in which you would like to have Event
   * Hubs created for streaming the Activity Log. The rule ID is of the format: '{service bus
   * resource ID}/authorizationrules/{key name}'.
   */
  serviceBusRuleId?: string;
  /**
   * List of regions for which Activity Log events should be stored or streamed. It is a comma
   * separated list of valid ARM locations including the 'global' location.
   */
  locations: string[];
  /**
   * the categories of the logs. These categories are created as is convenient to the user. Some
   * values are: 'Write', 'Delete', and/or 'Action.'
   */
  categories: string[];
  /**
   * the retention policy for the events in the log.
   */
  retentionPolicy: RetentionPolicy;
}

/**
 * A proxy only azure resource object
 */
export interface ProxyOnlyResource extends BaseResource {
  /**
   * Azure resource Id
   */
  readonly id?: string;
  /**
   * Azure resource name
   */
  readonly name?: string;
  /**
   * Azure resource type
   */
  readonly type?: string;
}

/**
 * Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular metric.
 */
export interface MetricSettings {
  /**
   * the timegrain of the metric in ISO8601 format.
   */
  timeGrain?: moment.Duration;
  /**
   * Name of a Diagnostic Metric category for a resource type this setting is applied to. To obtain
   * the list of Diagnostic metric categories for a resource, first perform a GET diagnostic
   * settings operation.
   */
  category?: string;
  /**
   * a value indicating whether this category is enabled.
   */
  enabled: boolean;
  /**
   * the retention policy for this category.
   */
  retentionPolicy?: RetentionPolicy;
}

/**
 * Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular log.
 */
export interface LogSettings {
  /**
   * Name of a Diagnostic Log category for a resource type this setting is applied to. To obtain
   * the list of Diagnostic Log categories for a resource, first perform a GET diagnostic settings
   * operation.
   */
  category?: string;
  /**
   * a value indicating whether this log is enabled.
   */
  enabled: boolean;
  /**
   * the retention policy for this log.
   */
  retentionPolicy?: RetentionPolicy;
}

/**
 * The diagnostic setting resource.
 */
export interface DiagnosticSettingsResource extends ProxyOnlyResource {
  /**
   * The resource ID of the storage account to which you would like to send Diagnostic Logs.
   */
  storageAccountId?: string;
  /**
   * The service bus rule Id of the diagnostic setting. This is here to maintain backwards
   * compatibility.
   */
  serviceBusRuleId?: string;
  /**
   * The resource Id for the event hub authorization rule.
   */
  eventHubAuthorizationRuleId?: string;
  /**
   * The name of the event hub. If none is specified, the default event hub will be selected.
   */
  eventHubName?: string;
  /**
   * the list of metric settings.
   */
  metrics?: MetricSettings[];
  /**
   * the list of logs settings.
   */
  logs?: LogSettings[];
  /**
   * The workspace ID (resource ID of a Log Analytics workspace) for a Log Analytics workspace to
   * which you would like to send Diagnostic Logs. Example:
   * /subscriptions/4b9e8510-67ab-4e9a-95a9-e2f1e570ea9c/resourceGroups/insights-integration/providers/Microsoft.OperationalInsights/workspaces/viruela2
   */
  workspaceId?: string;
}

/**
 * Represents a collection of alert rule resources.
 */
export interface DiagnosticSettingsResourceCollection {
  /**
   * The collection of diagnostic settings resources;.
   */
  value?: DiagnosticSettingsResource[];
}

/**
 * The diagnostic settings category resource.
 */
export interface DiagnosticSettingsCategoryResource extends ProxyOnlyResource {
  /**
   * The type of the diagnostic settings category. Possible values include: 'Metrics', 'Logs'
   */
  categoryType?: string;
}

/**
 * Represents a collection of diagnostic setting category resources.
 */
export interface DiagnosticSettingsCategoryResourceCollection {
  /**
   * The collection of diagnostic settings category resources.
   */
  value?: DiagnosticSettingsCategoryResource[];
}

/**
 * An email receiver.
 */
export interface EmailReceiver {
  /**
   * The name of the email receiver. Names must be unique across all receivers within an action
   * group.
   */
  name: string;
  /**
   * The email address of this receiver.
   */
  emailAddress: string;
  /**
   * The receiver status of the e-mail. Possible values include: 'NotSpecified', 'Enabled',
   * 'Disabled'
   */
  readonly status?: string;
}

/**
 * An SMS receiver.
 */
export interface SmsReceiver {
  /**
   * The name of the SMS receiver. Names must be unique across all receivers within an action
   * group.
   */
  name: string;
  /**
   * The country code of the SMS receiver.
   */
  countryCode: string;
  /**
   * The phone number of the SMS receiver.
   */
  phoneNumber: string;
  /**
   * The status of the receiver. Possible values include: 'NotSpecified', 'Enabled', 'Disabled'
   */
  readonly status?: string;
}

/**
 * A webhook receiver.
 */
export interface WebhookReceiver {
  /**
   * The name of the webhook receiver. Names must be unique across all receivers within an action
   * group.
   */
  name: string;
  /**
   * The URI where webhooks should be sent.
   */
  serviceUri: string;
}

/**
 * An Itsm receiver.
 */
export interface ItsmReceiver {
  /**
   * The name of the Itsm receiver. Names must be unique across all receivers within an action
   * group.
   */
  name: string;
  /**
   * OMS LA instance identifier.
   */
  workspaceId: string;
  /**
   * Unique identification of ITSM connection among multiple defined in above workspace.
   */
  connectionId: string;
  /**
   * JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be
   * part of this blob as well.
   */
  ticketConfiguration: string;
  /**
   * Region in which workspace resides. Supported
   * values:'centralindia','japaneast','southeastasia','australiasoutheast','uksouth','westcentralus','canadacentral','eastus','westeurope'
   */
  region: string;
}

/**
 * The Azure mobile App push notification receiver.
 */
export interface AzureAppPushReceiver {
  /**
   * The name of the Azure mobile app push receiver. Names must be unique across all receivers
   * within an action group.
   */
  name: string;
  /**
   * The email address registered for the Azure mobile app.
   */
  emailAddress: string;
}

/**
 * The Azure Automation Runbook notification receiver.
 */
export interface AutomationRunbookReceiver {
  /**
   * The Azure automation account Id which holds this runbook and authenticate to Azure resource.
   */
  automationAccountId: string;
  /**
   * The name for this runbook.
   */
  runbookName: string;
  /**
   * The resource id for webhook linked to this runbook.
   */
  webhookResourceId: string;
  /**
   * Indicates whether this instance is global runbook.
   */
  isGlobalRunbook: boolean;
  /**
   * Indicates name of the webhook.
   */
  name?: string;
  /**
   * The URI where webhooks should be sent.
   */
  serviceUri?: string;
}

/**
 * A voice receiver.
 */
export interface VoiceReceiver {
  /**
   * The name of the voice receiver. Names must be unique across all receivers within an action
   * group.
   */
  name: string;
  /**
   * The country code of the voice receiver.
   */
  countryCode: string;
  /**
   * The phone number of the voice receiver.
   */
  phoneNumber: string;
}

/**
 * A logic app receiver.
 */
export interface LogicAppReceiver {
  /**
   * The name of the logic app receiver. Names must be unique across all receivers within an action
   * group.
   */
  name: string;
  /**
   * The azure resource id of the logic app receiver.
   */
  resourceId: string;
  /**
   * The callback url where http request sent to.
   */
  callbackUrl: string;
}

/**
 * An azure function receiver.
 */
export interface AzureFunctionReceiver {
  /**
   * The name of the azure function receiver. Names must be unique across all receivers within an
   * action group.
   */
  name: string;
  /**
   * The azure resource id of the function app.
   */
  functionAppResourceId: string;
  /**
   * The function name in the function app.
   */
  functionName: string;
  /**
   * The http trigger url where http request sent to.
   */
  httpTriggerUrl: string;
}

/**
 * An arm role receiver.
 */
export interface ArmRoleReceiver {
  /**
   * The name of the arm role receiver. Names must be unique across all receivers within an action
   * group.
   */
  name: string;
  /**
   * The arm role id.
   */
  roleId: string;
}

/**
 * An action group resource.
 */
export interface ActionGroupResource extends Resource {
  /**
   * The short name of the action group. This will be used in SMS messages.
   */
  groupShortName: string;
  /**
   * Indicates whether this action group is enabled. If an action group is not enabled, then none
   * of its receivers will receive communications.
   */
  enabled: boolean;
  /**
   * The list of email receivers that are part of this action group.
   */
  emailReceivers?: EmailReceiver[];
  /**
   * The list of SMS receivers that are part of this action group.
   */
  smsReceivers?: SmsReceiver[];
  /**
   * The list of webhook receivers that are part of this action group.
   */
  webhookReceivers?: WebhookReceiver[];
  /**
   * The list of ITSM receivers that are part of this action group.
   */
  itsmReceivers?: ItsmReceiver[];
  /**
   * The list of AzureAppPush receivers that are part of this action group.
   */
  azureAppPushReceivers?: AzureAppPushReceiver[];
  /**
   * The list of AutomationRunbook receivers that are part of this action group.
   */
  automationRunbookReceivers?: AutomationRunbookReceiver[];
  /**
   * The list of voice receivers that are part of this action group.
   */
  voiceReceivers?: VoiceReceiver[];
  /**
   * The list of logic app receivers that are part of this action group.
   */
  logicAppReceivers?: LogicAppReceiver[];
  /**
   * The list of azure function receivers that are part of this action group.
   */
  azureFunctionReceivers?: AzureFunctionReceiver[];
  /**
   * The list of ARM role receivers that are part of this action group. Roles are Azure RBAC roles
   * and only built-in roles are supported.
   */
  armRoleReceivers?: ArmRoleReceiver[];
}

/**
 * Describes a receiver that should be resubscribed.
 */
export interface EnableRequest {
  /**
   * The name of the receiver to resubscribe.
   */
  receiverName: string;
}

/**
 * An action group object for the body of patch operations.
 */
export interface ActionGroupPatchBody {
  /**
   * Resource tags
   */
  tags?: { [propertyName: string]: string };
  /**
   * Indicates whether this action group is enabled. If an action group is not enabled, then none
   * of its actions will be activated.
   */
  enabled?: boolean;
}

/**
 * An Activity Log alert condition that is met by comparing an activity log field and value.
 */
export interface ActivityLogAlertLeafCondition {
  /**
   * The name of the field that this condition will examine. The possible values for this field are
   * (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName',
   * 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything
   * beginning with 'properties.'.
   */
  field: string;
  /**
   * The field value will be compared to this value (case-insensitive) to determine if the
   * condition is met.
   */
  equals: string;
}

/**
 * An Activity Log alert condition that is met when all its member conditions are met.
 */
export interface ActivityLogAlertAllOfCondition {
  /**
   * The list of activity log alert conditions.
   */
  allOf: ActivityLogAlertLeafCondition[];
}

/**
 * A pointer to an Azure Action Group.
 */
export interface ActivityLogAlertActionGroup {
  /**
   * The resourceId of the action group. This cannot be null or empty.
   */
  actionGroupId: string;
  /**
   * the dictionary of custom properties to include with the post operation. These data are
   * appended to the webhook payload.
   */
  webhookProperties?: { [propertyName: string]: string };
}

/**
 * A list of activity log alert actions.
 */
export interface ActivityLogAlertActionList {
  /**
   * The list of activity log alerts.
   */
  actionGroups?: ActivityLogAlertActionGroup[];
}

/**
 * An activity log alert resource.
 */
export interface ActivityLogAlertResource extends Resource {
  /**
   * A list of resourceIds that will be used as prefixes. The alert will only apply to activityLogs
   * with resourceIds that fall under one of these prefixes. This list must include at least one
   * item.
   */
  scopes: string[];
  /**
   * Indicates whether this activity log alert is enabled. If an activity log alert is not enabled,
   * then none of its actions will be activated.
   */
  enabled?: boolean;
  /**
   * The condition that will cause this alert to activate.
   */
  condition: ActivityLogAlertAllOfCondition;
  /**
   * The actions that will activate when the condition is met.
   */
  actions: ActivityLogAlertActionList;
  /**
   * A description of this activity log alert.
   */
  description?: string;
}

/**
 * An activity log alert object for the body of patch operations.
 */
export interface ActivityLogAlertPatchBody {
  /**
   * Resource tags
   */
  tags?: { [propertyName: string]: string };
  /**
   * Indicates whether this activity log alert is enabled. If an activity log alert is not enabled,
   * then none of its actions will be activated.
   */
  enabled?: boolean;
}

/**
 * The localizable string class.
 */
export interface LocalizableString {
  /**
   * the invariant value.
   */
  value: string;
  /**
   * the locale specific value.
   */
  localizedValue?: string;
}

/**
 * the authorization used by the user who has performed the operation that led to this event. This
 * captures the RBAC properties of the event. These usually include the 'action', 'role' and the
 * 'scope'
 */
export interface SenderAuthorization {
  /**
   * the permissible actions. For instance: microsoft.support/supporttickets/write
   */
  action?: string;
  /**
   * the role of the user. For instance: Subscription Admin
   */
  role?: string;
  /**
   * the scope.
   */
  scope?: string;
}

/**
 * The Http request info.
 */
export interface HttpRequestInfo {
  /**
   * the client request id.
   */
  clientRequestId?: string;
  /**
   * the client Ip Address
   */
  clientIpAddress?: string;
  /**
   * the Http request method.
   */
  method?: string;
  /**
   * the Uri.
   */
  uri?: string;
}

/**
 * The Azure event log entries are of type EventData
 */
export interface EventData {
  /**
   * The sender authorization information.
   */
  readonly authorization?: SenderAuthorization;
  /**
   * key value pairs to identify ARM permissions.
   */
  readonly claims?: { [propertyName: string]: string };
  /**
   * the email address of the user who has performed the operation, the UPN claim or SPN claim
   * based on availability.
   */
  readonly caller?: string;
  /**
   * the description of the event.
   */
  readonly description?: string;
  /**
   * the Id of this event as required by ARM for RBAC. It contains the EventDataID and a timestamp
   * information.
   */
  readonly id?: string;
  /**
   * the event data Id. This is a unique identifier for an event.
   */
  readonly eventDataId?: string;
  /**
   * the correlation Id, usually a GUID in the string format. The correlation Id is shared among
   * the events that belong to the same uber operation.
   */
  readonly correlationId?: string;
  /**
   * the event name. This value should not be confused with OperationName. For practical purposes,
   * OperationName might be more appealing to end users.
   */
  readonly eventName?: LocalizableString;
  /**
   * the event category.
   */
  readonly category?: LocalizableString;
  /**
   * the HTTP request info. Usually includes the 'clientRequestId', 'clientIpAddress' (IP address
   * of the user who initiated the event) and 'method' (HTTP method e.g. PUT).
   */
  readonly httpRequest?: HttpRequestInfo;
  /**
   * the event level. Possible values include: 'Critical', 'Error', 'Warning', 'Informational',
   * 'Verbose'
   */
  readonly level?: string;
  /**
   * the resource group name of the impacted resource.
   */
  readonly resourceGroupName?: string;
  /**
   * the resource provider name of the impacted resource.
   */
  readonly resourceProviderName?: LocalizableString;
  /**
   * the resource uri that uniquely identifies the resource that caused this event.
   */
  readonly resourceId?: string;
  /**
   * the resource type
   */
  readonly resourceType?: LocalizableString;
  /**
   * It is usually a GUID shared among the events corresponding to single operation. This value
   * should not be confused with EventName.
   */
  readonly operationId?: string;
  /**
   * the operation name.
   */
  readonly operationName?: LocalizableString;
  /**
   * the set of <Key, Value> pairs (usually a Dictionary<String, String>) that includes details
   * about the event.
   */
  readonly properties?: { [propertyName: string]: string };
  /**
   * a string describing the status of the operation. Some typical values are: Started, In
   * progress, Succeeded, Failed, Resolved.
   */
  readonly status?: LocalizableString;
  /**
   * the event sub status. Most of the time, when included, this captures the HTTP status code of
   * the REST call. Common values are: OK (HTTP Status Code: 200), Created (HTTP Status Code: 201),
   * Accepted (HTTP Status Code: 202), No Content (HTTP Status Code: 204), Bad Request(HTTP Status
   * Code: 400), Not Found (HTTP Status Code: 404), Conflict (HTTP Status Code: 409), Internal
   * Server Error (HTTP Status Code: 500), Service Unavailable (HTTP Status Code:503), Gateway
   * Timeout (HTTP Status Code: 504)
   */
  readonly subStatus?: LocalizableString;
  /**
   * the timestamp of when the event was generated by the Azure service processing the request
   * corresponding the event. It in ISO 8601 format.
   */
  readonly eventTimestamp?: Date;
  /**
   * the timestamp of when the event became available for querying via this API. It is in ISO 8601
   * format. This value should not be confused eventTimestamp. As there might be a delay between
   * the occurrence time of the event, and the time that the event is submitted to the Azure
   * logging infrastructure.
   */
  readonly submissionTimestamp?: Date;
  /**
   * the Azure subscription Id usually a GUID.
   */
  readonly subscriptionId?: string;
  /**
   * the Azure tenant Id
   */
  readonly tenantId?: string;
}

/**
 * Metric availability specifies the time grain (aggregation interval or frequency) and the
 * retention period for that time grain.
 */
export interface MetricAvailability {
  /**
   * the time grain specifies the aggregation interval for the metric. Expressed as a duration
   * 'PT1M', 'P1D', etc.
   */
  timeGrain?: moment.Duration;
  /**
   * the retention period for the metric at the specified timegrain.  Expressed as a duration
   * 'PT1M', 'P1D', etc.
   */
  retention?: moment.Duration;
}

/**
 * Metric definition class specifies the metadata for a metric.
 */
export interface MetricDefinition {
  /**
   * Flag to indicate whether the dimension is required.
   */
  isDimensionRequired?: boolean;
  /**
   * the resource identifier of the resource that emitted the metric.
   */
  resourceId?: string;
  /**
   * the namespace the metric belongs to.
   */
  namespace?: string;
  /**
   * the name and the display name of the metric, i.e. it is a localizable string.
   */
  name?: LocalizableString;
  /**
   * the unit of the metric. Possible values include: 'Count', 'Bytes', 'Seconds',
   * 'CountPerSecond', 'BytesPerSecond', 'Percent', 'MilliSeconds', 'ByteSeconds', 'Unspecified'
   */
  unit?: string;
  /**
   * the primary aggregation type value defining how to use the values for display. Possible values
   * include: 'None', 'Average', 'Count', 'Minimum', 'Maximum', 'Total'
   */
  primaryAggregationType?: string;
  /**
   * the collection of what aggregation types are supported.
   */
  supportedAggregationTypes?: string[];
  /**
   * the collection of what aggregation intervals are available to be queried.
   */
  metricAvailabilities?: MetricAvailability[];
  /**
   * the resource identifier of the metric definition.
   */
  id?: string;
  /**
   * the name and the display name of the dimension, i.e. it is a localizable string.
   */
  dimensions?: LocalizableString[];
}

/**
 * Represents a metric value.
 */
export interface MetricValue {
  /**
   * the timestamp for the metric value in ISO 8601 format.
   */
  timeStamp: Date;
  /**
   * the average value in the time range.
   */
  average?: number;
  /**
   * the least value in the time range.
   */
  minimum?: number;
  /**
   * the greatest value in the time range.
   */
  maximum?: number;
  /**
   * the sum of all of the values in the time range.
   */
  total?: number;
  /**
   * the number of samples in the time range. Can be used to determine the number of values that
   * contributed to the average value.
   */
  count?: number;
}

/**
 * Represents a metric metadata value.
 */
export interface MetadataValue {
  /**
   * the name of the metadata.
   */
  name?: LocalizableString;
  /**
   * the value of the metadata.
   */
  value?: string;
}

/**
 * A time series result type. The discriminator value is always TimeSeries in this case.
 */
export interface TimeSeriesElement {
  /**
   * the metadata values returned if $filter was specified in the call.
   */
  metadatavalues?: MetadataValue[];
  /**
   * An array of data points representing the metric values.  This is only returned if a result
   * type of data is specified.
   */
  data?: MetricValue[];
}

/**
 * The result data of a query.
 */
export interface Metric {
  /**
   * the metric Id.
   */
  id: string;
  /**
   * the resource type of the metric resource.
   */
  type: string;
  /**
   * the name and the display name of the metric, i.e. it is localizable string.
   */
  name: LocalizableString;
  /**
   * the unit of the metric. Possible values include: 'Count', 'Bytes', 'Seconds',
   * 'CountPerSecond', 'BytesPerSecond', 'Percent', 'MilliSeconds', 'ByteSeconds', 'Unspecified'
   */
  unit: string;
  /**
   * the time series returned when a data query is performed.
   */
  timeseries: TimeSeriesElement[];
}

/**
 * The response to a metrics query.
 */
export interface Response {
  /**
   * The integer value representing the cost of the query, for data case.
   */
  cost?: number;
  /**
   * The timespan for which the data was retrieved. Its value consists of two datetimes
   * concatenated, separated by '/'.  This may be adjusted in the future and returned back from
   * what was originally requested.
   */
  timespan: string;
  /**
   * The interval (window size) for which the metric data was returned in.  This may be adjusted in
   * the future and returned back from what was originally requested.  This is not present if a
   * metadata request was made.
   */
  interval?: moment.Duration;
  /**
   * The namespace of the metrics been queried
   */
  namespace?: string;
  /**
   * The region of the resource been queried for metrics.
   */
  resourceregion?: string;
  /**
   * the value of the collection.
   */
  value: Metric[];
}

/**
 * Represents a baseline metadata value.
 */
export interface BaselineMetadataValue {
  /**
   * the name of the metadata.
   */
  name?: LocalizableString;
  /**
   * the value of the metadata.
   */
  value?: string;
}

/**
 * The baseline values for a single sensitivity value.
 */
export interface Baseline {
  /**
   * the sensitivity of the baseline. Possible values include: 'Low', 'Medium', 'High'
   */
  sensitivity: string;
  /**
   * The low thresholds of the baseline.
   */
  lowThresholds: number[];
  /**
   * The high thresholds of the baseline.
   */
  highThresholds: number[];
}

/**
 * The response to a baseline query.
 */
export interface BaselineResponse {
  /**
   * the metric baseline Id.
   */
  readonly id?: string;
  /**
   * the resource type of the baseline resource.
   */
  readonly type?: string;
  /**
   * the name and the display name of the metric, i.e. it is localizable string.
   */
  readonly name?: LocalizableString;
  /**
   * The timespan for which the data was retrieved. Its value consists of two datetimes
   * concatenated, separated by '/'.  This may be adjusted in the future and returned back from
   * what was originally requested.
   */
  timespan?: string;
  /**
   * The interval (window size) for which the metric data was returned in.  This may be adjusted in
   * the future and returned back from what was originally requested.  This is not present if a
   * metadata request was made.
   */
  interval?: moment.Duration;
  /**
   * The aggregation type of the metric.
   */
  aggregation?: string;
  /**
   * the array of timestamps of the baselines.
   */
  timestamps?: Date[];
  /**
   * the baseline values for each sensitivity.
   */
  baseline?: Baseline[];
  /**
   * the baseline metadata values.
   */
  metadata?: BaselineMetadataValue[];
}

/**
 * The time series info needed for calculating the baseline.
 */
export interface TimeSeriesInformation {
  /**
   * the list of sensitivities for calculating the baseline.
   */
  sensitivities: string[];
  /**
   * The metric values to calculate the baseline.
   */
  values: number[];
  /**
   * the array of timestamps of the baselines.
   */
  timestamps?: Date[];
}

/**
 * The response to a calculate baseline call.
 */
export interface CalculateBaselineResponse {
  /**
   * the resource type of the baseline resource.
   */
  type: string;
  /**
   * the array of timestamps of the baselines.
   */
  timestamps?: Date[];
  /**
   * the baseline values for each sensitivity.
   */
  baseline: Baseline[];
}

/**
 * An alert action.
 */
export interface MetricAlertAction {
  /**
   * the id of the action group to use.
   */
  actionGroupId?: string;
  /**
   * The properties of a webhook object.
   */
  webhookProperties?: { [propertyName: string]: string };
}

/**
 * The rule criteria that defines the conditions of the alert rule.
 */
export interface MetricAlertCriteria {
  /**
   * Polymorphic Discriminator
   */
  odatatype: string;
  /**
   * Describes unknown properties. The value of an unknown property can be of "any" type.
   */
  [additionalPropertyName: string]: any;
}

/**
 * The metric alert resource.
 */
export interface MetricAlertResource extends Resource {
  /**
   * the description of the metric alert that will be included in the alert email.
   */
  description: string;
  /**
   * Alert severity {0, 1, 2, 3, 4}
   */
  severity: number;
  /**
   * the flag that indicates whether the metric alert is enabled.
   */
  enabled: boolean;
  /**
   * the list of resource id's that this metric alert is scoped to.
   */
  scopes?: string[];
  /**
   * how often the metric alert is evaluated represented in ISO 8601 duration format.
   */
  evaluationFrequency: moment.Duration;
  /**
   * the period of time (in ISO 8601 duration format) that is used to monitor alert activity based
   * on the threshold.
   */
  windowSize: moment.Duration;
  /**
   * the resource type of the target resource(s) on which the alert is created/updated. Mandatory
   * for MultipleResourceMultipleMetricCriteria.
   */
  targetResourceType?: string;
  /**
   * the region of the target resource(s) on which the alert is created/updated. Mandatory for
   * MultipleResourceMultipleMetricCriteria.
   */
  targetResourceRegion?: string;
  /**
   * defines the specific alert criteria information.
   */
  criteria: MetricAlertCriteria;
  /**
   * the flag that indicates whether the alert should be auto resolved or not.
   */
  autoMitigate?: boolean;
  /**
   * the array of actions that are performed when the alert rule becomes active, and when an alert
   * condition is resolved.
   */
  actions?: MetricAlertAction[];
  /**
   * Last time the rule was updated in ISO8601 format.
   */
  readonly lastUpdatedTime?: Date;
}

/**
 * The metric alert resource for patch operations.
 */
export interface MetricAlertResourcePatch {
  /**
   * Resource tags
   */
  tags?: { [propertyName: string]: string };
  /**
   * the description of the metric alert that will be included in the alert email.
   */
  description: string;
  /**
   * Alert severity {0, 1, 2, 3, 4}
   */
  severity: number;
  /**
   * the flag that indicates whether the metric alert is enabled.
   */
  enabled: boolean;
  /**
   * the list of resource id's that this metric alert is scoped to.
   */
  scopes?: string[];
  /**
   * how often the metric alert is evaluated represented in ISO 8601 duration format.
   */
  evaluationFrequency: moment.Duration;
  /**
   * the period of time (in ISO 8601 duration format) that is used to monitor alert activity based
   * on the threshold.
   */
  windowSize: moment.Duration;
  /**
   * the resource type of the target resource(s) on which the alert is created/updated. Mandatory
   * for MultipleResourceMultipleMetricCriteria.
   */
  targetResourceType?: string;
  /**
   * the region of the target resource(s) on which the alert is created/updated. Mandatory for
   * MultipleResourceMultipleMetricCriteria.
   */
  targetResourceRegion?: string;
  /**
   * defines the specific alert criteria information.
   */
  criteria: MetricAlertCriteria;
  /**
   * the flag that indicates whether the alert should be auto resolved or not.
   */
  autoMitigate?: boolean;
  /**
   * the array of actions that are performed when the alert rule becomes active, and when an alert
   * condition is resolved.
   */
  actions?: MetricAlertAction[];
  /**
   * Last time the rule was updated in ISO8601 format.
   */
  readonly lastUpdatedTime?: Date;
}

/**
 * An alert status properties.
 */
export interface MetricAlertStatusProperties {
  /**
   * An object describing the type of the dimensions.
   */
  dimensions?: { [propertyName: string]: string };
  /**
   * status value
   */
  status?: string;
  /**
   * UTC time when the status was checked.
   */
  timestamp?: Date;
}

/**
 * An alert status.
 */
export interface MetricAlertStatus {
  /**
   * The status name.
   */
  name?: string;
  /**
   * The alert rule arm id.
   */
  id?: string;
  /**
   * The extended resource type name.
   */
  type?: string;
  /**
   * The alert status properties of the metric alert status.
   */
  properties?: MetricAlertStatusProperties;
}

/**
 * Represents a collection of alert rule resources.
 */
export interface MetricAlertStatusCollection {
  /**
   * the values for the alert rule resources.
   */
  value?: MetricAlertStatus[];
}

/**
 * Specifies a metric dimension.
 */
export interface MetricDimension {
  /**
   * Name of the dimension.
   */
  name: string;
  /**
   * the dimension operator. Only 'Include' and 'Exclude' are supported
   */
  operator: string;
  /**
   * list of dimension values.
   */
  values: string[];
}

/**
 * The types of conditions for a multi resource alert
 */
export interface MultiMetricCriteria {
  /**
   * Polymorphic Discriminator
   */
  criterionType: string;
  /**
   * Describes unknown properties. The value of an unknown property can be of "any" type.
   */
  [additionalPropertyName: string]: any;
}

/**
 * Criterion to filter metrics.
 */
export interface MetricCriteria extends MultiMetricCriteria {
  /**
   * Name of the criteria.
   */
  name: string;
  /**
   * Name of the metric.
   */
  metricName: string;
  /**
   * Namespace of the metric.
   */
  metricNamespace?: string;
  /**
   * the criteria operator.
   */
  operator: any;
  /**
   * the criteria time aggregation types.
   */
  timeAggregation: any;
  /**
   * the criteria threshold value that activates the alert.
   */
  threshold: number;
  /**
   * List of dimension conditions.
   */
  dimensions?: MetricDimension[];
}

/**
 * Specifies the metric alert criteria for a single resource that has multiple metric criteria.
 */
export interface MetricAlertSingleResourceMultipleMetricCriteria extends MetricAlertCriteria {
  /**
   * The list of metric criteria for this 'all of' operation.
   */
  allOf?: MetricCriteria[];
}

/**
 * Specifies the metric alert criteria for multiple resource that has multiple metric criteria.
 */
export interface MetricAlertMultipleResourceMultipleMetricCriteria extends MetricAlertCriteria {
  /**
   * the list of multiple metric criteria for this 'all of' operation.
   */
  allOf?: MultiMetricCriteria[];
}

/**
 * Specifies the log search query.
 */
export interface Source {
  /**
   * Log search query. Required for action type - AlertingAction
   */
  query?: string;
  /**
   * List of  Resource referred into query
   */
  authorizedResources?: string[];
  /**
   * The resource uri over which log search query is to be run.
   */
  dataSourceId: string;
  /**
   * Set value to 'ResultCount'. Possible values include: 'ResultCount'
   */
  queryType?: string;
}

/**
 * Defines how often to run the search and the time interval.
 */
export interface Schedule {
  /**
   * frequency (in minutes) at which rule condition should be evaluated.
   */
  frequencyInMinutes: number;
  /**
   * Time window for which data needs to be fetched for query (should be greater than or equal to
   * frequencyInMinutes).
   */
  timeWindowInMinutes: number;
}

/**
 * Action descriptor.
 */
export interface Action {
  /**
   * Polymorphic Discriminator
   */
  odatatype: string;
}

/**
 * The Log Search Rule resource.
 */
export interface LogSearchRuleResource extends Resource {
  /**
   * The description of the Log Search rule.
   */
  description?: string;
  /**
   * The flag which indicates whether the Log Search rule is enabled. Value should be true or
   * false. Possible values include: 'true', 'false'
   */
  enabled?: string;
  /**
   * Last time the rule was updated in IS08601 format.
   */
  readonly lastUpdatedTime?: Date;
  /**
   * Provisioning state of the scheduled query rule. Possible values include: 'Succeeded',
   * 'Deploying', 'Canceled', 'Failed'
   */
  readonly provisioningState?: string;
  /**
   * Data Source against which rule will Query Data
   */
  source: Source;
  /**
   * Schedule (Frequency, Time Window) for rule. Required for action type - AlertingAction
   */
  schedule?: Schedule;
  /**
   * Action needs to be taken on rule execution.
   */
  action: Action;
}

/**
 * The log search rule resource for patch operations.
 */
export interface LogSearchRuleResourcePatch {
  /**
   * Resource tags
   */
  tags?: { [propertyName: string]: string };
  /**
   * The flag which indicates whether the Log Search rule is enabled. Value should be true or
   * false. Possible values include: 'true', 'false'
   */
  enabled?: string;
}

/**
 * A log metrics trigger descriptor.
 */
export interface LogMetricTrigger {
  /**
   * Evaluation operation for Metric -'GreaterThan' or 'LessThan' or 'Equal'. Possible values
   * include: 'GreaterThan', 'LessThan', 'Equal'
   */
  thresholdOperator?: string;
  /**
   * The threshold of the metric trigger.
   */
  threshold?: number;
  /**
   * Metric Trigger Type - 'Consecutive' or 'Total'. Possible values include: 'Consecutive',
   * 'Total'
   */
  metricTriggerType?: string;
  /**
   * Evaluation of metric on a particular column
   */
  metricColumn?: string;
}

/**
 * The condition that results in the Log Search rule.
 */
export interface TriggerCondition {
  /**
   * Evaluation operation for rule - 'GreaterThan' or 'LessThan. Possible values include:
   * 'GreaterThan', 'LessThan', 'Equal'
   */
  thresholdOperator: string;
  /**
   * Result or count threshold based on which rule should be triggered.
   */
  threshold: number;
  /**
   * Trigger condition for metric query rule
   */
  metricTrigger?: LogMetricTrigger;
}

/**
 * Azure action group
 */
export interface AzNsActionGroup {
  /**
   * Azure Action Group reference.
   */
  actionGroup?: string[];
  /**
   * Custom subject override for all email ids in Azure action group
   */
  emailSubject?: string;
  /**
   * Custom payload to be sent for all webhook URI in Azure action group
   */
  customWebhookPayload?: string;
}

/**
 * Specify action need to be taken when rule type is Alert
 */
export interface AlertingAction extends Action {
  /**
   * Severity of the alert. Possible values include: '0', '1', '2', '3', '4'
   */
  severity: string;
  /**
   * Azure action group reference.
   */
  aznsAction: AzNsActionGroup;
  /**
   * time (in minutes) for which Alerts should be throttled or suppressed.
   */
  throttlingInMin?: number;
  /**
   * The trigger condition that results in the alert rule being.
   */
  trigger: TriggerCondition;
}

/**
 * Specifies the criteria for converting log to metric.
 */
export interface Dimension {
  /**
   * Name of the dimension
   */
  name: string;
  /**
   * List of dimension values
   */
  values: string[];
}

/**
 * Specifies the criteria for converting log to metric.
 */
export interface Criteria {
  /**
   * Name of the metric
   */
  metricName: string;
  /**
   * List of Dimensions for creating metric
   */
  dimensions?: Dimension[];
}

/**
 * Specify action need to be taken when rule type is converting log to metric
 */
export interface LogToMetricAction extends Action {
  /**
   * Severity of the alert
   */
  criteria: Criteria;
}

/**
 * The fully qualified metric namespace name.
 */
export interface MetricNamespaceName {
  /**
   * The metric namespace name.
   */
  metricNamespaceName?: string;
}

/**
 * Metric namespace class specifies the metadata for a metric namespace.
 */
export interface MetricNamespace {
  /**
   * The ID of the metricNamespace.
   */
  id?: string;
  /**
   * The type of the namespace.
   */
  type?: string;
  /**
   * The name of the namespace.
   */
  name?: string;
  /**
   * Properties which include the fully qualified namespace name.
   */
  properties?: MetricNamespaceName;
}

/**
 * Represents a collection of autoscale setting resources.
 */
export interface AutoscaleSettingResourceCollection extends Array<AutoscaleSettingResource> {
  /**
   * URL to get the next set of results.
   */
  nextLink?: string;
}

/**
 * The List incidents operation response.
 */
export interface IncidentListResult extends Array<Incident> {
}

/**
 * Represents a collection of alert rule resources.
 */
export interface AlertRuleResourceCollection extends Array<AlertRuleResource> {
}

/**
 * Represents a collection of log profiles.
 */
export interface LogProfileCollection extends Array<LogProfileResource> {
}

/**
 * A list of action groups.
 */
export interface ActionGroupList extends Array<ActionGroupResource> {
  /**
   * Provides the link to retrieve the next set of elements.
   */
  nextLink?: string;
}

/**
 * A list of activity log alerts.
 */
export interface ActivityLogAlertList extends Array<ActivityLogAlertResource> {
  /**
   * Provides the link to retrieve the next set of elements.
   */
  nextLink?: string;
}

/**
 * Represents collection of events.
 */
export interface EventDataCollection extends Array<EventData> {
  /**
   * Provides the link to retrieve the next set of events.
   */
  nextLink?: string;
}

/**
 * A collection of event categories. Currently possible values are: Administrative, Security,
 * ServiceHealth, Alert, Recommendation, Policy.
 */
export interface EventCategoryCollection extends Array<LocalizableString> {
}

/**
 * Represents collection of metric definitions.
 */
export interface MetricDefinitionCollection extends Array<MetricDefinition> {
}

/**
 * Represents a collection of alert rule resources.
 */
export interface MetricAlertResourceCollection extends Array<MetricAlertResource> {
}

/**
 * Represents a collection of Log Search rule resources.
 */
export interface LogSearchRuleResourceCollection extends Array<LogSearchRuleResource> {
}

/**
 * Represents collection of metric namespaces.
 */
export interface MetricNamespaceCollection extends Array<MetricNamespace> {
}
