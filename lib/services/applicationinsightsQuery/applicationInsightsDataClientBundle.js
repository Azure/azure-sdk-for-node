var applicationInsightsDataClient =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ms_rest_azure_js_1 = __webpack_require__(3);
exports.CloudError = ms_rest_azure_js_1.CloudErrorMapper;
exports.BaseResource = ms_rest_azure_js_1.BaseResourceMapper;
exports.MetricsPostBodySchemaParameters = {
    serializedName: "metricsPostBodySchema_parameters",
    type: {
        name: "Composite",
        className: "MetricsPostBodySchemaParameters",
        modelProperties: {
            metricId: {
                serializedName: "metricId",
                type: {
                    name: "String"
                }
            },
            timespan: {
                serializedName: "timespan",
                type: {
                    name: "String"
                }
            },
            aggregation: {
                serializedName: "aggregation",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetricsAggregationElementType",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "min",
                                "max",
                                "avg",
                                "sum",
                                "count",
                                "unique"
                            ]
                        }
                    }
                }
            },
            interval: {
                serializedName: "interval",
                type: {
                    name: "TimeSpan"
                }
            },
            segment: {
                serializedName: "segment",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetricsSegmentElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            },
            orderby: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.MetricsPostBodySchema = {
    serializedName: "metricsPostBodySchema",
    type: {
        name: "Composite",
        className: "MetricsPostBodySchema",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            parameters: {
                required: true,
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "MetricsPostBodySchemaParameters"
                }
            }
        }
    }
};
exports.MetricsSegmentInfo = {
    serializedName: "metricsSegmentInfo",
    type: {
        name: "Composite",
        className: "MetricsSegmentInfo",
        modelProperties: {
            additionalProperties: {
                type: {
                    name: "Dictionary",
                    value: {
                        serializedName: "ObjectElementType",
                        type: {
                            name: "Object"
                        }
                    }
                }
            },
            start: {
                serializedName: "start",
                type: {
                    name: "DateTime"
                }
            },
            end: {
                serializedName: "end",
                type: {
                    name: "DateTime"
                }
            },
            segments: {
                serializedName: "segments",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetricsSegmentInfoElementType",
                        type: {
                            name: "Composite",
                            className: "MetricsSegmentInfo"
                        }
                    }
                }
            }
        }
    }
};
exports.MetricsResultInfo = {
    serializedName: "metricsResultInfo",
    type: {
        name: "Composite",
        className: "MetricsResultInfo",
        modelProperties: {
            additionalProperties: {
                type: {
                    name: "Dictionary",
                    value: {
                        serializedName: "ObjectElementType",
                        type: {
                            name: "Object"
                        }
                    }
                }
            },
            start: {
                serializedName: "start",
                type: {
                    name: "DateTime"
                }
            },
            end: {
                serializedName: "end",
                type: {
                    name: "DateTime"
                }
            },
            interval: {
                serializedName: "interval",
                type: {
                    name: "TimeSpan"
                }
            },
            segments: {
                serializedName: "segments",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetricsSegmentInfoElementType",
                        type: {
                            name: "Composite",
                            className: "MetricsSegmentInfo"
                        }
                    }
                }
            }
        }
    }
};
exports.MetricsResult = {
    serializedName: "metricsResult",
    type: {
        name: "Composite",
        className: "MetricsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "MetricsResultInfo"
                }
            }
        }
    }
};
exports.MetricsResultsItem = {
    serializedName: "metricsResultsItem",
    type: {
        name: "Composite",
        className: "MetricsResultsItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Number"
                }
            },
            body: {
                serializedName: "body",
                type: {
                    name: "Composite",
                    className: "MetricsResult"
                }
            }
        }
    }
};
exports.ErrorDetail = {
    serializedName: "errorDetail",
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                required: true,
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                required: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            additionalProperties: {
                serializedName: "additionalProperties",
                type: {
                    name: "Object"
                }
            }
        }
    }
};
exports.ErrorInfo = {
    serializedName: "errorInfo",
    type: {
        name: "Composite",
        className: "ErrorInfo",
        modelProperties: {
            code: {
                required: true,
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                required: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ErrorDetailElementType",
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorInfo"
                }
            },
            additionalProperties: {
                serializedName: "additionalProperties",
                type: {
                    name: "Object"
                }
            }
        }
    }
};
exports.EventsResultDataCustomDimensions = {
    serializedName: "eventsResultData_customDimensions",
    type: {
        name: "Composite",
        className: "EventsResultDataCustomDimensions",
        modelProperties: {
            additionalProperties: {
                serializedName: "additionalProperties",
                type: {
                    name: "Object"
                }
            }
        }
    }
};
exports.EventsResultDataCustomMeasurements = {
    serializedName: "eventsResultData_customMeasurements",
    type: {
        name: "Composite",
        className: "EventsResultDataCustomMeasurements",
        modelProperties: {
            additionalProperties: {
                serializedName: "additionalProperties",
                type: {
                    name: "Object"
                }
            }
        }
    }
};
exports.EventsOperationInfo = {
    serializedName: "eventsOperationInfo",
    type: {
        name: "Composite",
        className: "EventsOperationInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            parentId: {
                serializedName: "parentId",
                type: {
                    name: "String"
                }
            },
            syntheticSource: {
                serializedName: "syntheticSource",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsSessionInfo = {
    serializedName: "eventsSessionInfo",
    type: {
        name: "Composite",
        className: "EventsSessionInfo",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsUserInfo = {
    serializedName: "eventsUserInfo",
    type: {
        name: "Composite",
        className: "EventsUserInfo",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            accountId: {
                serializedName: "accountId",
                type: {
                    name: "String"
                }
            },
            authenticatedId: {
                serializedName: "authenticatedId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsCloudInfo = {
    serializedName: "eventsCloudInfo",
    type: {
        name: "Composite",
        className: "EventsCloudInfo",
        modelProperties: {
            roleName: {
                serializedName: "roleName",
                type: {
                    name: "String"
                }
            },
            roleInstance: {
                serializedName: "roleInstance",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsAiInfo = {
    serializedName: "eventsAiInfo",
    type: {
        name: "Composite",
        className: "EventsAiInfo",
        modelProperties: {
            iKey: {
                serializedName: "iKey",
                type: {
                    name: "String"
                }
            },
            appName: {
                serializedName: "appName",
                type: {
                    name: "String"
                }
            },
            appId: {
                serializedName: "appId",
                type: {
                    name: "String"
                }
            },
            sdkVersion: {
                serializedName: "sdkVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsApplicationInfo = {
    serializedName: "eventsApplicationInfo",
    type: {
        name: "Composite",
        className: "EventsApplicationInfo",
        modelProperties: {
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsClientInfo = {
    serializedName: "eventsClientInfo",
    type: {
        name: "Composite",
        className: "EventsClientInfo",
        modelProperties: {
            model: {
                serializedName: "model",
                type: {
                    name: "String"
                }
            },
            os: {
                serializedName: "os",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            browser: {
                serializedName: "browser",
                type: {
                    name: "String"
                }
            },
            ip: {
                serializedName: "ip",
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                type: {
                    name: "String"
                }
            },
            stateOrProvince: {
                serializedName: "stateOrProvince",
                type: {
                    name: "String"
                }
            },
            countryOrRegion: {
                serializedName: "countryOrRegion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsResultData = {
    serializedName: "eventsResultData",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        uberParent: "EventsResultData",
        className: "EventsResultData",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            count: {
                serializedName: "count",
                type: {
                    name: "Number"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                type: {
                    name: "DateTime"
                }
            },
            customDimensions: {
                serializedName: "customDimensions",
                type: {
                    name: "Composite",
                    className: "EventsResultDataCustomDimensions"
                }
            },
            customMeasurements: {
                serializedName: "customMeasurements",
                type: {
                    name: "Composite",
                    className: "EventsResultDataCustomMeasurements"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "Composite",
                    className: "EventsOperationInfo"
                }
            },
            session: {
                serializedName: "session",
                type: {
                    name: "Composite",
                    className: "EventsSessionInfo"
                }
            },
            user: {
                serializedName: "user",
                type: {
                    name: "Composite",
                    className: "EventsUserInfo"
                }
            },
            cloud: {
                serializedName: "cloud",
                type: {
                    name: "Composite",
                    className: "EventsCloudInfo"
                }
            },
            ai: {
                serializedName: "ai",
                type: {
                    name: "Composite",
                    className: "EventsAiInfo"
                }
            },
            application: {
                serializedName: "application",
                type: {
                    name: "Composite",
                    className: "EventsApplicationInfo"
                }
            },
            client: {
                serializedName: "client",
                type: {
                    name: "Composite",
                    className: "EventsClientInfo"
                }
            },
            type: {
                required: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsResults = {
    serializedName: "eventsResults",
    type: {
        name: "Composite",
        className: "EventsResults",
        modelProperties: {
            odatacontext: {
                serializedName: "@odata\\.context",
                type: {
                    name: "String"
                }
            },
            aimessages: {
                serializedName: "@ai\\.messages",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ErrorInfoElementType",
                        type: {
                            name: "Composite",
                            className: "ErrorInfo"
                        }
                    }
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EventsResultDataElementType",
                        type: {
                            name: "Composite",
                            polymorphicDiscriminator: {
                                serializedName: "type",
                                clientName: "type"
                            },
                            uberParent: "EventsResultData",
                            className: "EventsResultData"
                        }
                    }
                }
            }
        }
    }
};
exports.EventsResult = {
    serializedName: "eventsResult",
    type: {
        name: "Composite",
        className: "EventsResult",
        modelProperties: {
            aimessages: {
                serializedName: "@ai\\.messages",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ErrorInfoElementType",
                        type: {
                            name: "Composite",
                            className: "ErrorInfo"
                        }
                    }
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    polymorphicDiscriminator: {
                        serializedName: "type",
                        clientName: "type"
                    },
                    uberParent: "EventsResultData",
                    className: "EventsResultData"
                }
            }
        }
    }
};
exports.EventsTraceInfo = {
    serializedName: "eventsTraceInfo",
    type: {
        name: "Composite",
        className: "EventsTraceInfo",
        modelProperties: {
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            severityLevel: {
                serializedName: "severityLevel",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.EventsTraceResult = {
    serializedName: "trace",
    type: {
        name: "Composite",
        className: "EventsTraceResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { trace: {
                serializedName: "trace",
                type: {
                    name: "Composite",
                    className: "EventsTraceInfo"
                }
            } })
    }
};
exports.EventsCustomEventInfo = {
    serializedName: "eventsCustomEventInfo",
    type: {
        name: "Composite",
        className: "EventsCustomEventInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsCustomEventResult = {
    serializedName: "customEvent",
    type: {
        name: "Composite",
        className: "EventsCustomEventResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { customEvent: {
                serializedName: "customEvent",
                type: {
                    name: "Composite",
                    className: "EventsCustomEventInfo"
                }
            } })
    }
};
exports.EventsPageViewInfo = {
    serializedName: "eventsPageViewInfo",
    type: {
        name: "Composite",
        className: "EventsPageViewInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            },
            performanceBucket: {
                serializedName: "performanceBucket",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsPageViewResult = {
    serializedName: "pageView",
    type: {
        name: "Composite",
        className: "EventsPageViewResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { pageView: {
                serializedName: "pageView",
                type: {
                    name: "Composite",
                    className: "EventsPageViewInfo"
                }
            } })
    }
};
exports.EventsBrowserTimingInfo = {
    serializedName: "eventsBrowserTimingInfo",
    type: {
        name: "Composite",
        className: "EventsBrowserTimingInfo",
        modelProperties: {
            urlPath: {
                serializedName: "urlPath",
                type: {
                    name: "String"
                }
            },
            urlHost: {
                serializedName: "urlHost",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            totalDuration: {
                serializedName: "totalDuration",
                type: {
                    name: "Number"
                }
            },
            performanceBucket: {
                serializedName: "performanceBucket",
                type: {
                    name: "String"
                }
            },
            networkDuration: {
                serializedName: "networkDuration",
                type: {
                    name: "Number"
                }
            },
            sendDuration: {
                serializedName: "sendDuration",
                type: {
                    name: "Number"
                }
            },
            receiveDuration: {
                serializedName: "receiveDuration",
                type: {
                    name: "Number"
                }
            },
            processingDuration: {
                serializedName: "processingDuration",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.EventsClientPerformanceInfo = {
    serializedName: "eventsClientPerformanceInfo",
    type: {
        name: "Composite",
        className: "EventsClientPerformanceInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsBrowserTimingResult = {
    serializedName: "browserTiming",
    type: {
        name: "Composite",
        className: "EventsBrowserTimingResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { browserTiming: {
                serializedName: "browserTiming",
                type: {
                    name: "Composite",
                    className: "EventsBrowserTimingInfo"
                }
            }, clientPerformance: {
                serializedName: "clientPerformance",
                type: {
                    name: "Composite",
                    className: "EventsClientPerformanceInfo"
                }
            } })
    }
};
exports.EventsRequestInfo = {
    serializedName: "eventsRequestInfo",
    type: {
        name: "Composite",
        className: "EventsRequestInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            success: {
                serializedName: "success",
                type: {
                    name: "String"
                }
            },
            duration: {
                serializedName: "duration",
                type: {
                    name: "Number"
                }
            },
            performanceBucket: {
                serializedName: "performanceBucket",
                type: {
                    name: "String"
                }
            },
            resultCode: {
                serializedName: "resultCode",
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsRequestResult = {
    serializedName: "request",
    type: {
        name: "Composite",
        className: "EventsRequestResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { request: {
                serializedName: "request",
                type: {
                    name: "Composite",
                    className: "EventsRequestInfo"
                }
            } })
    }
};
exports.EventsDependencyInfo = {
    serializedName: "eventsDependencyInfo",
    type: {
        name: "Composite",
        className: "EventsDependencyInfo",
        modelProperties: {
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "String"
                }
            },
            success: {
                serializedName: "success",
                type: {
                    name: "String"
                }
            },
            duration: {
                serializedName: "duration",
                type: {
                    name: "Number"
                }
            },
            performanceBucket: {
                serializedName: "performanceBucket",
                type: {
                    name: "String"
                }
            },
            resultCode: {
                serializedName: "resultCode",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsDependencyResult = {
    serializedName: "dependency",
    type: {
        name: "Composite",
        className: "EventsDependencyResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { dependency: {
                serializedName: "dependency",
                type: {
                    name: "Composite",
                    className: "EventsDependencyInfo"
                }
            } })
    }
};
exports.EventsExceptionDetailsParsedStack = {
    serializedName: "eventsExceptionDetailsParsedStack",
    type: {
        name: "Composite",
        className: "EventsExceptionDetailsParsedStack",
        modelProperties: {
            assembly: {
                serializedName: "assembly",
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            level: {
                serializedName: "level",
                type: {
                    name: "Number"
                }
            },
            line: {
                serializedName: "line",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.EventsExceptionDetail = {
    serializedName: "eventsExceptionDetail",
    type: {
        name: "Composite",
        className: "EventsExceptionDetail",
        modelProperties: {
            severityLevel: {
                serializedName: "severityLevel",
                type: {
                    name: "String"
                }
            },
            outerId: {
                serializedName: "outerId",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            parsedStack: {
                serializedName: "parsedStack",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EventsExceptionDetailsParsedStackElementType",
                        type: {
                            name: "Composite",
                            className: "EventsExceptionDetailsParsedStack"
                        }
                    }
                }
            }
        }
    }
};
exports.EventsExceptionInfo = {
    serializedName: "eventsExceptionInfo",
    type: {
        name: "Composite",
        className: "EventsExceptionInfo",
        modelProperties: {
            severityLevel: {
                serializedName: "severityLevel",
                type: {
                    name: "Number"
                }
            },
            problemId: {
                serializedName: "problemId",
                type: {
                    name: "String"
                }
            },
            handledAt: {
                serializedName: "handledAt",
                type: {
                    name: "String"
                }
            },
            assembly: {
                serializedName: "assembly",
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            outerType: {
                serializedName: "outerType",
                type: {
                    name: "String"
                }
            },
            outerMethod: {
                serializedName: "outerMethod",
                type: {
                    name: "String"
                }
            },
            outerAssembly: {
                serializedName: "outerAssembly",
                type: {
                    name: "String"
                }
            },
            outerMessage: {
                serializedName: "outerMessage",
                type: {
                    name: "String"
                }
            },
            innermostType: {
                serializedName: "innermostType",
                type: {
                    name: "String"
                }
            },
            innermostMessage: {
                serializedName: "innermostMessage",
                type: {
                    name: "String"
                }
            },
            innermostMethod: {
                serializedName: "innermostMethod",
                type: {
                    name: "String"
                }
            },
            innermostAssembly: {
                serializedName: "innermostAssembly",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EventsExceptionDetailElementType",
                        type: {
                            name: "Composite",
                            className: "EventsExceptionDetail"
                        }
                    }
                }
            }
        }
    }
};
exports.EventsExceptionResult = {
    serializedName: "exception",
    type: {
        name: "Composite",
        className: "EventsExceptionResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { exception: {
                serializedName: "exception",
                type: {
                    name: "Composite",
                    className: "EventsExceptionInfo"
                }
            } })
    }
};
exports.EventsAvailabilityResultInfo = {
    serializedName: "eventsAvailabilityResultInfo",
    type: {
        name: "Composite",
        className: "EventsAvailabilityResultInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            success: {
                serializedName: "success",
                type: {
                    name: "String"
                }
            },
            duration: {
                serializedName: "duration",
                type: {
                    name: "Number"
                }
            },
            performanceBucket: {
                serializedName: "performanceBucket",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsAvailabilityResultResult = {
    serializedName: "availabilityResult",
    type: {
        name: "Composite",
        className: "EventsAvailabilityResultResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { availabilityResult: {
                serializedName: "availabilityResult",
                type: {
                    name: "Composite",
                    className: "EventsAvailabilityResultInfo"
                }
            } })
    }
};
exports.EventsPerformanceCounterInfo = {
    serializedName: "eventsPerformanceCounterInfo",
    type: {
        name: "Composite",
        className: "EventsPerformanceCounterInfo",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            counter: {
                serializedName: "counter",
                type: {
                    name: "String"
                }
            },
            instanceName: {
                serializedName: "instanceName",
                type: {
                    name: "String"
                }
            },
            instance: {
                serializedName: "instance",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsPerformanceCounterResult = {
    serializedName: "performanceCounter",
    type: {
        name: "Composite",
        className: "EventsPerformanceCounterResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { performanceCounter: {
                serializedName: "performanceCounter",
                type: {
                    name: "Composite",
                    className: "EventsPerformanceCounterInfo"
                }
            } })
    }
};
exports.EventsCustomMetricInfo = {
    serializedName: "eventsCustomMetricInfo",
    type: {
        name: "Composite",
        className: "EventsCustomMetricInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            },
            valueSum: {
                serializedName: "valueSum",
                type: {
                    name: "Number"
                }
            },
            valueCount: {
                serializedName: "valueCount",
                type: {
                    name: "Number"
                }
            },
            valueMin: {
                serializedName: "valueMin",
                type: {
                    name: "Number"
                }
            },
            valueMax: {
                serializedName: "valueMax",
                type: {
                    name: "Number"
                }
            },
            valueStdDev: {
                serializedName: "valueStdDev",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.EventsCustomMetricResult = {
    serializedName: "customMetric",
    type: {
        name: "Composite",
        className: "EventsCustomMetricResult",
        modelProperties: Object.assign({}, exports.EventsResultData.type.modelProperties, { customMetric: {
                serializedName: "customMetric",
                type: {
                    name: "Composite",
                    className: "EventsCustomMetricInfo"
                }
            } })
    }
};
exports.QueryBody = {
    serializedName: "queryBody",
    type: {
        name: "Composite",
        className: "QueryBody",
        modelProperties: {
            query: {
                required: true,
                serializedName: "query",
                type: {
                    name: "String"
                }
            },
            timespan: {
                serializedName: "timespan",
                type: {
                    name: "String"
                }
            },
            applications: {
                serializedName: "applications",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
exports.Column = {
    serializedName: "column",
    type: {
        name: "Composite",
        className: "Column",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Table = {
    serializedName: "table",
    type: {
        name: "Composite",
        className: "Table",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            columns: {
                required: true,
                serializedName: "columns",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ColumnElementType",
                        type: {
                            name: "Composite",
                            className: "Column"
                        }
                    }
                }
            },
            rows: {
                required: true,
                serializedName: "rows",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ArrayElementType",
                        type: {
                            name: "Sequence",
                            element: {
                                serializedName: "ObjectElementType",
                                type: {
                                    name: "Object"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
exports.QueryResults = {
    serializedName: "queryResults",
    type: {
        name: "Composite",
        className: "QueryResults",
        modelProperties: {
            tables: {
                required: true,
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "TableElementType",
                        type: {
                            name: "Composite",
                            className: "Table"
                        }
                    }
                }
            }
        }
    }
};
exports.ErrorResponse = {
    serializedName: "errorResponse",
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                required: true,
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorInfo"
                }
            }
        }
    }
};
exports.MetricsGetOptionalParams = {
    serializedName: "GetOptions",
    type: {
        name: "Composite",
        className: "MetricsGetOptionalParams",
        modelProperties: {
            timespan: {
                serializedName: "timespan",
                type: {
                    name: "String"
                }
            },
            interval: {
                serializedName: "interval",
                type: {
                    name: "TimeSpan"
                }
            },
            aggregation: {
                serializedName: "aggregation",
                constraints: {
                    MinItems: 1
                },
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetricsAggregationElementType",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "min",
                                "max",
                                "avg",
                                "sum",
                                "count",
                                "unique"
                            ]
                        }
                    }
                }
            },
            segment: {
                serializedName: "segment",
                constraints: {
                    MinItems: 1
                },
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetricsSegmentElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            },
            orderby: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsGetByTypeOptionalParams = {
    serializedName: "GetByTypeOptions",
    type: {
        name: "Composite",
        className: "EventsGetByTypeOptionalParams",
        modelProperties: {
            timespan: {
                serializedName: "timespan",
                type: {
                    name: "String"
                }
            },
            filter: {
                serializedName: "$filter",
                type: {
                    name: "String"
                }
            },
            search: {
                serializedName: "$search",
                type: {
                    name: "String"
                }
            },
            orderby: {
                serializedName: "$orderby",
                type: {
                    name: "String"
                }
            },
            select: {
                serializedName: "$select",
                type: {
                    name: "String"
                }
            },
            skip: {
                serializedName: "$skip",
                type: {
                    name: "Number"
                }
            },
            top: {
                serializedName: "$top",
                type: {
                    name: "Number"
                }
            },
            format: {
                serializedName: "$format",
                type: {
                    name: "String"
                }
            },
            count: {
                serializedName: "$count",
                type: {
                    name: "Boolean"
                }
            },
            apply: {
                serializedName: "$apply",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EventsGetOptionalParams = {
    serializedName: "GetOptions",
    type: {
        name: "Composite",
        className: "EventsGetOptionalParams",
        modelProperties: {
            timespan: {
                serializedName: "timespan",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.discriminators = {
    'eventsResultData': exports.EventsResultData,
    'EventsResultData.trace': exports.EventsTraceResult,
    'EventsResultData.customEvent': exports.EventsCustomEventResult,
    'EventsResultData.pageView': exports.EventsPageViewResult,
    'EventsResultData.browserTiming': exports.EventsBrowserTimingResult,
    'EventsResultData.request': exports.EventsRequestResult,
    'EventsResultData.dependency': exports.EventsDependencyResult,
    'EventsResultData.exception': exports.EventsExceptionResult,
    'EventsResultData.availabilityResult': exports.EventsAvailabilityResultResult,
    'EventsResultData.performanceCounter': exports.EventsPerformanceCounterResult,
    'EventsResultData.customMetric': exports.EventsCustomMetricResult
};


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = msRest;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (immutable) */ __webpack_exports__["__rest"] = __rest;
/* harmony export (immutable) */ __webpack_exports__["__decorate"] = __decorate;
/* harmony export (immutable) */ __webpack_exports__["__param"] = __param;
/* harmony export (immutable) */ __webpack_exports__["__metadata"] = __metadata;
/* harmony export (immutable) */ __webpack_exports__["__awaiter"] = __awaiter;
/* harmony export (immutable) */ __webpack_exports__["__generator"] = __generator;
/* harmony export (immutable) */ __webpack_exports__["__exportStar"] = __exportStar;
/* harmony export (immutable) */ __webpack_exports__["__values"] = __values;
/* harmony export (immutable) */ __webpack_exports__["__read"] = __read;
/* harmony export (immutable) */ __webpack_exports__["__spread"] = __spread;
/* harmony export (immutable) */ __webpack_exports__["__await"] = __await;
/* harmony export (immutable) */ __webpack_exports__["__asyncGenerator"] = __asyncGenerator;
/* harmony export (immutable) */ __webpack_exports__["__asyncDelegator"] = __asyncDelegator;
/* harmony export (immutable) */ __webpack_exports__["__asyncValues"] = __asyncValues;
/* harmony export (immutable) */ __webpack_exports__["__makeTemplateObject"] = __makeTemplateObject;
/* harmony export (immutable) */ __webpack_exports__["__importStar"] = __importStar;
/* harmony export (immutable) */ __webpack_exports__["__importDefault"] = __importDefault;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = msRestAzure;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Models = __webpack_require__(5);
exports.ApplicationInsightsDataModels = Models;
const Mappers = __webpack_require__(0);
exports.ApplicationInsightsDataMappers = Mappers;
const msRest = __webpack_require__(1);
const applicationInsightsDataClientContext_1 = __webpack_require__(6);
const operations = __webpack_require__(7);
class ApplicationInsightsDataClient extends applicationInsightsDataClientContext_1.ApplicationInsightsDataClientContext {
    /**
     * @class
     * Initializes a new instance of the ApplicationInsightsDataClient class.
     * @constructor
     *
     * @param {msRest.ServiceClientCredentials} credentials - Credentials needed for the client to connect to Azure.
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     * @param {string} [options.acceptLanguage] - The preferred language for the response.
     *
     * @param {number} [options.longRunningOperationRetryTimeout] - The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param {boolean} [options.generateClientRequestId] - Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     */
    constructor(credentials, baseUri, options) {
        super(credentials, baseUri, options);
        this.serializer = new msRest.Serializer(Mappers);
        this.metrics = new operations.Metrics(this);
        this.events = new operations.Events(this);
        this.query = new operations.Query(this);
    }
}
exports.ApplicationInsightsDataClient = ApplicationInsightsDataClient;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Defines values for MetricId.
 * Possible values include: 'requests/count', 'requests/duration',
 * 'requests/failed', 'users/count', 'users/authenticated', 'pageViews/count',
 * 'pageViews/duration', 'client/processingDuration', 'client/receiveDuration',
 * 'client/networkDuration', 'client/sendDuration', 'client/totalDuration',
 * 'dependencies/count', 'dependencies/failed', 'dependencies/duration',
 * 'exceptions/count', 'exceptions/browser', 'exceptions/server',
 * 'sessions/count', 'performanceCounters/requestExecutionTime',
 * 'performanceCounters/requestsPerSecond',
 * 'performanceCounters/requestsInQueue',
 * 'performanceCounters/memoryAvailableBytes',
 * 'performanceCounters/exceptionsPerSecond',
 * 'performanceCounters/processCpuPercentage',
 * 'performanceCounters/processIOBytesPerSecond',
 * 'performanceCounters/processPrivateBytes',
 * 'performanceCounters/processorCpuPercentage',
 * 'availabilityResults/availabilityPercentage',
 * 'availabilityResults/duration', 'billing/telemetryCount',
 * 'customEvents/count'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: MetricId = <MetricId>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var MetricId;
(function (MetricId) {
    MetricId["Requestscount"] = "requests/count";
    MetricId["Requestsduration"] = "requests/duration";
    MetricId["Requestsfailed"] = "requests/failed";
    MetricId["Userscount"] = "users/count";
    MetricId["Usersauthenticated"] = "users/authenticated";
    MetricId["PageViewscount"] = "pageViews/count";
    MetricId["PageViewsduration"] = "pageViews/duration";
    MetricId["ClientprocessingDuration"] = "client/processingDuration";
    MetricId["ClientreceiveDuration"] = "client/receiveDuration";
    MetricId["ClientnetworkDuration"] = "client/networkDuration";
    MetricId["ClientsendDuration"] = "client/sendDuration";
    MetricId["ClienttotalDuration"] = "client/totalDuration";
    MetricId["Dependenciescount"] = "dependencies/count";
    MetricId["Dependenciesfailed"] = "dependencies/failed";
    MetricId["Dependenciesduration"] = "dependencies/duration";
    MetricId["Exceptionscount"] = "exceptions/count";
    MetricId["Exceptionsbrowser"] = "exceptions/browser";
    MetricId["Exceptionsserver"] = "exceptions/server";
    MetricId["Sessionscount"] = "sessions/count";
    MetricId["PerformanceCountersrequestExecutionTime"] = "performanceCounters/requestExecutionTime";
    MetricId["PerformanceCountersrequestsPerSecond"] = "performanceCounters/requestsPerSecond";
    MetricId["PerformanceCountersrequestsInQueue"] = "performanceCounters/requestsInQueue";
    MetricId["PerformanceCountersmemoryAvailableBytes"] = "performanceCounters/memoryAvailableBytes";
    MetricId["PerformanceCountersexceptionsPerSecond"] = "performanceCounters/exceptionsPerSecond";
    MetricId["PerformanceCountersprocessCpuPercentage"] = "performanceCounters/processCpuPercentage";
    MetricId["PerformanceCountersprocessIOBytesPerSecond"] = "performanceCounters/processIOBytesPerSecond";
    MetricId["PerformanceCountersprocessPrivateBytes"] = "performanceCounters/processPrivateBytes";
    MetricId["PerformanceCountersprocessorCpuPercentage"] = "performanceCounters/processorCpuPercentage";
    MetricId["AvailabilityResultsavailabilityPercentage"] = "availabilityResults/availabilityPercentage";
    MetricId["AvailabilityResultsduration"] = "availabilityResults/duration";
    MetricId["BillingtelemetryCount"] = "billing/telemetryCount";
    MetricId["CustomEventscount"] = "customEvents/count";
})(MetricId = exports.MetricId || (exports.MetricId = {}));
/**
 * Defines values for MetricsAggregation.
 * Possible values include: 'min', 'max', 'avg', 'sum', 'count', 'unique'
 * @readonly
 * @enum {string}
 */
var MetricsAggregation;
(function (MetricsAggregation) {
    MetricsAggregation["Min"] = "min";
    MetricsAggregation["Max"] = "max";
    MetricsAggregation["Avg"] = "avg";
    MetricsAggregation["Sum"] = "sum";
    MetricsAggregation["Count"] = "count";
    MetricsAggregation["Unique"] = "unique";
})(MetricsAggregation = exports.MetricsAggregation || (exports.MetricsAggregation = {}));
/**
 * Defines values for MetricsSegment.
 * Possible values include: 'applicationBuild', 'applicationVersion',
 * 'authenticatedOrAnonymousTraffic', 'browser', 'browserVersion', 'city',
 * 'cloudRoleName', 'cloudServiceName', 'continent', 'countryOrRegion',
 * 'deploymentId', 'deploymentUnit', 'deviceType', 'environment',
 * 'hostingLocation', 'instanceName'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: MetricsSegment =
 * <MetricsSegment>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var MetricsSegment;
(function (MetricsSegment) {
    MetricsSegment["ApplicationBuild"] = "applicationBuild";
    MetricsSegment["ApplicationVersion"] = "applicationVersion";
    MetricsSegment["AuthenticatedOrAnonymousTraffic"] = "authenticatedOrAnonymousTraffic";
    MetricsSegment["Browser"] = "browser";
    MetricsSegment["BrowserVersion"] = "browserVersion";
    MetricsSegment["City"] = "city";
    MetricsSegment["CloudRoleName"] = "cloudRoleName";
    MetricsSegment["CloudServiceName"] = "cloudServiceName";
    MetricsSegment["Continent"] = "continent";
    MetricsSegment["CountryOrRegion"] = "countryOrRegion";
    MetricsSegment["DeploymentId"] = "deploymentId";
    MetricsSegment["DeploymentUnit"] = "deploymentUnit";
    MetricsSegment["DeviceType"] = "deviceType";
    MetricsSegment["Environment"] = "environment";
    MetricsSegment["HostingLocation"] = "hostingLocation";
    MetricsSegment["InstanceName"] = "instanceName";
})(MetricsSegment = exports.MetricsSegment || (exports.MetricsSegment = {}));
/**
 * Defines values for EventType.
 * Possible values include: '$all', 'traces', 'customEvents', 'pageViews',
 * 'browserTimings', 'requests', 'dependencies', 'exceptions',
 * 'availabilityResults', 'performanceCounters', 'customMetrics'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: EventType = <EventType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var EventType;
(function (EventType) {
    EventType["All"] = "$all";
    EventType["Traces"] = "traces";
    EventType["CustomEvents"] = "customEvents";
    EventType["PageViews"] = "pageViews";
    EventType["BrowserTimings"] = "browserTimings";
    EventType["Requests"] = "requests";
    EventType["Dependencies"] = "dependencies";
    EventType["Exceptions"] = "exceptions";
    EventType["AvailabilityResults"] = "availabilityResults";
    EventType["PerformanceCounters"] = "performanceCounters";
    EventType["CustomMetrics"] = "customMetrics";
})(EventType = exports.EventType || (exports.EventType = {}));


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const msRestAzure = __webpack_require__(3);
const packageName = "azure-applicationinsights-query";
const packageVersion = "1.0.0-Preview-1";
class ApplicationInsightsDataClientContext extends msRestAzure.AzureServiceClient {
    /**
     * @class
     * Initializes a new instance of the ApplicationInsightsDataClient class.
     * @constructor
     *
     * @param {msRest.ServiceClientCredentials} credentials - Credentials needed for the client to connect to Azure.
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     * @param {string} [options.acceptLanguage] - The preferred language for the response.
     *
     * @param {number} [options.longRunningOperationRetryTimeout] - The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param {boolean} [options.generateClientRequestId] - Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     */
    constructor(credentials, baseUri, options) {
        if (credentials == undefined) {
            throw new Error('\'credentials\' cannot be null.');
        }
        if (!options) {
            options = {};
        }
        super(credentials, options);
        this.acceptLanguage = 'en-US';
        this.longRunningOperationRetryTimeout = 30;
        this.baseUri = baseUri;
        if (!this.baseUri) {
            this.baseUri = 'https://api.applicationinsights.io/v1';
        }
        this.credentials = credentials;
        this.addUserAgentInfo(`${packageName}/${packageVersion}`);
        if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
            this.acceptLanguage = options.acceptLanguage;
        }
        if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
            this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
        }
    }
}
exports.ApplicationInsightsDataClientContext = ApplicationInsightsDataClientContext;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const metrics_1 = __webpack_require__(8);
exports.Metrics = metrics_1.Metrics;
const events_1 = __webpack_require__(10);
exports.Events = events_1.Events;
const query_1 = __webpack_require__(12);
exports.Query = query_1.Query;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(9);
const WebResource = msRest.WebResource;
/** Class representing a Metrics. */
class Metrics {
    /**
     * Create a Metrics.
     * @param {ApplicationInsightsDataClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.serializer = new msRest.Serializer(Mappers);
        this.client = client;
    }
    /**
     * @summary Retrieve metric data
     *
     * Gets metric values for a single metric
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {MetricId} metricId ID of the metric. This is either a standard AI metric, or an
     * application-specific custom metric. Possible values include: 'requests/count',
     * 'requests/duration', 'requests/failed', 'users/count', 'users/authenticated', 'pageViews/count',
     * 'pageViews/duration', 'client/processingDuration', 'client/receiveDuration',
     * 'client/networkDuration', 'client/sendDuration', 'client/totalDuration', 'dependencies/count',
     * 'dependencies/failed', 'dependencies/duration', 'exceptions/count', 'exceptions/browser',
     * 'exceptions/server', 'sessions/count', 'performanceCounters/requestExecutionTime',
     * 'performanceCounters/requestsPerSecond', 'performanceCounters/requestsInQueue',
     * 'performanceCounters/memoryAvailableBytes', 'performanceCounters/exceptionsPerSecond',
     * 'performanceCounters/processCpuPercentage', 'performanceCounters/processIOBytesPerSecond',
     * 'performanceCounters/processPrivateBytes', 'performanceCounters/processorCpuPercentage',
     * 'availabilityResults/availabilityPercentage', 'availabilityResults/duration',
     * 'billing/telemetryCount', 'customEvents/count'
     *
     * @param {MetricsGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getWithHttpOperationResponse(appId, metricId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let timespan = (options && options.timespan !== undefined) ? options.timespan : undefined;
            let interval = (options && options.interval !== undefined) ? options.interval : undefined;
            let aggregation = (options && options.aggregation !== undefined) ? options.aggregation : undefined;
            let segment = (options && options.segment !== undefined) ? options.segment : undefined;
            let top = (options && options.top !== undefined) ? options.top : undefined;
            let orderby = (options && options.orderby !== undefined) ? options.orderby : undefined;
            let filter = (options && options.filter !== undefined) ? options.filter : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    metricId,
                    timespan,
                    interval,
                    aggregation,
                    segment,
                    top,
                    orderby,
                    filter,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/metrics/{metricId}",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "metricId",
                            mapper: {
                                required: true,
                                serializedName: "metricId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "timespan",
                            mapper: {
                                serializedName: "timespan",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "interval",
                            mapper: {
                                serializedName: "interval",
                                type: {
                                    name: "TimeSpan"
                                }
                            }
                        },
                        {
                            parameterPath: "aggregation",
                            collectionFormat: msRest.QueryCollectionFormat.Csv,
                            mapper: {
                                serializedName: "aggregation",
                                constraints: {
                                    MinItems: 1
                                },
                                type: {
                                    name: "Sequence",
                                    element: {
                                        serializedName: "MetricsAggregationElementType",
                                        type: {
                                            name: "Enum",
                                            allowedValues: [
                                                "min",
                                                "max",
                                                "avg",
                                                "sum",
                                                "count",
                                                "unique"
                                            ]
                                        }
                                    }
                                }
                            }
                        },
                        {
                            parameterPath: "segment",
                            collectionFormat: msRest.QueryCollectionFormat.Csv,
                            mapper: {
                                serializedName: "segment",
                                constraints: {
                                    MinItems: 1
                                },
                                type: {
                                    name: "Sequence",
                                    element: {
                                        serializedName: "MetricsSegmentElementType",
                                        type: {
                                            name: "String"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            parameterPath: "top",
                            mapper: {
                                serializedName: "top",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "orderby",
                            mapper: {
                                serializedName: "orderby",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "filter",
                            mapper: {
                                serializedName: "filter",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.MetricsResult
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.MetricsResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Retrieve metric data
     *
     * Gets metric values for multiple metrics
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {MetricsPostBodySchema[]} body The batched metrics query.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getMultipleWithHttpOperationResponse(appId, body, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    body,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/metrics",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "body",
                        mapper: {
                            required: true,
                            serializedName: "body",
                            type: {
                                name: "Sequence",
                                element: {
                                    serializedName: "MetricsPostBodySchemaElementType",
                                    type: {
                                        name: "Composite",
                                        className: "MetricsPostBodySchema"
                                    }
                                }
                            }
                        }
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Sequence",
                                    element: {
                                        serializedName: "MetricsResultsItemElementType",
                                        type: {
                                            name: "Composite",
                                            className: "MetricsResultsItem"
                                        }
                                    }
                                }
                            }
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Sequence",
                                    element: {
                                        serializedName: "MetricsResultsItemElementType",
                                        type: {
                                            name: "Composite",
                                            className: "MetricsResultsItem"
                                        }
                                    }
                                }
                            };
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Retrieve metric metatadata
     *
     * Gets metadata describing the available metrics
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getMetadataWithHttpOperationResponse(appId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/metrics/metadata",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            }
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            };
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    get(appId, metricId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(appId, metricId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(appId, metricId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getMultiple(appId, body, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getMultipleWithHttpOperationResponse(appId, body, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getMultipleWithHttpOperationResponse(appId, body, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getMetadata(appId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getMetadataWithHttpOperationResponse(appId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getMetadataWithHttpOperationResponse(appId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Metrics = Metrics;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var mappers_1 = __webpack_require__(0);
exports.discriminators = mappers_1.discriminators;
exports.MetricsResult = mappers_1.MetricsResult;
exports.MetricsResultInfo = mappers_1.MetricsResultInfo;
exports.MetricsSegmentInfo = mappers_1.MetricsSegmentInfo;
exports.ErrorResponse = mappers_1.ErrorResponse;
exports.ErrorInfo = mappers_1.ErrorInfo;
exports.ErrorDetail = mappers_1.ErrorDetail;
exports.MetricsPostBodySchema = mappers_1.MetricsPostBodySchema;
exports.MetricsPostBodySchemaParameters = mappers_1.MetricsPostBodySchemaParameters;
exports.MetricsResultsItem = mappers_1.MetricsResultsItem;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(11);
const WebResource = msRest.WebResource;
/** Class representing a Events. */
class Events {
    /**
     * Create a Events.
     * @param {ApplicationInsightsDataClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.serializer = new msRest.Serializer(Mappers);
        this.client = client;
    }
    /**
     * @summary Execute OData query
     *
     * Executes an OData query for events
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {EventType} eventType The type of events to query; either a standard event type
     * (`traces`, `customEvents`, `pageViews`, `requests`, `dependencies`, `exceptions`,
     * `availabilityResults`) or `$all` to query across all event types. Possible values include:
     * '$all', 'traces', 'customEvents', 'pageViews', 'browserTimings', 'requests', 'dependencies',
     * 'exceptions', 'availabilityResults', 'performanceCounters', 'customMetrics'
     *
     * @param {EventsGetByTypeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getByTypeWithHttpOperationResponse(appId, eventType, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let timespan = (options && options.timespan !== undefined) ? options.timespan : undefined;
            let filter = (options && options.filter !== undefined) ? options.filter : undefined;
            let search = (options && options.search !== undefined) ? options.search : undefined;
            let orderby = (options && options.orderby !== undefined) ? options.orderby : undefined;
            let select = (options && options.select !== undefined) ? options.select : undefined;
            let skip = (options && options.skip !== undefined) ? options.skip : undefined;
            let top = (options && options.top !== undefined) ? options.top : undefined;
            let format = (options && options.format !== undefined) ? options.format : undefined;
            let count = (options && options.count !== undefined) ? options.count : undefined;
            let apply = (options && options.apply !== undefined) ? options.apply : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    eventType,
                    timespan,
                    filter,
                    search,
                    orderby,
                    select,
                    skip,
                    top,
                    format,
                    count,
                    apply,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/events/{eventType}",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "eventType",
                            mapper: {
                                required: true,
                                serializedName: "eventType",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "timespan",
                            mapper: {
                                serializedName: "timespan",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "search",
                            mapper: {
                                serializedName: "$search",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "orderby",
                            mapper: {
                                serializedName: "$orderby",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "skip",
                            mapper: {
                                serializedName: "$skip",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "top",
                            mapper: {
                                serializedName: "$top",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "format",
                            mapper: {
                                serializedName: "$format",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "count",
                            mapper: {
                                serializedName: "$count",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterPath: "apply",
                            mapper: {
                                serializedName: "$apply",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.EventsResults
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.EventsResults;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Get an event
     *
     * Gets the data for a single event
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {EventType} eventType The type of events to query; either a standard event type
     * (`traces`, `customEvents`, `pageViews`, `requests`, `dependencies`, `exceptions`,
     * `availabilityResults`) or `$all` to query across all event types. Possible values include:
     * '$all', 'traces', 'customEvents', 'pageViews', 'browserTimings', 'requests', 'dependencies',
     * 'exceptions', 'availabilityResults', 'performanceCounters', 'customMetrics'
     *
     * @param {string} eventId ID of event.
     *
     * @param {EventsGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getWithHttpOperationResponse(appId, eventType, eventId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let timespan = (options && options.timespan !== undefined) ? options.timespan : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    eventType,
                    timespan,
                    eventId,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/events/{eventType}/{eventId}",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "eventType",
                            mapper: {
                                required: true,
                                serializedName: "eventType",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "eventId",
                            mapper: {
                                required: true,
                                serializedName: "eventId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "timespan",
                            mapper: {
                                serializedName: "timespan",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.EventsResults
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.EventsResults;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Get OData metadata
     *
     * Gets OData EDMX metadata describing the event data model
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getOdataMetadataWithHttpOperationResponse(appId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/events/$metadata",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            }
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            };
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    getByType(appId, eventType, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getByTypeWithHttpOperationResponse(appId, eventType, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getByTypeWithHttpOperationResponse(appId, eventType, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    get(appId, eventType, eventId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(appId, eventType, eventId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(appId, eventType, eventId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getOdataMetadata(appId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getOdataMetadataWithHttpOperationResponse(appId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getOdataMetadataWithHttpOperationResponse(appId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Events = Events;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var mappers_1 = __webpack_require__(0);
exports.discriminators = mappers_1.discriminators;
exports.EventsResults = mappers_1.EventsResults;
exports.ErrorInfo = mappers_1.ErrorInfo;
exports.ErrorDetail = mappers_1.ErrorDetail;
exports.EventsResultData = mappers_1.EventsResultData;
exports.EventsResultDataCustomDimensions = mappers_1.EventsResultDataCustomDimensions;
exports.EventsResultDataCustomMeasurements = mappers_1.EventsResultDataCustomMeasurements;
exports.EventsOperationInfo = mappers_1.EventsOperationInfo;
exports.EventsSessionInfo = mappers_1.EventsSessionInfo;
exports.EventsUserInfo = mappers_1.EventsUserInfo;
exports.EventsCloudInfo = mappers_1.EventsCloudInfo;
exports.EventsAiInfo = mappers_1.EventsAiInfo;
exports.EventsApplicationInfo = mappers_1.EventsApplicationInfo;
exports.EventsClientInfo = mappers_1.EventsClientInfo;
exports.ErrorResponse = mappers_1.ErrorResponse;
exports.EventsTraceResult = mappers_1.EventsTraceResult;
exports.EventsTraceInfo = mappers_1.EventsTraceInfo;
exports.EventsCustomEventResult = mappers_1.EventsCustomEventResult;
exports.EventsCustomEventInfo = mappers_1.EventsCustomEventInfo;
exports.EventsPageViewResult = mappers_1.EventsPageViewResult;
exports.EventsPageViewInfo = mappers_1.EventsPageViewInfo;
exports.EventsBrowserTimingResult = mappers_1.EventsBrowserTimingResult;
exports.EventsBrowserTimingInfo = mappers_1.EventsBrowserTimingInfo;
exports.EventsClientPerformanceInfo = mappers_1.EventsClientPerformanceInfo;
exports.EventsRequestResult = mappers_1.EventsRequestResult;
exports.EventsRequestInfo = mappers_1.EventsRequestInfo;
exports.EventsDependencyResult = mappers_1.EventsDependencyResult;
exports.EventsDependencyInfo = mappers_1.EventsDependencyInfo;
exports.EventsExceptionResult = mappers_1.EventsExceptionResult;
exports.EventsExceptionInfo = mappers_1.EventsExceptionInfo;
exports.EventsExceptionDetail = mappers_1.EventsExceptionDetail;
exports.EventsExceptionDetailsParsedStack = mappers_1.EventsExceptionDetailsParsedStack;
exports.EventsAvailabilityResultResult = mappers_1.EventsAvailabilityResultResult;
exports.EventsAvailabilityResultInfo = mappers_1.EventsAvailabilityResultInfo;
exports.EventsPerformanceCounterResult = mappers_1.EventsPerformanceCounterResult;
exports.EventsPerformanceCounterInfo = mappers_1.EventsPerformanceCounterInfo;
exports.EventsCustomMetricResult = mappers_1.EventsCustomMetricResult;
exports.EventsCustomMetricInfo = mappers_1.EventsCustomMetricInfo;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(13);
const WebResource = msRest.WebResource;
/** Class representing a Query. */
class Query {
    /**
     * Create a Query.
     * @param {ApplicationInsightsDataClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.serializer = new msRest.Serializer(Mappers);
        this.client = client;
    }
    /**
     * @summary Execute an Analytics query
     *
     * Executes an Analytics query for data.
     * [Here](https://dev.applicationinsights.io/documentation/Using-the-API/Query) is an example for
     * using POST with an Analytics query.
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {QueryBody} body The Analytics query. Learn more about the [Analytics query
     * syntax](https://azure.microsoft.com/documentation/articles/app-insights-analytics-reference/)
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    executeWithHttpOperationResponse(appId, body, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    body,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/query",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "body",
                        mapper: Object.assign({}, Mappers.QueryBody, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.QueryResults
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.QueryResults;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    execute(appId, body, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.executeWithHttpOperationResponse(appId, body, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.executeWithHttpOperationResponse(appId, body, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Query = Query;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var mappers_1 = __webpack_require__(0);
exports.discriminators = mappers_1.discriminators;
exports.QueryBody = mappers_1.QueryBody;
exports.QueryResults = mappers_1.QueryResults;
exports.Table = mappers_1.Table;
exports.Column = mappers_1.Column;
exports.ErrorResponse = mappers_1.ErrorResponse;
exports.ErrorInfo = mappers_1.ErrorInfo;
exports.ErrorDetail = mappers_1.ErrorDetail;


/***/ })
/******/ ]);
//# sourceMappingURL=applicationInsightsDataClientBundle.js.map