"use strict";
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const msRest = require("ms-rest-js");
const Mappers = require("../models/metricsMappers");
const WebResource = msRest.WebResource;
/** Class representing a Metrics. */
class Metrics {
    /**
     * Create a Metrics.
     * @param {ApplicationInsightsDataClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.serializer = new msRest.Serializer(Mappers);
        this.client = client;
    }
    /**
     * @summary Retrieve metric data
     *
     * Gets metric values for a single metric
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {MetricId} metricId ID of the metric. This is either a standard AI metric, or an
     * application-specific custom metric. Possible values include: 'requests/count',
     * 'requests/duration', 'requests/failed', 'users/count', 'users/authenticated', 'pageViews/count',
     * 'pageViews/duration', 'client/processingDuration', 'client/receiveDuration',
     * 'client/networkDuration', 'client/sendDuration', 'client/totalDuration', 'dependencies/count',
     * 'dependencies/failed', 'dependencies/duration', 'exceptions/count', 'exceptions/browser',
     * 'exceptions/server', 'sessions/count', 'performanceCounters/requestExecutionTime',
     * 'performanceCounters/requestsPerSecond', 'performanceCounters/requestsInQueue',
     * 'performanceCounters/memoryAvailableBytes', 'performanceCounters/exceptionsPerSecond',
     * 'performanceCounters/processCpuPercentage', 'performanceCounters/processIOBytesPerSecond',
     * 'performanceCounters/processPrivateBytes', 'performanceCounters/processorCpuPercentage',
     * 'availabilityResults/availabilityPercentage', 'availabilityResults/duration',
     * 'billing/telemetryCount', 'customEvents/count'
     *
     * @param {MetricsGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getWithHttpOperationResponse(appId, metricId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let timespan = (options && options.timespan !== undefined) ? options.timespan : undefined;
            let interval = (options && options.interval !== undefined) ? options.interval : undefined;
            let aggregation = (options && options.aggregation !== undefined) ? options.aggregation : undefined;
            let segment = (options && options.segment !== undefined) ? options.segment : undefined;
            let top = (options && options.top !== undefined) ? options.top : undefined;
            let orderby = (options && options.orderby !== undefined) ? options.orderby : undefined;
            let filter = (options && options.filter !== undefined) ? options.filter : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    metricId,
                    timespan,
                    interval,
                    aggregation,
                    segment,
                    top,
                    orderby,
                    filter,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/metrics/{metricId}",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "metricId",
                            mapper: {
                                required: true,
                                serializedName: "metricId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "timespan",
                            mapper: {
                                serializedName: "timespan",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "interval",
                            mapper: {
                                serializedName: "interval",
                                type: {
                                    name: "TimeSpan"
                                }
                            }
                        },
                        {
                            parameterPath: "aggregation",
                            collectionFormat: msRest.QueryCollectionFormat.Csv,
                            mapper: {
                                serializedName: "aggregation",
                                constraints: {
                                    MinItems: 1
                                },
                                type: {
                                    name: "Sequence",
                                    element: {
                                        serializedName: "MetricsAggregationElementType",
                                        type: {
                                            name: "Enum",
                                            allowedValues: [
                                                "min",
                                                "max",
                                                "avg",
                                                "sum",
                                                "count",
                                                "unique"
                                            ]
                                        }
                                    }
                                }
                            }
                        },
                        {
                            parameterPath: "segment",
                            collectionFormat: msRest.QueryCollectionFormat.Csv,
                            mapper: {
                                serializedName: "segment",
                                constraints: {
                                    MinItems: 1
                                },
                                type: {
                                    name: "Sequence",
                                    element: {
                                        serializedName: "MetricsSegmentElementType",
                                        type: {
                                            name: "String"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            parameterPath: "top",
                            mapper: {
                                serializedName: "top",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "orderby",
                            mapper: {
                                serializedName: "orderby",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "filter",
                            mapper: {
                                serializedName: "filter",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.MetricsResult
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.MetricsResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Retrieve metric data
     *
     * Gets metric values for multiple metrics
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {MetricsPostBodySchema[]} body The batched metrics query.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getMultipleWithHttpOperationResponse(appId, body, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    body,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/metrics",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "body",
                        mapper: {
                            required: true,
                            serializedName: "body",
                            type: {
                                name: "Sequence",
                                element: {
                                    serializedName: "MetricsPostBodySchemaElementType",
                                    type: {
                                        name: "Composite",
                                        className: "MetricsPostBodySchema"
                                    }
                                }
                            }
                        }
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Sequence",
                                    element: {
                                        serializedName: "MetricsResultsItemElementType",
                                        type: {
                                            name: "Composite",
                                            className: "MetricsResultsItem"
                                        }
                                    }
                                }
                            }
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Sequence",
                                    element: {
                                        serializedName: "MetricsResultsItemElementType",
                                        type: {
                                            name: "Composite",
                                            className: "MetricsResultsItem"
                                        }
                                    }
                                }
                            };
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Retrieve metric metatadata
     *
     * Gets metadata describing the available metrics
     *
     * @param {string} appId ID of the application. This is Application ID from the API Access settings
     * blade in the Azure portal.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getMetadataWithHttpOperationResponse(appId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    appId,
                    "this.client.acceptLanguage": this.client.acceptLanguage
                }, options);
                operationRes = yield this.client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "v1/apps/{appId}/metrics/metadata",
                    urlParameters: [
                        {
                            parameterPath: "appId",
                            mapper: {
                                required: true,
                                serializedName: "appId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterPath: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            }
                        },
                        default: {
                            bodyMapper: Mappers.ErrorResponse
                        }
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            };
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    get(appId, metricId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(appId, metricId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(appId, metricId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getMultiple(appId, body, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getMultipleWithHttpOperationResponse(appId, body, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getMultipleWithHttpOperationResponse(appId, body, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getMetadata(appId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getMetadataWithHttpOperationResponse(appId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getMetadataWithHttpOperationResponse(appId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Metrics = Metrics;
//# sourceMappingURL=metrics.js.map