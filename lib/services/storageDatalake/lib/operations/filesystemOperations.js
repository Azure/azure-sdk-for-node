/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;

/**
 * @summary List Filesystems
 *
 * List filesystems and their properties in given account.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.prefix] Filters results to filesystems within the
 * specified prefix.
 *
 * @param {string} [options.continuation] The number of filesystems returned
 * with each invocation is limited. If the number of filesystems to be returned
 * exceeds this limit, a continuation token is returned in the response header
 * x-ms-continuation. When a continuation token is  returned in the response,
 * it must be specified in a subsequent invocation of the list operation to
 * continue listing the filesystems.
 *
 * @param {number} [options.maxResults] An optional value that specifies the
 * maximum number of items to return. If omitted or greater than 5,000, the
 * response will include up to 5,000 items.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link FilesystemList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _list(options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let prefix = (options && options.prefix !== undefined) ? options.prefix : undefined;
  let continuation = (options && options.continuation !== undefined) ? options.continuation : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  let resource = 'account';
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (prefix !== null && prefix !== undefined && typeof prefix.valueOf() !== 'string') {
      throw new Error('prefix must be of type string.');
    }
    if (continuation !== null && continuation !== undefined && typeof continuation.valueOf() !== 'string') {
      throw new Error('continuation must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 1)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  let queryParameters = [];
  queryParameters.push('resource=' + encodeURIComponent(resource));
  if (prefix !== null && prefix !== undefined) {
    queryParameters.push('prefix=' + encodeURIComponent(prefix));
  }
  if (continuation !== null && continuation !== undefined) {
    queryParameters.push('continuation=' + encodeURIComponent(continuation));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['FilesystemList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create Filesystem
 *
 * Create a filesystem rooted at the specified location. If the filesystem
 * already exists, the operation fails.  This operation does not support
 * conditional HTTP requests.
 *
 * @param {string} filesystem The filesystem identifier.  The value must start
 * and end with a letter or number and must contain only letters, numbers, and
 * the dash (-) character.  Consecutive dashes are not permitted.  All letters
 * must be lowercase.  The value must have between 3 and 63 characters.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.xMsProperties] User-defined properties to be stored
 * with the filesystem, in the format of a comma-separated list of name and
 * value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _create(filesystem, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let xMsProperties = (options && options.xMsProperties !== undefined) ? options.xMsProperties : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  let resource = 'filesystem';
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (xMsProperties !== null && xMsProperties !== undefined && typeof xMsProperties.valueOf() !== 'string') {
      throw new Error('xMsProperties must be of type string.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  let queryParameters = [];
  queryParameters.push('resource=' + encodeURIComponent(resource));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (xMsProperties !== undefined && xMsProperties !== null) {
    httpRequest.headers['x-ms-properties'] = xMsProperties;
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Set Filesystem Properties
 *
 * Set properties for the filesystem.  This operation supports conditional HTTP
 * requests.  For more information, see [Specifying Conditional Headers for
 * Blob Service
 * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
 *
 * @param {string} filesystem The filesystem identifier.  The value must start
 * and end with a letter or number and must contain only letters, numbers, and
 * the dash (-) character.  Consecutive dashes are not permitted.  All letters
 * must be lowercase.  The value must have between 3 and 63 characters.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.xMsProperties] Optional. User-defined properties to
 * be stored with the filesystem, in the format of a comma-separated list of
 * name and value pairs "n1=v1, n2=v2, ...", where each value is base64
 * encoded.  If the filesystem exists, any properties not included in the list
 * will be removed.  All properties are removed if the header is omitted.  To
 * merge new and existing properties, first get all existing properties and the
 * current E-Tag, then make a conditional request with the E-Tag and include
 * values for all properties.
 *
 * @param {string} [options.ifModifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has been
 * modified since the specified date and time.
 *
 * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has not
 * been modified since the specified date and time.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _setProperties(filesystem, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let xMsProperties = (options && options.xMsProperties !== undefined) ? options.xMsProperties : undefined;
  let ifModifiedSince = (options && options.ifModifiedSince !== undefined) ? options.ifModifiedSince : undefined;
  let ifUnmodifiedSince = (options && options.ifUnmodifiedSince !== undefined) ? options.ifUnmodifiedSince : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  let resource = 'filesystem';
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (xMsProperties !== null && xMsProperties !== undefined && typeof xMsProperties.valueOf() !== 'string') {
      throw new Error('xMsProperties must be of type string.');
    }
    if (ifModifiedSince !== null && ifModifiedSince !== undefined && typeof ifModifiedSince.valueOf() !== 'string') {
      throw new Error('ifModifiedSince must be of type string.');
    }
    if (ifUnmodifiedSince !== null && ifUnmodifiedSince !== undefined && typeof ifUnmodifiedSince.valueOf() !== 'string') {
      throw new Error('ifUnmodifiedSince must be of type string.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  let queryParameters = [];
  queryParameters.push('resource=' + encodeURIComponent(resource));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (xMsProperties !== undefined && xMsProperties !== null) {
    httpRequest.headers['x-ms-properties'] = xMsProperties;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince;
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince;
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get Filesystem Properties.
 *
 * All system and user-defined filesystem properties are specified in the
 * response headers.
 *
 * @param {string} filesystem The filesystem identifier.  The value must start
 * and end with a letter or number and must contain only letters, numbers, and
 * the dash (-) character.  Consecutive dashes are not permitted.  All letters
 * must be lowercase.  The value must have between 3 and 63 characters.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getProperties(filesystem, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  let resource = 'filesystem';
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  let queryParameters = [];
  queryParameters.push('resource=' + encodeURIComponent(resource));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'HEAD';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete Filesystem
 *
 * Marks the filesystem for deletion.  When a filesystem is deleted, a
 * filesystem with the same identifier cannot be created for at least 30
 * seconds. While the filesystem is being deleted, attempts to create a
 * filesystem with the same identifier will fail with status code 409
 * (Conflict), with the service returning additional error information
 * indicating that the filesystem is being deleted. All other operations,
 * including operations on any files or directories within the filesystem, will
 * fail with status code 404 (Not Found) while the filesystem is being deleted.
 * This operation supports conditional HTTP requests.  For more information,
 * see [Specifying Conditional Headers for Blob Service
 * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
 *
 * @param {string} filesystem The filesystem identifier.  The value must start
 * and end with a letter or number and must contain only letters, numbers, and
 * the dash (-) character.  Consecutive dashes are not permitted.  All letters
 * must be lowercase.  The value must have between 3 and 63 characters.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.ifModifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has been
 * modified since the specified date and time.
 *
 * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has not
 * been modified since the specified date and time.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMethod(filesystem, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let ifModifiedSince = (options && options.ifModifiedSince !== undefined) ? options.ifModifiedSince : undefined;
  let ifUnmodifiedSince = (options && options.ifUnmodifiedSince !== undefined) ? options.ifUnmodifiedSince : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  let resource = 'filesystem';
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (ifModifiedSince !== null && ifModifiedSince !== undefined && typeof ifModifiedSince.valueOf() !== 'string') {
      throw new Error('ifModifiedSince must be of type string.');
    }
    if (ifUnmodifiedSince !== null && ifUnmodifiedSince !== undefined && typeof ifUnmodifiedSince.valueOf() !== 'string') {
      throw new Error('ifUnmodifiedSince must be of type string.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  let queryParameters = [];
  queryParameters.push('resource=' + encodeURIComponent(resource));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince;
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince;
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a FilesystemOperations. */
class FilesystemOperations {
  /**
   * Create a FilesystemOperations.
   * @param {DataLakeStorageClient} client Reference to the service client.
   */
  constructor(client) {
    this.client = client;
    this._list = _list;
    this._create = _create;
    this._setProperties = _setProperties;
    this._getProperties = _getProperties;
    this._deleteMethod = _deleteMethod;
  }

  /**
   * @summary List Filesystems
   *
   * List filesystems and their properties in given account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.prefix] Filters results to filesystems within the
   * specified prefix.
   *
   * @param {string} [options.continuation] The number of filesystems returned
   * with each invocation is limited. If the number of filesystems to be returned
   * exceeds this limit, a continuation token is returned in the response header
   * x-ms-continuation. When a continuation token is  returned in the response,
   * it must be specified in a subsequent invocation of the list operation to
   * continue listing the filesystems.
   *
   * @param {number} [options.maxResults] An optional value that specifies the
   * maximum number of items to return. If omitted or greater than 5,000, the
   * response will include up to 5,000 items.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<FilesystemList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listWithHttpOperationResponse(options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._list(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List Filesystems
   *
   * List filesystems and their properties in given account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.prefix] Filters results to filesystems within the
   * specified prefix.
   *
   * @param {string} [options.continuation] The number of filesystems returned
   * with each invocation is limited. If the number of filesystems to be returned
   * exceeds this limit, a continuation token is returned in the response header
   * x-ms-continuation. When a continuation token is  returned in the response,
   * it must be specified in a subsequent invocation of the list operation to
   * continue listing the filesystems.
   *
   * @param {number} [options.maxResults] An optional value that specifies the
   * maximum number of items to return. If omitted or greater than 5,000, the
   * response will include up to 5,000 items.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {FilesystemList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link FilesystemList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  list(options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._list(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._list(options, optionalCallback);
    }
  }

  /**
   * @summary Create Filesystem
   *
   * Create a filesystem rooted at the specified location. If the filesystem
   * already exists, the operation fails.  This operation does not support
   * conditional HTTP requests.
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.xMsProperties] User-defined properties to be stored
   * with the filesystem, in the format of a comma-separated list of name and
   * value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createWithHttpOperationResponse(filesystem, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._create(filesystem, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create Filesystem
   *
   * Create a filesystem rooted at the specified location. If the filesystem
   * already exists, the operation fails.  This operation does not support
   * conditional HTTP requests.
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.xMsProperties] User-defined properties to be stored
   * with the filesystem, in the format of a comma-separated list of name and
   * value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  create(filesystem, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._create(filesystem, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._create(filesystem, options, optionalCallback);
    }
  }

  /**
   * @summary Set Filesystem Properties
   *
   * Set properties for the filesystem.  This operation supports conditional HTTP
   * requests.  For more information, see [Specifying Conditional Headers for
   * Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.xMsProperties] Optional. User-defined properties to
   * be stored with the filesystem, in the format of a comma-separated list of
   * name and value pairs "n1=v1, n2=v2, ...", where each value is base64
   * encoded.  If the filesystem exists, any properties not included in the list
   * will be removed.  All properties are removed if the header is omitted.  To
   * merge new and existing properties, first get all existing properties and the
   * current E-Tag, then make a conditional request with the E-Tag and include
   * values for all properties.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  setPropertiesWithHttpOperationResponse(filesystem, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._setProperties(filesystem, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Set Filesystem Properties
   *
   * Set properties for the filesystem.  This operation supports conditional HTTP
   * requests.  For more information, see [Specifying Conditional Headers for
   * Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.xMsProperties] Optional. User-defined properties to
   * be stored with the filesystem, in the format of a comma-separated list of
   * name and value pairs "n1=v1, n2=v2, ...", where each value is base64
   * encoded.  If the filesystem exists, any properties not included in the list
   * will be removed.  All properties are removed if the header is omitted.  To
   * merge new and existing properties, first get all existing properties and the
   * current E-Tag, then make a conditional request with the E-Tag and include
   * values for all properties.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  setProperties(filesystem, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._setProperties(filesystem, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._setProperties(filesystem, options, optionalCallback);
    }
  }

  /**
   * @summary Get Filesystem Properties.
   *
   * All system and user-defined filesystem properties are specified in the
   * response headers.
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPropertiesWithHttpOperationResponse(filesystem, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getProperties(filesystem, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get Filesystem Properties.
   *
   * All system and user-defined filesystem properties are specified in the
   * response headers.
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getProperties(filesystem, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getProperties(filesystem, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getProperties(filesystem, options, optionalCallback);
    }
  }

  /**
   * @summary Delete Filesystem
   *
   * Marks the filesystem for deletion.  When a filesystem is deleted, a
   * filesystem with the same identifier cannot be created for at least 30
   * seconds. While the filesystem is being deleted, attempts to create a
   * filesystem with the same identifier will fail with status code 409
   * (Conflict), with the service returning additional error information
   * indicating that the filesystem is being deleted. All other operations,
   * including operations on any files or directories within the filesystem, will
   * fail with status code 404 (Not Found) while the filesystem is being deleted.
   * This operation supports conditional HTTP requests.  For more information,
   * see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMethodWithHttpOperationResponse(filesystem, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMethod(filesystem, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete Filesystem
   *
   * Marks the filesystem for deletion.  When a filesystem is deleted, a
   * filesystem with the same identifier cannot be created for at least 30
   * seconds. While the filesystem is being deleted, attempts to create a
   * filesystem with the same identifier will fail with status code 409
   * (Conflict), with the service returning additional error information
   * indicating that the filesystem is being deleted. All other operations,
   * including operations on any files or directories within the filesystem, will
   * fail with status code 404 (Not Found) while the filesystem is being deleted.
   * This operation supports conditional HTTP requests.  For more information,
   * see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(filesystem, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMethod(filesystem, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMethod(filesystem, options, optionalCallback);
    }
  }

}

module.exports = FilesystemOperations;
