/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;

/**
 * @summary List Paths
 *
 * List filesystem paths and their properties.
 *
 * @param {boolean} recursive If "true", all paths are listed; otherwise, only
 * paths at the root of the filesystem are listed.  If "directory" is
 * specified, the list will only include paths that share the same root.
 *
 * @param {string} filesystem The filesystem identifier.  The value must start
 * and end with a letter or number and must contain only letters, numbers, and
 * the dash (-) character.  Consecutive dashes are not permitted.  All letters
 * must be lowercase.  The value must have between 3 and 63 characters.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.directory] Filters results to paths within the
 * specified directory. An error occurs if the directory does not exist.
 *
 * @param {string} [options.continuation] The number of paths returned with
 * each invocation is limited. If the number of paths to be returned exceeds
 * this limit, a continuation token is returned in the response header
 * x-ms-continuation. When a continuation token is  returned in the response,
 * it must be specified in a subsequent invocation of the list operation to
 * continue listing the paths.
 *
 * @param {number} [options.maxResults] An optional value that specifies the
 * maximum number of items to return. If omitted or greater than 5,000, the
 * response will include up to 5,000 items.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PathList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _list(recursive, filesystem, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let directory = (options && options.directory !== undefined) ? options.directory : undefined;
  let continuation = (options && options.continuation !== undefined) ? options.continuation : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  let resource = 'filesystem';
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (directory !== null && directory !== undefined && typeof directory.valueOf() !== 'string') {
      throw new Error('directory must be of type string.');
    }
    if (recursive === null || recursive === undefined || typeof recursive !== 'boolean') {
      throw new Error('recursive cannot be null or undefined and it must be of type boolean.');
    }
    if (continuation !== null && continuation !== undefined && typeof continuation.valueOf() !== 'string') {
      throw new Error('continuation must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 1)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  let queryParameters = [];
  if (directory !== null && directory !== undefined) {
    queryParameters.push('directory=' + encodeURIComponent(directory));
  }
  queryParameters.push('recursive=' + encodeURIComponent(recursive.toString()));
  if (continuation !== null && continuation !== undefined) {
    queryParameters.push('continuation=' + encodeURIComponent(continuation));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxResults=' + encodeURIComponent(maxResults.toString()));
  }
  queryParameters.push('resource=' + encodeURIComponent(resource));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PathList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create File | Create Directory | Rename File | Rename Directory
 *
 * Create or rename a file or directory.    By default, the destination is
 * overwritten and if the destination already exists and has a lease the lease
 * is broken.  This operation supports conditional HTTP requests.  For more
 * information, see [Specifying Conditional Headers for Blob Service
 * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
 * To fail if the destination already exists, use a conditional request with
 * If-None-Match: "*".
 *
 * @param {string} filesystem The filesystem identifier.
 *
 * @param {string} path The file or directory path.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.resource] Required only for Create File and Create
 * Directory. The value must be "file" or "directory". Possible values include:
 * 'directory', 'file'
 *
 * @param {string} [options.continuation] Optional.  When renaming a directory,
 * the number of paths that are renamed with each invocation is limited.  If
 * the number of paths to be renamed exceeds this limit, a continuation token
 * is returned in this response header.  When a continuation token is returned
 * in the response, it must be specified in a subsequent invocation of the
 * rename operation to continue renaming the directory.
 *
 * @param {string} [options.mode] Optional. Valid only when namespace is
 * enabled. This parameter determines the behavior of the rename operation. The
 * value must be "legacy" or "posix", and the default value will be "posix".
 * Possible values include: 'legacy', 'posix'
 *
 * @param {string} [options.cacheControl] Optional.  The service stores this
 * value and includes it in the "Cache-Control" response header for "Read File"
 * operations for "Read File" operations.
 *
 * @param {string} [options.contentEncoding] Optional.  Specifies which content
 * encodings have been applied to the file. This value is returned to the
 * client when the "Read File" operation is performed.
 *
 * @param {string} [options.contentLanguage] Optional.  Specifies the natural
 * language used by the intended audience for the file.
 *
 * @param {string} [options.contentDisposition] Optional.  The service stores
 * this value and includes it in the "Content-Disposition" response header for
 * "Read File" operations.
 *
 * @param {string} [options.xMsCacheControl] Optional.  The service stores this
 * value and includes it in the "Cache-Control" response header for "Read File"
 * operations.
 *
 * @param {string} [options.xMsContentType] Optional.  The service stores this
 * value and includes it in the "Content-Type" response header for "Read File"
 * operations.
 *
 * @param {string} [options.xMsContentEncoding] Optional.  The service stores
 * this value and includes it in the "Content-Encoding" response header for
 * "Read File" operations.
 *
 * @param {string} [options.xMsContentLanguage] Optional.  The service stores
 * this value and includes it in the "Content-Language" response header for
 * "Read File" operations.
 *
 * @param {string} [options.xMsContentDisposition] Optional.  The service
 * stores this value and includes it in the "Content-Disposition" response
 * header for "Read File" operations.
 *
 * @param {string} [options.xMsRenameSource] An optional file or directory to
 * be renamed.  The value must have the following format:
 * "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties
 * will overwrite the existing properties; otherwise, the existing properties
 * will be preserved.
 *
 * @param {string} [options.xMsLeaseId] Optional.  A lease ID for the path
 * specified in the URI.  The path to be overwritten must have an active lease
 * and the lease ID must match.
 *
 * @param {string} [options.xMsProposedLeaseId] Optional for create operations.
 * Required when "x-ms-lease-action" is used.  A lease will be acquired using
 * the proposed ID when the resource is created.
 *
 * @param {string} [options.xMsSourceLeaseId] Optional for rename operations.
 * A lease ID for the source path.  The source path must have an active lease
 * and the lease ID must match.
 *
 * @param {string} [options.xMsProperties] Optional.  User-defined properties
 * to be stored with the file or directory, in the format of a comma-separated
 * list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64
 * encoded.
 *
 * @param {string} [options.xMsPermissions] Optional and only valid if
 * Hierarchical Namespace is enabled for the account. Sets POSIX access
 * permissions for the file owner, the file owning group, and others. Each
 * class may be granted read, write, or execute permission.  The sticky bit is
 * also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g.
 * 0766) are supported.
 *
 * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
 * header to perform the operation only if the resource's ETag matches the
 * value specified. The ETag must be specified in quotes.
 *
 * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
 * special wildcard ("*") value. Specify this header to perform the operation
 * only if the resource's ETag does not match the value specified. The ETag
 * must be specified in quotes.
 *
 * @param {string} [options.ifModifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has been
 * modified since the specified date and time.
 *
 * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has not
 * been modified since the specified date and time.
 *
 * @param {string} [options.xMsSourceIfMatch] Optional.  An ETag value. Specify
 * this header to perform the rename operation only if the source's ETag
 * matches the value specified. The ETag must be specified in quotes.
 *
 * @param {string} [options.xMsSourceIfNoneMatch] Optional.  An ETag value or
 * the special wildcard ("*") value. Specify this header to perform the rename
 * operation only if the source's ETag does not match the value specified. The
 * ETag must be specified in quotes.
 *
 * @param {string} [options.xMsSourceIfModifiedSince] Optional. A date and time
 * value. Specify this header to perform the rename operation only if the
 * source has been modified since the specified date and time.
 *
 * @param {string} [options.xMsSourceIfUnmodifiedSince] Optional. A date and
 * time value. Specify this header to perform the rename operation only if the
 * source has not been modified since the specified date and time.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _create(filesystem, path, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let resource = (options && options.resource !== undefined) ? options.resource : undefined;
  let continuation = (options && options.continuation !== undefined) ? options.continuation : undefined;
  let mode = (options && options.mode !== undefined) ? options.mode : undefined;
  let cacheControl = (options && options.cacheControl !== undefined) ? options.cacheControl : undefined;
  let contentEncoding = (options && options.contentEncoding !== undefined) ? options.contentEncoding : undefined;
  let contentLanguage = (options && options.contentLanguage !== undefined) ? options.contentLanguage : undefined;
  let contentDisposition = (options && options.contentDisposition !== undefined) ? options.contentDisposition : undefined;
  let xMsCacheControl = (options && options.xMsCacheControl !== undefined) ? options.xMsCacheControl : undefined;
  let xMsContentType = (options && options.xMsContentType !== undefined) ? options.xMsContentType : undefined;
  let xMsContentEncoding = (options && options.xMsContentEncoding !== undefined) ? options.xMsContentEncoding : undefined;
  let xMsContentLanguage = (options && options.xMsContentLanguage !== undefined) ? options.xMsContentLanguage : undefined;
  let xMsContentDisposition = (options && options.xMsContentDisposition !== undefined) ? options.xMsContentDisposition : undefined;
  let xMsRenameSource = (options && options.xMsRenameSource !== undefined) ? options.xMsRenameSource : undefined;
  let xMsLeaseId = (options && options.xMsLeaseId !== undefined) ? options.xMsLeaseId : undefined;
  let xMsProposedLeaseId = (options && options.xMsProposedLeaseId !== undefined) ? options.xMsProposedLeaseId : undefined;
  let xMsSourceLeaseId = (options && options.xMsSourceLeaseId !== undefined) ? options.xMsSourceLeaseId : undefined;
  let xMsProperties = (options && options.xMsProperties !== undefined) ? options.xMsProperties : undefined;
  let xMsPermissions = (options && options.xMsPermissions !== undefined) ? options.xMsPermissions : undefined;
  let ifMatch = (options && options.ifMatch !== undefined) ? options.ifMatch : undefined;
  let ifNoneMatch = (options && options.ifNoneMatch !== undefined) ? options.ifNoneMatch : undefined;
  let ifModifiedSince = (options && options.ifModifiedSince !== undefined) ? options.ifModifiedSince : undefined;
  let ifUnmodifiedSince = (options && options.ifUnmodifiedSince !== undefined) ? options.ifUnmodifiedSince : undefined;
  let xMsSourceIfMatch = (options && options.xMsSourceIfMatch !== undefined) ? options.xMsSourceIfMatch : undefined;
  let xMsSourceIfNoneMatch = (options && options.xMsSourceIfNoneMatch !== undefined) ? options.xMsSourceIfNoneMatch : undefined;
  let xMsSourceIfModifiedSince = (options && options.xMsSourceIfModifiedSince !== undefined) ? options.xMsSourceIfModifiedSince : undefined;
  let xMsSourceIfUnmodifiedSince = (options && options.xMsSourceIfUnmodifiedSince !== undefined) ? options.xMsSourceIfUnmodifiedSince : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (resource) {
      let allowedValues = [ 'directory', 'file' ];
      if (!allowedValues.some( function(item) { return item === resource; })) {
        throw new Error(resource + ' is not a valid value. The valid values are: ' + allowedValues);
      }
    }
    if (continuation !== null && continuation !== undefined && typeof continuation.valueOf() !== 'string') {
      throw new Error('continuation must be of type string.');
    }
    if (mode) {
      let allowedValues1 = [ 'legacy', 'posix' ];
      if (!allowedValues1.some( function(item) { return item === mode; })) {
        throw new Error(mode + ' is not a valid value. The valid values are: ' + allowedValues1);
      }
    }
    if (cacheControl !== null && cacheControl !== undefined && typeof cacheControl.valueOf() !== 'string') {
      throw new Error('cacheControl must be of type string.');
    }
    if (contentEncoding !== null && contentEncoding !== undefined && typeof contentEncoding.valueOf() !== 'string') {
      throw new Error('contentEncoding must be of type string.');
    }
    if (contentLanguage !== null && contentLanguage !== undefined && typeof contentLanguage.valueOf() !== 'string') {
      throw new Error('contentLanguage must be of type string.');
    }
    if (contentDisposition !== null && contentDisposition !== undefined && typeof contentDisposition.valueOf() !== 'string') {
      throw new Error('contentDisposition must be of type string.');
    }
    if (xMsCacheControl !== null && xMsCacheControl !== undefined && typeof xMsCacheControl.valueOf() !== 'string') {
      throw new Error('xMsCacheControl must be of type string.');
    }
    if (xMsContentType !== null && xMsContentType !== undefined && typeof xMsContentType.valueOf() !== 'string') {
      throw new Error('xMsContentType must be of type string.');
    }
    if (xMsContentEncoding !== null && xMsContentEncoding !== undefined && typeof xMsContentEncoding.valueOf() !== 'string') {
      throw new Error('xMsContentEncoding must be of type string.');
    }
    if (xMsContentLanguage !== null && xMsContentLanguage !== undefined && typeof xMsContentLanguage.valueOf() !== 'string') {
      throw new Error('xMsContentLanguage must be of type string.');
    }
    if (xMsContentDisposition !== null && xMsContentDisposition !== undefined && typeof xMsContentDisposition.valueOf() !== 'string') {
      throw new Error('xMsContentDisposition must be of type string.');
    }
    if (xMsRenameSource !== null && xMsRenameSource !== undefined && typeof xMsRenameSource.valueOf() !== 'string') {
      throw new Error('xMsRenameSource must be of type string.');
    }
    if (xMsLeaseId !== null && xMsLeaseId !== undefined && typeof xMsLeaseId.valueOf() !== 'string') {
      throw new Error('xMsLeaseId must be of type string.');
    }
    if (xMsLeaseId !== null && xMsLeaseId !== undefined) {
      if (xMsLeaseId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsLeaseId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (xMsProposedLeaseId !== null && xMsProposedLeaseId !== undefined && typeof xMsProposedLeaseId.valueOf() !== 'string') {
      throw new Error('xMsProposedLeaseId must be of type string.');
    }
    if (xMsProposedLeaseId !== null && xMsProposedLeaseId !== undefined) {
      if (xMsProposedLeaseId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsProposedLeaseId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (xMsSourceLeaseId !== null && xMsSourceLeaseId !== undefined && typeof xMsSourceLeaseId.valueOf() !== 'string') {
      throw new Error('xMsSourceLeaseId must be of type string.');
    }
    if (xMsSourceLeaseId !== null && xMsSourceLeaseId !== undefined) {
      if (xMsSourceLeaseId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsSourceLeaseId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (xMsProperties !== null && xMsProperties !== undefined && typeof xMsProperties.valueOf() !== 'string') {
      throw new Error('xMsProperties must be of type string.');
    }
    if (xMsPermissions !== null && xMsPermissions !== undefined && typeof xMsPermissions.valueOf() !== 'string') {
      throw new Error('xMsPermissions must be of type string.');
    }
    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
      throw new Error('ifMatch must be of type string.');
    }
    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
      throw new Error('ifNoneMatch must be of type string.');
    }
    if (ifModifiedSince !== null && ifModifiedSince !== undefined && typeof ifModifiedSince.valueOf() !== 'string') {
      throw new Error('ifModifiedSince must be of type string.');
    }
    if (ifUnmodifiedSince !== null && ifUnmodifiedSince !== undefined && typeof ifUnmodifiedSince.valueOf() !== 'string') {
      throw new Error('ifUnmodifiedSince must be of type string.');
    }
    if (xMsSourceIfMatch !== null && xMsSourceIfMatch !== undefined && typeof xMsSourceIfMatch.valueOf() !== 'string') {
      throw new Error('xMsSourceIfMatch must be of type string.');
    }
    if (xMsSourceIfNoneMatch !== null && xMsSourceIfNoneMatch !== undefined && typeof xMsSourceIfNoneMatch.valueOf() !== 'string') {
      throw new Error('xMsSourceIfNoneMatch must be of type string.');
    }
    if (xMsSourceIfModifiedSince !== null && xMsSourceIfModifiedSince !== undefined && typeof xMsSourceIfModifiedSince.valueOf() !== 'string') {
      throw new Error('xMsSourceIfModifiedSince must be of type string.');
    }
    if (xMsSourceIfUnmodifiedSince !== null && xMsSourceIfUnmodifiedSince !== undefined && typeof xMsSourceIfUnmodifiedSince.valueOf() !== 'string') {
      throw new Error('xMsSourceIfUnmodifiedSince must be of type string.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (filesystem !== null && filesystem !== undefined) {
      if (filesystem.length > 63)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MaxLength": 63');
      }
      if (filesystem.length < 3)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MinLength": 3');
      }
      if (filesystem.match(/^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/) === null)
      {
        throw new Error('"filesystem" should satisfy the constraint - "Pattern": /^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/');
      }
    }
    if (path === null || path === undefined || typeof path.valueOf() !== 'string') {
      throw new Error('path cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}/{path}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  requestUrl = requestUrl.replace('{path}', encodeURIComponent(path));
  let queryParameters = [];
  if (resource !== null && resource !== undefined) {
    queryParameters.push('resource=' + encodeURIComponent(resource));
  }
  if (continuation !== null && continuation !== undefined) {
    queryParameters.push('continuation=' + encodeURIComponent(continuation));
  }
  if (mode !== null && mode !== undefined) {
    queryParameters.push('mode=' + encodeURIComponent(mode));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (cacheControl !== undefined && cacheControl !== null) {
    httpRequest.headers['Cache-Control'] = cacheControl;
  }
  if (contentEncoding !== undefined && contentEncoding !== null) {
    httpRequest.headers['Content-Encoding'] = contentEncoding;
  }
  if (contentLanguage !== undefined && contentLanguage !== null) {
    httpRequest.headers['Content-Language'] = contentLanguage;
  }
  if (contentDisposition !== undefined && contentDisposition !== null) {
    httpRequest.headers['Content-Disposition'] = contentDisposition;
  }
  if (xMsCacheControl !== undefined && xMsCacheControl !== null) {
    httpRequest.headers['x-ms-cache-control'] = xMsCacheControl;
  }
  if (xMsContentType !== undefined && xMsContentType !== null) {
    httpRequest.headers['x-ms-content-type'] = xMsContentType;
  }
  if (xMsContentEncoding !== undefined && xMsContentEncoding !== null) {
    httpRequest.headers['x-ms-content-encoding'] = xMsContentEncoding;
  }
  if (xMsContentLanguage !== undefined && xMsContentLanguage !== null) {
    httpRequest.headers['x-ms-content-language'] = xMsContentLanguage;
  }
  if (xMsContentDisposition !== undefined && xMsContentDisposition !== null) {
    httpRequest.headers['x-ms-content-disposition'] = xMsContentDisposition;
  }
  if (xMsRenameSource !== undefined && xMsRenameSource !== null) {
    httpRequest.headers['x-ms-rename-source'] = xMsRenameSource;
  }
  if (xMsLeaseId !== undefined && xMsLeaseId !== null) {
    httpRequest.headers['x-ms-lease-id'] = xMsLeaseId;
  }
  if (xMsProposedLeaseId !== undefined && xMsProposedLeaseId !== null) {
    httpRequest.headers['x-ms-proposed-lease-id'] = xMsProposedLeaseId;
  }
  if (xMsSourceLeaseId !== undefined && xMsSourceLeaseId !== null) {
    httpRequest.headers['x-ms-source-lease-id'] = xMsSourceLeaseId;
  }
  if (xMsProperties !== undefined && xMsProperties !== null) {
    httpRequest.headers['x-ms-properties'] = xMsProperties;
  }
  if (xMsPermissions !== undefined && xMsPermissions !== null) {
    httpRequest.headers['x-ms-permissions'] = xMsPermissions;
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince;
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince;
  }
  if (xMsSourceIfMatch !== undefined && xMsSourceIfMatch !== null) {
    httpRequest.headers['x-ms-source-if-match'] = xMsSourceIfMatch;
  }
  if (xMsSourceIfNoneMatch !== undefined && xMsSourceIfNoneMatch !== null) {
    httpRequest.headers['x-ms-source-if-none-match'] = xMsSourceIfNoneMatch;
  }
  if (xMsSourceIfModifiedSince !== undefined && xMsSourceIfModifiedSince !== null) {
    httpRequest.headers['x-ms-source-if-modified-since'] = xMsSourceIfModifiedSince;
  }
  if (xMsSourceIfUnmodifiedSince !== undefined && xMsSourceIfUnmodifiedSince !== null) {
    httpRequest.headers['x-ms-source-if-unmodified-since'] = xMsSourceIfUnmodifiedSince;
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Append Data | Flush Data | Set Properties | Set Access Control
 *
 * Uploads data to be appended to a file, flushes (writes) previously uploaded
 * data to a file, sets properties for a file or directory, or sets access
 * control for a file or directory. Data can only be appended to a file. This
 * operation supports conditional HTTP requests. For more information, see
 * [Specifying Conditional Headers for Blob Service
 * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
 *
 * @param {string} action The action must be "append" to upload data to be
 * appended to a file, "flush" to flush previously uploaded data to a file,
 * "setProperties" to set the properties of a file or directory, or
 * "setAccessControl" to set the owner, group, permissions, or access control
 * list for a file or directory.  Note that Hierarchical Namespace must be
 * enabled for the account in order to use access control.  Also note that the
 * Access Control List (ACL) includes permissions for the owner, owning group,
 * and others, so the x-ms-permissions and x-ms-acl request headers are
 * mutually exclusive. Possible values include: 'append', 'flush',
 * 'setProperties', 'setAccessControl'
 *
 * @param {string} filesystem The filesystem identifier.
 *
 * @param {string} path The file or directory path.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.position] This parameter allows the caller to
 * upload data in parallel and control the order in which it is appended to the
 * file.  It is required when uploading data to be appended to the file and
 * when flushing previously uploaded data to the file.  The value must be the
 * position where the data is to be appended.  Uploaded data is not immediately
 * flushed, or written, to the file.  To flush, the previously uploaded data
 * must be contiguous, the position parameter must be specified and equal to
 * the length of the file after all data has been written, and there must not
 * be a request entity body included with the request.
 *
 * @param {boolean} [options.retainUncommittedData] Valid only for flush
 * operations.  If "true", uncommitted data is retained after the flush
 * operation completes; otherwise, the uncommitted data is deleted after the
 * flush operation.  The default is false.  Data at offsets less than the
 * specified position are written to the file when flush succeeds, but this
 * optional parameter allows data after the flush position to be retained for a
 * future flush operation.
 *
 * @param {string} [options.contentLength] Required for "Append Data" and
 * "Flush Data".  Must be 0 for "Flush Data".  Must be the length of the
 * request content in bytes for "Append Data".
 *
 * @param {string} [options.xMsLeaseAction] Optional.  The lease action can be
 * "renew" to renew an existing lease or "release" to release a lease. Possible
 * values include: 'renew', 'release'
 *
 * @param {string} [options.xMsLeaseId] The lease ID must be specified if there
 * is an active lease.
 *
 * @param {string} [options.xMsCacheControl] Optional and only valid for flush
 * and set properties operations.  The service stores this value and includes
 * it in the "Cache-Control" response header for "Read File" operations.
 *
 * @param {string} [options.xMsContentType] Optional and only valid for flush
 * and set properties operations.  The service stores this value and includes
 * it in the "Content-Type" response header for "Read File" operations.
 *
 * @param {string} [options.xMsContentDisposition] Optional and only valid for
 * flush and set properties operations.  The service stores this value and
 * includes it in the "Content-Disposition" response header for "Read File"
 * operations.
 *
 * @param {string} [options.xMsContentEncoding] Optional and only valid for
 * flush and set properties operations.  The service stores this value and
 * includes it in the "Content-Encoding" response header for "Read File"
 * operations.
 *
 * @param {string} [options.xMsContentLanguage] Optional and only valid for
 * flush and set properties operations.  The service stores this value and
 * includes it in the "Content-Language" response header for "Read File"
 * operations.
 *
 * @param {string} [options.xMsProperties] Optional.  User-defined properties
 * to be stored with the file or directory, in the format of a comma-separated
 * list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64
 * encoded.  Valid only for the setProperties operation.  If the file or
 * directory exists, any properties not included in the list will be removed.
 * All properties are removed if the header is omitted.  To merge new and
 * existing properties, first get all existing properties and the current
 * E-Tag, then make a conditional request with the E-Tag and include values for
 * all properties.
 *
 * @param {string} [options.xMsOwner] Optional and valid only for the
 * setAccessControl operation. Sets the owner of the file or directory.
 *
 * @param {string} [options.xMsGroup] Optional and valid only for the
 * setAccessControl operation. Sets the owning group of the file or directory.
 *
 * @param {string} [options.xMsPermissions] Optional and only valid if
 * Hierarchical Namespace is enabled for the account. Sets POSIX access
 * permissions for the file owner, the file owning group, and others. Each
 * class may be granted read, write, or execute permission.  The sticky bit is
 * also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g.
 * 0766) are supported. Invalid in conjunction with x-ms-acl.
 *
 * @param {string} [options.xMsAcl] Optional and valid only for the
 * setAccessControl operation. Sets POSIX access control rights on files and
 * directories. The value is a comma-separated list of access control entries
 * that fully replaces the existing access control list (ACL).  Each access
 * control entry (ACE) consists of a scope, a type, a user or group identifier,
 * and permissions in the format "[scope:][type]:[id]:[permissions]". The scope
 * must be "default" to indicate the ACE belongs to the default ACL for a
 * directory; otherwise scope is implicit and the ACE belongs to the access
 * ACL.  There are four ACE types: "user" grants rights to the owner or a named
 * user, "group" grants rights to the owning group or a named group, "mask"
 * restricts rights granted to named users and the members of groups, and
 * "other" grants rights to all users not found in any of the other entries.
 * The user or group identifier is omitted for entries of type "mask" and
 * "other".  The user or group identifier is also omitted for the owner and
 * owning group.  The permission field is a 3-character sequence where the
 * first character is 'r' to grant read access, the second character is 'w' to
 * grant write access, and the third character is 'x' to grant execute
 * permission.  If access is not granted, the '-' character is used to denote
 * that the permission is denied. For example, the following ACL grants read,
 * write, and execute rights to the file owner and john.doe@contoso, the read
 * right to the owning group, and nothing to everyone else:
 * "user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx".
 * Invalid in conjunction with x-ms-permissions.
 *
 * @param {string} [options.ifMatch] Optional for Flush Data and Set
 * Properties, but invalid for Append Data.  An ETag value. Specify this header
 * to perform the operation only if the resource's ETag matches the value
 * specified. The ETag must be specified in quotes.
 *
 * @param {string} [options.ifNoneMatch] Optional for Flush Data and Set
 * Properties, but invalid for Append Data.  An ETag value or the special
 * wildcard ("*") value. Specify this header to perform the operation only if
 * the resource's ETag does not match the value specified. The ETag must be
 * specified in quotes.
 *
 * @param {string} [options.ifModifiedSince] Optional for Flush Data and Set
 * Properties, but invalid for Append Data. A date and time value. Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date and time.
 *
 * @param {string} [options.ifUnmodifiedSince] Optional for Flush Data and Set
 * Properties, but invalid for Append Data. A date and time value. Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date and time.
 *
 * @param {object} [options.requestBody] Valid only for append operations.  The
 * data to be uploaded and appended to the file.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _update(action, filesystem, path, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let position = (options && options.position !== undefined) ? options.position : undefined;
  let retainUncommittedData = (options && options.retainUncommittedData !== undefined) ? options.retainUncommittedData : undefined;
  let contentLength = (options && options.contentLength !== undefined) ? options.contentLength : undefined;
  let xMsLeaseAction = (options && options.xMsLeaseAction !== undefined) ? options.xMsLeaseAction : undefined;
  let xMsLeaseId = (options && options.xMsLeaseId !== undefined) ? options.xMsLeaseId : undefined;
  let xMsCacheControl = (options && options.xMsCacheControl !== undefined) ? options.xMsCacheControl : undefined;
  let xMsContentType = (options && options.xMsContentType !== undefined) ? options.xMsContentType : undefined;
  let xMsContentDisposition = (options && options.xMsContentDisposition !== undefined) ? options.xMsContentDisposition : undefined;
  let xMsContentEncoding = (options && options.xMsContentEncoding !== undefined) ? options.xMsContentEncoding : undefined;
  let xMsContentLanguage = (options && options.xMsContentLanguage !== undefined) ? options.xMsContentLanguage : undefined;
  let xMsProperties = (options && options.xMsProperties !== undefined) ? options.xMsProperties : undefined;
  let xMsOwner = (options && options.xMsOwner !== undefined) ? options.xMsOwner : undefined;
  let xMsGroup = (options && options.xMsGroup !== undefined) ? options.xMsGroup : undefined;
  let xMsPermissions = (options && options.xMsPermissions !== undefined) ? options.xMsPermissions : undefined;
  let xMsAcl = (options && options.xMsAcl !== undefined) ? options.xMsAcl : undefined;
  let ifMatch = (options && options.ifMatch !== undefined) ? options.ifMatch : undefined;
  let ifNoneMatch = (options && options.ifNoneMatch !== undefined) ? options.ifNoneMatch : undefined;
  let ifModifiedSince = (options && options.ifModifiedSince !== undefined) ? options.ifModifiedSince : undefined;
  let ifUnmodifiedSince = (options && options.ifUnmodifiedSince !== undefined) ? options.ifUnmodifiedSince : undefined;
  let requestBody = (options && options.requestBody !== undefined) ? options.requestBody : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (action) {
      let allowedValues = [ 'append', 'flush', 'setProperties', 'setAccessControl' ];
      if (!allowedValues.some( function(item) { return item === action; })) {
        throw new Error(action + ' is not a valid value. The valid values are: ' + allowedValues);
      }
    } else {
      throw new Error('action cannot be null or undefined.');
    }
    if (position !== null && position !== undefined && typeof position !== 'number') {
      throw new Error('position must be of type number.');
    }
    if (retainUncommittedData !== null && retainUncommittedData !== undefined && typeof retainUncommittedData !== 'boolean') {
      throw new Error('retainUncommittedData must be of type boolean.');
    }
    if (contentLength !== null && contentLength !== undefined && typeof contentLength.valueOf() !== 'string') {
      throw new Error('contentLength must be of type string.');
    }
    if (xMsLeaseAction) {
      let allowedValues1 = [ 'renew', 'release' ];
      if (!allowedValues1.some( function(item) { return item === xMsLeaseAction; })) {
        throw new Error(xMsLeaseAction + ' is not a valid value. The valid values are: ' + allowedValues1);
      }
    }
    if (xMsLeaseId !== null && xMsLeaseId !== undefined && typeof xMsLeaseId.valueOf() !== 'string') {
      throw new Error('xMsLeaseId must be of type string.');
    }
    if (xMsLeaseId !== null && xMsLeaseId !== undefined) {
      if (xMsLeaseId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsLeaseId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (xMsCacheControl !== null && xMsCacheControl !== undefined && typeof xMsCacheControl.valueOf() !== 'string') {
      throw new Error('xMsCacheControl must be of type string.');
    }
    if (xMsContentType !== null && xMsContentType !== undefined && typeof xMsContentType.valueOf() !== 'string') {
      throw new Error('xMsContentType must be of type string.');
    }
    if (xMsContentDisposition !== null && xMsContentDisposition !== undefined && typeof xMsContentDisposition.valueOf() !== 'string') {
      throw new Error('xMsContentDisposition must be of type string.');
    }
    if (xMsContentEncoding !== null && xMsContentEncoding !== undefined && typeof xMsContentEncoding.valueOf() !== 'string') {
      throw new Error('xMsContentEncoding must be of type string.');
    }
    if (xMsContentLanguage !== null && xMsContentLanguage !== undefined && typeof xMsContentLanguage.valueOf() !== 'string') {
      throw new Error('xMsContentLanguage must be of type string.');
    }
    if (xMsProperties !== null && xMsProperties !== undefined && typeof xMsProperties.valueOf() !== 'string') {
      throw new Error('xMsProperties must be of type string.');
    }
    if (xMsOwner !== null && xMsOwner !== undefined && typeof xMsOwner.valueOf() !== 'string') {
      throw new Error('xMsOwner must be of type string.');
    }
    if (xMsGroup !== null && xMsGroup !== undefined && typeof xMsGroup.valueOf() !== 'string') {
      throw new Error('xMsGroup must be of type string.');
    }
    if (xMsPermissions !== null && xMsPermissions !== undefined && typeof xMsPermissions.valueOf() !== 'string') {
      throw new Error('xMsPermissions must be of type string.');
    }
    if (xMsAcl !== null && xMsAcl !== undefined && typeof xMsAcl.valueOf() !== 'string') {
      throw new Error('xMsAcl must be of type string.');
    }
    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
      throw new Error('ifMatch must be of type string.');
    }
    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
      throw new Error('ifNoneMatch must be of type string.');
    }
    if (ifModifiedSince !== null && ifModifiedSince !== undefined && typeof ifModifiedSince.valueOf() !== 'string') {
      throw new Error('ifModifiedSince must be of type string.');
    }
    if (ifUnmodifiedSince !== null && ifUnmodifiedSince !== undefined && typeof ifUnmodifiedSince.valueOf() !== 'string') {
      throw new Error('ifUnmodifiedSince must be of type string.');
    }
    if (requestBody !== null && requestBody !== undefined && typeof requestBody.valueOf() !== 'object') {
      throw new Error('requestBody must be of type object.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (filesystem !== null && filesystem !== undefined) {
      if (filesystem.length > 63)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MaxLength": 63');
      }
      if (filesystem.length < 3)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MinLength": 3');
      }
      if (filesystem.match(/^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/) === null)
      {
        throw new Error('"filesystem" should satisfy the constraint - "Pattern": /^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/');
      }
    }
    if (path === null || path === undefined || typeof path.valueOf() !== 'string') {
      throw new Error('path cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}/{path}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  requestUrl = requestUrl.replace('{path}', encodeURIComponent(path));
  let queryParameters = [];
  queryParameters.push('action=' + encodeURIComponent(action));
  if (position !== null && position !== undefined) {
    queryParameters.push('position=' + encodeURIComponent(position.toString()));
  }
  if (retainUncommittedData !== null && retainUncommittedData !== undefined) {
    queryParameters.push('retainUncommittedData=' + encodeURIComponent(retainUncommittedData.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/octet-stream';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (contentLength !== undefined && contentLength !== null) {
    httpRequest.headers['Content-Length'] = contentLength;
  }
  if (xMsLeaseAction !== undefined && xMsLeaseAction !== null) {
    httpRequest.headers['x-ms-lease-action'] = xMsLeaseAction;
  }
  if (xMsLeaseId !== undefined && xMsLeaseId !== null) {
    httpRequest.headers['x-ms-lease-id'] = xMsLeaseId;
  }
  if (xMsCacheControl !== undefined && xMsCacheControl !== null) {
    httpRequest.headers['x-ms-cache-control'] = xMsCacheControl;
  }
  if (xMsContentType !== undefined && xMsContentType !== null) {
    httpRequest.headers['x-ms-content-type'] = xMsContentType;
  }
  if (xMsContentDisposition !== undefined && xMsContentDisposition !== null) {
    httpRequest.headers['x-ms-content-disposition'] = xMsContentDisposition;
  }
  if (xMsContentEncoding !== undefined && xMsContentEncoding !== null) {
    httpRequest.headers['x-ms-content-encoding'] = xMsContentEncoding;
  }
  if (xMsContentLanguage !== undefined && xMsContentLanguage !== null) {
    httpRequest.headers['x-ms-content-language'] = xMsContentLanguage;
  }
  if (xMsProperties !== undefined && xMsProperties !== null) {
    httpRequest.headers['x-ms-properties'] = xMsProperties;
  }
  if (xMsOwner !== undefined && xMsOwner !== null) {
    httpRequest.headers['x-ms-owner'] = xMsOwner;
  }
  if (xMsGroup !== undefined && xMsGroup !== null) {
    httpRequest.headers['x-ms-group'] = xMsGroup;
  }
  if (xMsPermissions !== undefined && xMsPermissions !== null) {
    httpRequest.headers['x-ms-permissions'] = xMsPermissions;
  }
  if (xMsAcl !== undefined && xMsAcl !== null) {
    httpRequest.headers['x-ms-acl'] = xMsAcl;
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince;
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince;
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = requestBody;
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lease Path
 *
 * Create and manage a lease to restrict write and delete access to the path.
 * This operation supports conditional HTTP requests.  For more information,
 * see [Specifying Conditional Headers for Blob Service
 * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
 *
 * @param {string} xMsLeaseAction There are five lease actions: "acquire",
 * "break", "change", "renew", and "release". Use "acquire" and specify the
 * "x-ms-proposed-lease-id" and "x-ms-lease-duration" to acquire a new lease.
 * Use "break" to break an existing lease. When a lease is broken, the lease
 * break period is allowed to elapse, during which time no lease operation
 * except break and release can be performed on the file. When a lease is
 * successfully broken, the response indicates the interval in seconds until a
 * new lease can be acquired. Use "change" and specify the current lease ID in
 * "x-ms-lease-id" and the new lease ID in "x-ms-proposed-lease-id" to change
 * the lease ID of an active lease. Use "renew" and specify the "x-ms-lease-id"
 * to renew an existing lease. Use "release" and specify the "x-ms-lease-id" to
 * release a lease. Possible values include: 'acquire', 'break', 'change',
 * 'renew', 'release'
 *
 * @param {string} filesystem The filesystem identifier.
 *
 * @param {string} path The file or directory path.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.xMsLeaseDuration] The lease duration is required to
 * acquire a lease, and specifies the duration of the lease in seconds.  The
 * lease duration must be between 15 and 60 seconds or -1 for infinite lease.
 *
 * @param {number} [options.xMsLeaseBreakPeriod] The lease break period
 * duration is optional to break a lease, and  specifies the break period of
 * the lease in seconds.  The lease break  duration must be between 0 and 60
 * seconds.
 *
 * @param {string} [options.xMsLeaseId] Required when "x-ms-lease-action" is
 * "renew", "change" or "release". For the renew and release actions, this must
 * match the current lease ID.
 *
 * @param {string} [options.xMsProposedLeaseId] Required when
 * "x-ms-lease-action" is "acquire" or "change".  A lease will be acquired with
 * this lease ID if the operation is successful.
 *
 * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
 * header to perform the operation only if the resource's ETag matches the
 * value specified. The ETag must be specified in quotes.
 *
 * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
 * special wildcard ("*") value. Specify this header to perform the operation
 * only if the resource's ETag does not match the value specified. The ETag
 * must be specified in quotes.
 *
 * @param {string} [options.ifModifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has been
 * modified since the specified date and time.
 *
 * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has not
 * been modified since the specified date and time.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _lease(xMsLeaseAction, filesystem, path, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let xMsLeaseDuration = (options && options.xMsLeaseDuration !== undefined) ? options.xMsLeaseDuration : undefined;
  let xMsLeaseBreakPeriod = (options && options.xMsLeaseBreakPeriod !== undefined) ? options.xMsLeaseBreakPeriod : undefined;
  let xMsLeaseId = (options && options.xMsLeaseId !== undefined) ? options.xMsLeaseId : undefined;
  let xMsProposedLeaseId = (options && options.xMsProposedLeaseId !== undefined) ? options.xMsProposedLeaseId : undefined;
  let ifMatch = (options && options.ifMatch !== undefined) ? options.ifMatch : undefined;
  let ifNoneMatch = (options && options.ifNoneMatch !== undefined) ? options.ifNoneMatch : undefined;
  let ifModifiedSince = (options && options.ifModifiedSince !== undefined) ? options.ifModifiedSince : undefined;
  let ifUnmodifiedSince = (options && options.ifUnmodifiedSince !== undefined) ? options.ifUnmodifiedSince : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (xMsLeaseAction) {
      let allowedValues = [ 'acquire', 'break', 'change', 'renew', 'release' ];
      if (!allowedValues.some( function(item) { return item === xMsLeaseAction; })) {
        throw new Error(xMsLeaseAction + ' is not a valid value. The valid values are: ' + allowedValues);
      }
    } else {
      throw new Error('xMsLeaseAction cannot be null or undefined.');
    }
    if (xMsLeaseDuration !== null && xMsLeaseDuration !== undefined && typeof xMsLeaseDuration !== 'number') {
      throw new Error('xMsLeaseDuration must be of type number.');
    }
    if (xMsLeaseBreakPeriod !== null && xMsLeaseBreakPeriod !== undefined && typeof xMsLeaseBreakPeriod !== 'number') {
      throw new Error('xMsLeaseBreakPeriod must be of type number.');
    }
    if (xMsLeaseId !== null && xMsLeaseId !== undefined && typeof xMsLeaseId.valueOf() !== 'string') {
      throw new Error('xMsLeaseId must be of type string.');
    }
    if (xMsLeaseId !== null && xMsLeaseId !== undefined) {
      if (xMsLeaseId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsLeaseId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (xMsProposedLeaseId !== null && xMsProposedLeaseId !== undefined && typeof xMsProposedLeaseId.valueOf() !== 'string') {
      throw new Error('xMsProposedLeaseId must be of type string.');
    }
    if (xMsProposedLeaseId !== null && xMsProposedLeaseId !== undefined) {
      if (xMsProposedLeaseId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsProposedLeaseId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
      throw new Error('ifMatch must be of type string.');
    }
    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
      throw new Error('ifNoneMatch must be of type string.');
    }
    if (ifModifiedSince !== null && ifModifiedSince !== undefined && typeof ifModifiedSince.valueOf() !== 'string') {
      throw new Error('ifModifiedSince must be of type string.');
    }
    if (ifUnmodifiedSince !== null && ifUnmodifiedSince !== undefined && typeof ifUnmodifiedSince.valueOf() !== 'string') {
      throw new Error('ifUnmodifiedSince must be of type string.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (filesystem !== null && filesystem !== undefined) {
      if (filesystem.length > 63)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MaxLength": 63');
      }
      if (filesystem.length < 3)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MinLength": 3');
      }
      if (filesystem.match(/^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/) === null)
      {
        throw new Error('"filesystem" should satisfy the constraint - "Pattern": /^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/');
      }
    }
    if (path === null || path === undefined || typeof path.valueOf() !== 'string') {
      throw new Error('path cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}/{path}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  requestUrl = requestUrl.replace('{path}', encodeURIComponent(path));
  let queryParameters = [];
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (xMsLeaseAction !== undefined && xMsLeaseAction !== null) {
    httpRequest.headers['x-ms-lease-action'] = xMsLeaseAction;
  }
  if (xMsLeaseDuration !== undefined && xMsLeaseDuration !== null) {
    httpRequest.headers['x-ms-lease-duration'] = xMsLeaseDuration.toString();
  }
  if (xMsLeaseBreakPeriod !== undefined && xMsLeaseBreakPeriod !== null) {
    httpRequest.headers['x-ms-lease-break-period'] = xMsLeaseBreakPeriod.toString();
  }
  if (xMsLeaseId !== undefined && xMsLeaseId !== null) {
    httpRequest.headers['x-ms-lease-id'] = xMsLeaseId;
  }
  if (xMsProposedLeaseId !== undefined && xMsProposedLeaseId !== null) {
    httpRequest.headers['x-ms-proposed-lease-id'] = xMsProposedLeaseId;
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince;
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince;
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 201 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Read File
 *
 * Read the contents of a file.  For read operations, range requests are
 * supported. This operation supports conditional HTTP requests.  For more
 * information, see [Specifying Conditional Headers for Blob Service
 * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
 *
 * @param {string} filesystem The filesystem identifier.
 *
 * @param {string} path The file or directory path.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.range] The HTTP Range request header specifies one
 * or more byte ranges of the resource to be retrieved.
 *
 * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
 * header to perform the operation only if the resource's ETag matches the
 * value specified. The ETag must be specified in quotes.
 *
 * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
 * special wildcard ("*") value. Specify this header to perform the operation
 * only if the resource's ETag does not match the value specified. The ETag
 * must be specified in quotes.
 *
 * @param {string} [options.ifModifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has been
 * modified since the specified date and time.
 *
 * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has not
 * been modified since the specified date and time.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _read(filesystem, path, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let range = (options && options.range !== undefined) ? options.range : undefined;
  let ifMatch = (options && options.ifMatch !== undefined) ? options.ifMatch : undefined;
  let ifNoneMatch = (options && options.ifNoneMatch !== undefined) ? options.ifNoneMatch : undefined;
  let ifModifiedSince = (options && options.ifModifiedSince !== undefined) ? options.ifModifiedSince : undefined;
  let ifUnmodifiedSince = (options && options.ifUnmodifiedSince !== undefined) ? options.ifUnmodifiedSince : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (range !== null && range !== undefined && typeof range.valueOf() !== 'string') {
      throw new Error('range must be of type string.');
    }
    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
      throw new Error('ifMatch must be of type string.');
    }
    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
      throw new Error('ifNoneMatch must be of type string.');
    }
    if (ifModifiedSince !== null && ifModifiedSince !== undefined && typeof ifModifiedSince.valueOf() !== 'string') {
      throw new Error('ifModifiedSince must be of type string.');
    }
    if (ifUnmodifiedSince !== null && ifUnmodifiedSince !== undefined && typeof ifUnmodifiedSince.valueOf() !== 'string') {
      throw new Error('ifUnmodifiedSince must be of type string.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (filesystem !== null && filesystem !== undefined) {
      if (filesystem.length > 63)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MaxLength": 63');
      }
      if (filesystem.length < 3)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MinLength": 3');
      }
      if (filesystem.match(/^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/) === null)
      {
        throw new Error('"filesystem" should satisfy the constraint - "Pattern": /^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/');
      }
    }
    if (path === null || path === undefined || typeof path.valueOf() !== 'string') {
      throw new Error('path cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}/{path}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  requestUrl = requestUrl.replace('{path}', encodeURIComponent(path));
  let queryParameters = [];
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (range !== undefined && range !== null) {
    httpRequest.headers['Range'] = range;
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince;
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince;
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  httpRequest.streamedResponse = true;
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }

    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 206) {
      let error = new Error(`Unexpected status code: ${statusCode}`);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        if (responseBody !== undefined) parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }

    // Create Result
    let result = response;
    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get Properties | Get Access Control List
 *
 * Get the properties for a file or directory, and optionally include the
 * access control list.  This operation supports conditional HTTP requests.
 * For more information, see [Specifying Conditional Headers for Blob Service
 * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
 *
 * @param {string} filesystem The filesystem identifier.
 *
 * @param {string} path The file or directory path.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.action] Optional. If the value is
 * "getAccessControl" the access control list is returned in the response
 * headers (Hierarchical Namespace must be enabled for the account). Possible
 * values include: 'getAccessControl'
 *
 * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
 * header to perform the operation only if the resource's ETag matches the
 * value specified. The ETag must be specified in quotes.
 *
 * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
 * special wildcard ("*") value. Specify this header to perform the operation
 * only if the resource's ETag does not match the value specified. The ETag
 * must be specified in quotes.
 *
 * @param {string} [options.ifModifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has been
 * modified since the specified date and time.
 *
 * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has not
 * been modified since the specified date and time.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getProperties(filesystem, path, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let action = (options && options.action !== undefined) ? options.action : undefined;
  let ifMatch = (options && options.ifMatch !== undefined) ? options.ifMatch : undefined;
  let ifNoneMatch = (options && options.ifNoneMatch !== undefined) ? options.ifNoneMatch : undefined;
  let ifModifiedSince = (options && options.ifModifiedSince !== undefined) ? options.ifModifiedSince : undefined;
  let ifUnmodifiedSince = (options && options.ifUnmodifiedSince !== undefined) ? options.ifUnmodifiedSince : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (action) {
      let allowedValues = [ 'getAccessControl' ];
      if (!allowedValues.some( function(item) { return item === action; })) {
        throw new Error(action + ' is not a valid value. The valid values are: ' + allowedValues);
      }
    }
    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
      throw new Error('ifMatch must be of type string.');
    }
    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
      throw new Error('ifNoneMatch must be of type string.');
    }
    if (ifModifiedSince !== null && ifModifiedSince !== undefined && typeof ifModifiedSince.valueOf() !== 'string') {
      throw new Error('ifModifiedSince must be of type string.');
    }
    if (ifUnmodifiedSince !== null && ifUnmodifiedSince !== undefined && typeof ifUnmodifiedSince.valueOf() !== 'string') {
      throw new Error('ifUnmodifiedSince must be of type string.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (filesystem !== null && filesystem !== undefined) {
      if (filesystem.length > 63)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MaxLength": 63');
      }
      if (filesystem.length < 3)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MinLength": 3');
      }
      if (filesystem.match(/^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/) === null)
      {
        throw new Error('"filesystem" should satisfy the constraint - "Pattern": /^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/');
      }
    }
    if (path === null || path === undefined || typeof path.valueOf() !== 'string') {
      throw new Error('path cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}/{path}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  requestUrl = requestUrl.replace('{path}', encodeURIComponent(path));
  let queryParameters = [];
  if (action !== null && action !== undefined) {
    queryParameters.push('action=' + encodeURIComponent(action));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'HEAD';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince;
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince;
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete File | Delete Directory
 *
 * Delete the file or directory. This operation supports conditional HTTP
 * requests.  For more information, see [Specifying Conditional Headers for
 * Blob Service
 * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
 *
 * @param {string} filesystem The filesystem identifier.
 *
 * @param {string} path The file or directory path.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.recursive] Required and valid only when the
 * resource is a directory.  If "true", all paths beneath the directory will be
 * deleted. If "false" and the directory is non-empty, an error occurs.
 *
 * @param {string} [options.continuation] Optional.  When deleting a directory,
 * the number of paths that are deleted with each invocation is limited.  If
 * the number of paths to be deleted exceeds this limit, a continuation token
 * is returned in this response header.  When a continuation token is returned
 * in the response, it must be specified in a subsequent invocation of the
 * delete operation to continue deleting the directory.
 *
 * @param {string} [options.xMsLeaseId] The lease ID must be specified if there
 * is an active lease.
 *
 * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
 * header to perform the operation only if the resource's ETag matches the
 * value specified. The ETag must be specified in quotes.
 *
 * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
 * special wildcard ("*") value. Specify this header to perform the operation
 * only if the resource's ETag does not match the value specified. The ETag
 * must be specified in quotes.
 *
 * @param {string} [options.ifModifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has been
 * modified since the specified date and time.
 *
 * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
 * Specify this header to perform the operation only if the resource has not
 * been modified since the specified date and time.
 *
 * @param {string} [options.xMsClientRequestId] A UUID recorded in the
 * analytics logs for troubleshooting and correlation.
 *
 * @param {number} [options.timeout] An optional operation timeout value in
 * seconds. The period begins when the request is received by the service. If
 * the timeout value elapses before the operation completes, the operation
 * fails.
 *
 * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
 * (UTC) for the request.  This is required when using shared key
 * authorization.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMethod(filesystem, path, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
  let continuation = (options && options.continuation !== undefined) ? options.continuation : undefined;
  let xMsLeaseId = (options && options.xMsLeaseId !== undefined) ? options.xMsLeaseId : undefined;
  let ifMatch = (options && options.ifMatch !== undefined) ? options.ifMatch : undefined;
  let ifNoneMatch = (options && options.ifNoneMatch !== undefined) ? options.ifNoneMatch : undefined;
  let ifModifiedSince = (options && options.ifModifiedSince !== undefined) ? options.ifModifiedSince : undefined;
  let ifUnmodifiedSince = (options && options.ifUnmodifiedSince !== undefined) ? options.ifUnmodifiedSince : undefined;
  let xMsClientRequestId = (options && options.xMsClientRequestId !== undefined) ? options.xMsClientRequestId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : undefined;
  let xMsDate = (options && options.xMsDate !== undefined) ? options.xMsDate : undefined;
  // Validate
  try {
    if (this.client.accountName === null || this.client.accountName === undefined || typeof this.client.accountName.valueOf() !== 'string') {
      throw new Error('this.client.accountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.dnsSuffix === null || this.client.dnsSuffix === undefined || typeof this.client.dnsSuffix.valueOf() !== 'string') {
      throw new Error('this.client.dnsSuffix cannot be null or undefined and it must be of type string.');
    }
    if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
      throw new Error('recursive must be of type boolean.');
    }
    if (continuation !== null && continuation !== undefined && typeof continuation.valueOf() !== 'string') {
      throw new Error('continuation must be of type string.');
    }
    if (xMsLeaseId !== null && xMsLeaseId !== undefined && typeof xMsLeaseId.valueOf() !== 'string') {
      throw new Error('xMsLeaseId must be of type string.');
    }
    if (xMsLeaseId !== null && xMsLeaseId !== undefined) {
      if (xMsLeaseId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsLeaseId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
      throw new Error('ifMatch must be of type string.');
    }
    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
      throw new Error('ifNoneMatch must be of type string.');
    }
    if (ifModifiedSince !== null && ifModifiedSince !== undefined && typeof ifModifiedSince.valueOf() !== 'string') {
      throw new Error('ifModifiedSince must be of type string.');
    }
    if (ifUnmodifiedSince !== null && ifUnmodifiedSince !== undefined && typeof ifUnmodifiedSince.valueOf() !== 'string') {
      throw new Error('ifUnmodifiedSince must be of type string.');
    }
    if (filesystem === null || filesystem === undefined || typeof filesystem.valueOf() !== 'string') {
      throw new Error('filesystem cannot be null or undefined and it must be of type string.');
    }
    if (filesystem !== null && filesystem !== undefined) {
      if (filesystem.length > 63)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MaxLength": 63');
      }
      if (filesystem.length < 3)
      {
        throw new Error('"filesystem" should satisfy the constraint - "MinLength": 3');
      }
      if (filesystem.match(/^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/) === null)
      {
        throw new Error('"filesystem" should satisfy the constraint - "Pattern": /^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$/');
      }
    }
    if (path === null || path === undefined || typeof path.valueOf() !== 'string') {
      throw new Error('path cannot be null or undefined and it must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined && typeof xMsClientRequestId.valueOf() !== 'string') {
      throw new Error('xMsClientRequestId must be of type string.');
    }
    if (xMsClientRequestId !== null && xMsClientRequestId !== undefined) {
      if (xMsClientRequestId.match(/^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/) === null)
      {
        throw new Error('"xMsClientRequestId" should satisfy the constraint - "Pattern": /^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$/');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (xMsDate !== null && xMsDate !== undefined && typeof xMsDate.valueOf() !== 'string') {
      throw new Error('xMsDate must be of type string.');
    }
    if (this.client.xMsVersion !== null && this.client.xMsVersion !== undefined && typeof this.client.xMsVersion.valueOf() !== 'string') {
      throw new Error('this.client.xMsVersion must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{filesystem}/{path}';
  requestUrl = requestUrl.replace('{accountName}', this.client.accountName);
  requestUrl = requestUrl.replace('{dnsSuffix}', this.client.dnsSuffix);
  requestUrl = requestUrl.replace('{filesystem}', encodeURIComponent(filesystem));
  requestUrl = requestUrl.replace('{path}', encodeURIComponent(path));
  let queryParameters = [];
  if (recursive !== null && recursive !== undefined) {
    queryParameters.push('recursive=' + encodeURIComponent(recursive.toString()));
  }
  if (continuation !== null && continuation !== undefined) {
    queryParameters.push('continuation=' + encodeURIComponent(continuation));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (xMsLeaseId !== undefined && xMsLeaseId !== null) {
    httpRequest.headers['x-ms-lease-id'] = xMsLeaseId;
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince;
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince;
  }
  if (xMsClientRequestId !== undefined && xMsClientRequestId !== null) {
    httpRequest.headers['x-ms-client-request-id'] = xMsClientRequestId;
  }
  if (xMsDate !== undefined && xMsDate !== null) {
    httpRequest.headers['x-ms-date'] = xMsDate;
  }
  if (this.client.xMsVersion !== undefined && this.client.xMsVersion !== null) {
    httpRequest.headers['x-ms-version'] = this.client.xMsVersion;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['DataLakeStorageError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a PathOperations. */
class PathOperations {
  /**
   * Create a PathOperations.
   * @param {DataLakeStorageClient} client Reference to the service client.
   */
  constructor(client) {
    this.client = client;
    this._list = _list;
    this._create = _create;
    this._update = _update;
    this._lease = _lease;
    this._read = _read;
    this._getProperties = _getProperties;
    this._deleteMethod = _deleteMethod;
  }

  /**
   * @summary List Paths
   *
   * List filesystem paths and their properties.
   *
   * @param {boolean} recursive If "true", all paths are listed; otherwise, only
   * paths at the root of the filesystem are listed.  If "directory" is
   * specified, the list will only include paths that share the same root.
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.directory] Filters results to paths within the
   * specified directory. An error occurs if the directory does not exist.
   *
   * @param {string} [options.continuation] The number of paths returned with
   * each invocation is limited. If the number of paths to be returned exceeds
   * this limit, a continuation token is returned in the response header
   * x-ms-continuation. When a continuation token is  returned in the response,
   * it must be specified in a subsequent invocation of the list operation to
   * continue listing the paths.
   *
   * @param {number} [options.maxResults] An optional value that specifies the
   * maximum number of items to return. If omitted or greater than 5,000, the
   * response will include up to 5,000 items.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PathList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listWithHttpOperationResponse(recursive, filesystem, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._list(recursive, filesystem, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List Paths
   *
   * List filesystem paths and their properties.
   *
   * @param {boolean} recursive If "true", all paths are listed; otherwise, only
   * paths at the root of the filesystem are listed.  If "directory" is
   * specified, the list will only include paths that share the same root.
   *
   * @param {string} filesystem The filesystem identifier.  The value must start
   * and end with a letter or number and must contain only letters, numbers, and
   * the dash (-) character.  Consecutive dashes are not permitted.  All letters
   * must be lowercase.  The value must have between 3 and 63 characters.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.directory] Filters results to paths within the
   * specified directory. An error occurs if the directory does not exist.
   *
   * @param {string} [options.continuation] The number of paths returned with
   * each invocation is limited. If the number of paths to be returned exceeds
   * this limit, a continuation token is returned in the response header
   * x-ms-continuation. When a continuation token is  returned in the response,
   * it must be specified in a subsequent invocation of the list operation to
   * continue listing the paths.
   *
   * @param {number} [options.maxResults] An optional value that specifies the
   * maximum number of items to return. If omitted or greater than 5,000, the
   * response will include up to 5,000 items.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PathList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PathList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  list(recursive, filesystem, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._list(recursive, filesystem, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._list(recursive, filesystem, options, optionalCallback);
    }
  }

  /**
   * @summary Create File | Create Directory | Rename File | Rename Directory
   *
   * Create or rename a file or directory.    By default, the destination is
   * overwritten and if the destination already exists and has a lease the lease
   * is broken.  This operation supports conditional HTTP requests.  For more
   * information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   * To fail if the destination already exists, use a conditional request with
   * If-None-Match: "*".
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.resource] Required only for Create File and Create
   * Directory. The value must be "file" or "directory". Possible values include:
   * 'directory', 'file'
   *
   * @param {string} [options.continuation] Optional.  When renaming a directory,
   * the number of paths that are renamed with each invocation is limited.  If
   * the number of paths to be renamed exceeds this limit, a continuation token
   * is returned in this response header.  When a continuation token is returned
   * in the response, it must be specified in a subsequent invocation of the
   * rename operation to continue renaming the directory.
   *
   * @param {string} [options.mode] Optional. Valid only when namespace is
   * enabled. This parameter determines the behavior of the rename operation. The
   * value must be "legacy" or "posix", and the default value will be "posix".
   * Possible values include: 'legacy', 'posix'
   *
   * @param {string} [options.cacheControl] Optional.  The service stores this
   * value and includes it in the "Cache-Control" response header for "Read File"
   * operations for "Read File" operations.
   *
   * @param {string} [options.contentEncoding] Optional.  Specifies which content
   * encodings have been applied to the file. This value is returned to the
   * client when the "Read File" operation is performed.
   *
   * @param {string} [options.contentLanguage] Optional.  Specifies the natural
   * language used by the intended audience for the file.
   *
   * @param {string} [options.contentDisposition] Optional.  The service stores
   * this value and includes it in the "Content-Disposition" response header for
   * "Read File" operations.
   *
   * @param {string} [options.xMsCacheControl] Optional.  The service stores this
   * value and includes it in the "Cache-Control" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsContentType] Optional.  The service stores this
   * value and includes it in the "Content-Type" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsContentEncoding] Optional.  The service stores
   * this value and includes it in the "Content-Encoding" response header for
   * "Read File" operations.
   *
   * @param {string} [options.xMsContentLanguage] Optional.  The service stores
   * this value and includes it in the "Content-Language" response header for
   * "Read File" operations.
   *
   * @param {string} [options.xMsContentDisposition] Optional.  The service
   * stores this value and includes it in the "Content-Disposition" response
   * header for "Read File" operations.
   *
   * @param {string} [options.xMsRenameSource] An optional file or directory to
   * be renamed.  The value must have the following format:
   * "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties
   * will overwrite the existing properties; otherwise, the existing properties
   * will be preserved.
   *
   * @param {string} [options.xMsLeaseId] Optional.  A lease ID for the path
   * specified in the URI.  The path to be overwritten must have an active lease
   * and the lease ID must match.
   *
   * @param {string} [options.xMsProposedLeaseId] Optional for create operations.
   * Required when "x-ms-lease-action" is used.  A lease will be acquired using
   * the proposed ID when the resource is created.
   *
   * @param {string} [options.xMsSourceLeaseId] Optional for rename operations.
   * A lease ID for the source path.  The source path must have an active lease
   * and the lease ID must match.
   *
   * @param {string} [options.xMsProperties] Optional.  User-defined properties
   * to be stored with the file or directory, in the format of a comma-separated
   * list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64
   * encoded.
   *
   * @param {string} [options.xMsPermissions] Optional and only valid if
   * Hierarchical Namespace is enabled for the account. Sets POSIX access
   * permissions for the file owner, the file owning group, and others. Each
   * class may be granted read, write, or execute permission.  The sticky bit is
   * also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g.
   * 0766) are supported.
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsSourceIfMatch] Optional.  An ETag value. Specify
   * this header to perform the rename operation only if the source's ETag
   * matches the value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.xMsSourceIfNoneMatch] Optional.  An ETag value or
   * the special wildcard ("*") value. Specify this header to perform the rename
   * operation only if the source's ETag does not match the value specified. The
   * ETag must be specified in quotes.
   *
   * @param {string} [options.xMsSourceIfModifiedSince] Optional. A date and time
   * value. Specify this header to perform the rename operation only if the
   * source has been modified since the specified date and time.
   *
   * @param {string} [options.xMsSourceIfUnmodifiedSince] Optional. A date and
   * time value. Specify this header to perform the rename operation only if the
   * source has not been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createWithHttpOperationResponse(filesystem, path, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._create(filesystem, path, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create File | Create Directory | Rename File | Rename Directory
   *
   * Create or rename a file or directory.    By default, the destination is
   * overwritten and if the destination already exists and has a lease the lease
   * is broken.  This operation supports conditional HTTP requests.  For more
   * information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   * To fail if the destination already exists, use a conditional request with
   * If-None-Match: "*".
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.resource] Required only for Create File and Create
   * Directory. The value must be "file" or "directory". Possible values include:
   * 'directory', 'file'
   *
   * @param {string} [options.continuation] Optional.  When renaming a directory,
   * the number of paths that are renamed with each invocation is limited.  If
   * the number of paths to be renamed exceeds this limit, a continuation token
   * is returned in this response header.  When a continuation token is returned
   * in the response, it must be specified in a subsequent invocation of the
   * rename operation to continue renaming the directory.
   *
   * @param {string} [options.mode] Optional. Valid only when namespace is
   * enabled. This parameter determines the behavior of the rename operation. The
   * value must be "legacy" or "posix", and the default value will be "posix".
   * Possible values include: 'legacy', 'posix'
   *
   * @param {string} [options.cacheControl] Optional.  The service stores this
   * value and includes it in the "Cache-Control" response header for "Read File"
   * operations for "Read File" operations.
   *
   * @param {string} [options.contentEncoding] Optional.  Specifies which content
   * encodings have been applied to the file. This value is returned to the
   * client when the "Read File" operation is performed.
   *
   * @param {string} [options.contentLanguage] Optional.  Specifies the natural
   * language used by the intended audience for the file.
   *
   * @param {string} [options.contentDisposition] Optional.  The service stores
   * this value and includes it in the "Content-Disposition" response header for
   * "Read File" operations.
   *
   * @param {string} [options.xMsCacheControl] Optional.  The service stores this
   * value and includes it in the "Cache-Control" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsContentType] Optional.  The service stores this
   * value and includes it in the "Content-Type" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsContentEncoding] Optional.  The service stores
   * this value and includes it in the "Content-Encoding" response header for
   * "Read File" operations.
   *
   * @param {string} [options.xMsContentLanguage] Optional.  The service stores
   * this value and includes it in the "Content-Language" response header for
   * "Read File" operations.
   *
   * @param {string} [options.xMsContentDisposition] Optional.  The service
   * stores this value and includes it in the "Content-Disposition" response
   * header for "Read File" operations.
   *
   * @param {string} [options.xMsRenameSource] An optional file or directory to
   * be renamed.  The value must have the following format:
   * "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties
   * will overwrite the existing properties; otherwise, the existing properties
   * will be preserved.
   *
   * @param {string} [options.xMsLeaseId] Optional.  A lease ID for the path
   * specified in the URI.  The path to be overwritten must have an active lease
   * and the lease ID must match.
   *
   * @param {string} [options.xMsProposedLeaseId] Optional for create operations.
   * Required when "x-ms-lease-action" is used.  A lease will be acquired using
   * the proposed ID when the resource is created.
   *
   * @param {string} [options.xMsSourceLeaseId] Optional for rename operations.
   * A lease ID for the source path.  The source path must have an active lease
   * and the lease ID must match.
   *
   * @param {string} [options.xMsProperties] Optional.  User-defined properties
   * to be stored with the file or directory, in the format of a comma-separated
   * list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64
   * encoded.
   *
   * @param {string} [options.xMsPermissions] Optional and only valid if
   * Hierarchical Namespace is enabled for the account. Sets POSIX access
   * permissions for the file owner, the file owning group, and others. Each
   * class may be granted read, write, or execute permission.  The sticky bit is
   * also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g.
   * 0766) are supported.
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsSourceIfMatch] Optional.  An ETag value. Specify
   * this header to perform the rename operation only if the source's ETag
   * matches the value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.xMsSourceIfNoneMatch] Optional.  An ETag value or
   * the special wildcard ("*") value. Specify this header to perform the rename
   * operation only if the source's ETag does not match the value specified. The
   * ETag must be specified in quotes.
   *
   * @param {string} [options.xMsSourceIfModifiedSince] Optional. A date and time
   * value. Specify this header to perform the rename operation only if the
   * source has been modified since the specified date and time.
   *
   * @param {string} [options.xMsSourceIfUnmodifiedSince] Optional. A date and
   * time value. Specify this header to perform the rename operation only if the
   * source has not been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  create(filesystem, path, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._create(filesystem, path, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._create(filesystem, path, options, optionalCallback);
    }
  }

  /**
   * @summary Append Data | Flush Data | Set Properties | Set Access Control
   *
   * Uploads data to be appended to a file, flushes (writes) previously uploaded
   * data to a file, sets properties for a file or directory, or sets access
   * control for a file or directory. Data can only be appended to a file. This
   * operation supports conditional HTTP requests. For more information, see
   * [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} action The action must be "append" to upload data to be
   * appended to a file, "flush" to flush previously uploaded data to a file,
   * "setProperties" to set the properties of a file or directory, or
   * "setAccessControl" to set the owner, group, permissions, or access control
   * list for a file or directory.  Note that Hierarchical Namespace must be
   * enabled for the account in order to use access control.  Also note that the
   * Access Control List (ACL) includes permissions for the owner, owning group,
   * and others, so the x-ms-permissions and x-ms-acl request headers are
   * mutually exclusive. Possible values include: 'append', 'flush',
   * 'setProperties', 'setAccessControl'
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.position] This parameter allows the caller to
   * upload data in parallel and control the order in which it is appended to the
   * file.  It is required when uploading data to be appended to the file and
   * when flushing previously uploaded data to the file.  The value must be the
   * position where the data is to be appended.  Uploaded data is not immediately
   * flushed, or written, to the file.  To flush, the previously uploaded data
   * must be contiguous, the position parameter must be specified and equal to
   * the length of the file after all data has been written, and there must not
   * be a request entity body included with the request.
   *
   * @param {boolean} [options.retainUncommittedData] Valid only for flush
   * operations.  If "true", uncommitted data is retained after the flush
   * operation completes; otherwise, the uncommitted data is deleted after the
   * flush operation.  The default is false.  Data at offsets less than the
   * specified position are written to the file when flush succeeds, but this
   * optional parameter allows data after the flush position to be retained for a
   * future flush operation.
   *
   * @param {string} [options.contentLength] Required for "Append Data" and
   * "Flush Data".  Must be 0 for "Flush Data".  Must be the length of the
   * request content in bytes for "Append Data".
   *
   * @param {string} [options.xMsLeaseAction] Optional.  The lease action can be
   * "renew" to renew an existing lease or "release" to release a lease. Possible
   * values include: 'renew', 'release'
   *
   * @param {string} [options.xMsLeaseId] The lease ID must be specified if there
   * is an active lease.
   *
   * @param {string} [options.xMsCacheControl] Optional and only valid for flush
   * and set properties operations.  The service stores this value and includes
   * it in the "Cache-Control" response header for "Read File" operations.
   *
   * @param {string} [options.xMsContentType] Optional and only valid for flush
   * and set properties operations.  The service stores this value and includes
   * it in the "Content-Type" response header for "Read File" operations.
   *
   * @param {string} [options.xMsContentDisposition] Optional and only valid for
   * flush and set properties operations.  The service stores this value and
   * includes it in the "Content-Disposition" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsContentEncoding] Optional and only valid for
   * flush and set properties operations.  The service stores this value and
   * includes it in the "Content-Encoding" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsContentLanguage] Optional and only valid for
   * flush and set properties operations.  The service stores this value and
   * includes it in the "Content-Language" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsProperties] Optional.  User-defined properties
   * to be stored with the file or directory, in the format of a comma-separated
   * list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64
   * encoded.  Valid only for the setProperties operation.  If the file or
   * directory exists, any properties not included in the list will be removed.
   * All properties are removed if the header is omitted.  To merge new and
   * existing properties, first get all existing properties and the current
   * E-Tag, then make a conditional request with the E-Tag and include values for
   * all properties.
   *
   * @param {string} [options.xMsOwner] Optional and valid only for the
   * setAccessControl operation. Sets the owner of the file or directory.
   *
   * @param {string} [options.xMsGroup] Optional and valid only for the
   * setAccessControl operation. Sets the owning group of the file or directory.
   *
   * @param {string} [options.xMsPermissions] Optional and only valid if
   * Hierarchical Namespace is enabled for the account. Sets POSIX access
   * permissions for the file owner, the file owning group, and others. Each
   * class may be granted read, write, or execute permission.  The sticky bit is
   * also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g.
   * 0766) are supported. Invalid in conjunction with x-ms-acl.
   *
   * @param {string} [options.xMsAcl] Optional and valid only for the
   * setAccessControl operation. Sets POSIX access control rights on files and
   * directories. The value is a comma-separated list of access control entries
   * that fully replaces the existing access control list (ACL).  Each access
   * control entry (ACE) consists of a scope, a type, a user or group identifier,
   * and permissions in the format "[scope:][type]:[id]:[permissions]". The scope
   * must be "default" to indicate the ACE belongs to the default ACL for a
   * directory; otherwise scope is implicit and the ACE belongs to the access
   * ACL.  There are four ACE types: "user" grants rights to the owner or a named
   * user, "group" grants rights to the owning group or a named group, "mask"
   * restricts rights granted to named users and the members of groups, and
   * "other" grants rights to all users not found in any of the other entries.
   * The user or group identifier is omitted for entries of type "mask" and
   * "other".  The user or group identifier is also omitted for the owner and
   * owning group.  The permission field is a 3-character sequence where the
   * first character is 'r' to grant read access, the second character is 'w' to
   * grant write access, and the third character is 'x' to grant execute
   * permission.  If access is not granted, the '-' character is used to denote
   * that the permission is denied. For example, the following ACL grants read,
   * write, and execute rights to the file owner and john.doe@contoso, the read
   * right to the owning group, and nothing to everyone else:
   * "user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx".
   * Invalid in conjunction with x-ms-permissions.
   *
   * @param {string} [options.ifMatch] Optional for Flush Data and Set
   * Properties, but invalid for Append Data.  An ETag value. Specify this header
   * to perform the operation only if the resource's ETag matches the value
   * specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional for Flush Data and Set
   * Properties, but invalid for Append Data.  An ETag value or the special
   * wildcard ("*") value. Specify this header to perform the operation only if
   * the resource's ETag does not match the value specified. The ETag must be
   * specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional for Flush Data and Set
   * Properties, but invalid for Append Data. A date and time value. Specify this
   * header to perform the operation only if the resource has been modified since
   * the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional for Flush Data and Set
   * Properties, but invalid for Append Data. A date and time value. Specify this
   * header to perform the operation only if the resource has not been modified
   * since the specified date and time.
   *
   * @param {object} [options.requestBody] Valid only for append operations.  The
   * data to be uploaded and appended to the file.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateWithHttpOperationResponse(action, filesystem, path, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._update(action, filesystem, path, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Append Data | Flush Data | Set Properties | Set Access Control
   *
   * Uploads data to be appended to a file, flushes (writes) previously uploaded
   * data to a file, sets properties for a file or directory, or sets access
   * control for a file or directory. Data can only be appended to a file. This
   * operation supports conditional HTTP requests. For more information, see
   * [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} action The action must be "append" to upload data to be
   * appended to a file, "flush" to flush previously uploaded data to a file,
   * "setProperties" to set the properties of a file or directory, or
   * "setAccessControl" to set the owner, group, permissions, or access control
   * list for a file or directory.  Note that Hierarchical Namespace must be
   * enabled for the account in order to use access control.  Also note that the
   * Access Control List (ACL) includes permissions for the owner, owning group,
   * and others, so the x-ms-permissions and x-ms-acl request headers are
   * mutually exclusive. Possible values include: 'append', 'flush',
   * 'setProperties', 'setAccessControl'
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.position] This parameter allows the caller to
   * upload data in parallel and control the order in which it is appended to the
   * file.  It is required when uploading data to be appended to the file and
   * when flushing previously uploaded data to the file.  The value must be the
   * position where the data is to be appended.  Uploaded data is not immediately
   * flushed, or written, to the file.  To flush, the previously uploaded data
   * must be contiguous, the position parameter must be specified and equal to
   * the length of the file after all data has been written, and there must not
   * be a request entity body included with the request.
   *
   * @param {boolean} [options.retainUncommittedData] Valid only for flush
   * operations.  If "true", uncommitted data is retained after the flush
   * operation completes; otherwise, the uncommitted data is deleted after the
   * flush operation.  The default is false.  Data at offsets less than the
   * specified position are written to the file when flush succeeds, but this
   * optional parameter allows data after the flush position to be retained for a
   * future flush operation.
   *
   * @param {string} [options.contentLength] Required for "Append Data" and
   * "Flush Data".  Must be 0 for "Flush Data".  Must be the length of the
   * request content in bytes for "Append Data".
   *
   * @param {string} [options.xMsLeaseAction] Optional.  The lease action can be
   * "renew" to renew an existing lease or "release" to release a lease. Possible
   * values include: 'renew', 'release'
   *
   * @param {string} [options.xMsLeaseId] The lease ID must be specified if there
   * is an active lease.
   *
   * @param {string} [options.xMsCacheControl] Optional and only valid for flush
   * and set properties operations.  The service stores this value and includes
   * it in the "Cache-Control" response header for "Read File" operations.
   *
   * @param {string} [options.xMsContentType] Optional and only valid for flush
   * and set properties operations.  The service stores this value and includes
   * it in the "Content-Type" response header for "Read File" operations.
   *
   * @param {string} [options.xMsContentDisposition] Optional and only valid for
   * flush and set properties operations.  The service stores this value and
   * includes it in the "Content-Disposition" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsContentEncoding] Optional and only valid for
   * flush and set properties operations.  The service stores this value and
   * includes it in the "Content-Encoding" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsContentLanguage] Optional and only valid for
   * flush and set properties operations.  The service stores this value and
   * includes it in the "Content-Language" response header for "Read File"
   * operations.
   *
   * @param {string} [options.xMsProperties] Optional.  User-defined properties
   * to be stored with the file or directory, in the format of a comma-separated
   * list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64
   * encoded.  Valid only for the setProperties operation.  If the file or
   * directory exists, any properties not included in the list will be removed.
   * All properties are removed if the header is omitted.  To merge new and
   * existing properties, first get all existing properties and the current
   * E-Tag, then make a conditional request with the E-Tag and include values for
   * all properties.
   *
   * @param {string} [options.xMsOwner] Optional and valid only for the
   * setAccessControl operation. Sets the owner of the file or directory.
   *
   * @param {string} [options.xMsGroup] Optional and valid only for the
   * setAccessControl operation. Sets the owning group of the file or directory.
   *
   * @param {string} [options.xMsPermissions] Optional and only valid if
   * Hierarchical Namespace is enabled for the account. Sets POSIX access
   * permissions for the file owner, the file owning group, and others. Each
   * class may be granted read, write, or execute permission.  The sticky bit is
   * also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g.
   * 0766) are supported. Invalid in conjunction with x-ms-acl.
   *
   * @param {string} [options.xMsAcl] Optional and valid only for the
   * setAccessControl operation. Sets POSIX access control rights on files and
   * directories. The value is a comma-separated list of access control entries
   * that fully replaces the existing access control list (ACL).  Each access
   * control entry (ACE) consists of a scope, a type, a user or group identifier,
   * and permissions in the format "[scope:][type]:[id]:[permissions]". The scope
   * must be "default" to indicate the ACE belongs to the default ACL for a
   * directory; otherwise scope is implicit and the ACE belongs to the access
   * ACL.  There are four ACE types: "user" grants rights to the owner or a named
   * user, "group" grants rights to the owning group or a named group, "mask"
   * restricts rights granted to named users and the members of groups, and
   * "other" grants rights to all users not found in any of the other entries.
   * The user or group identifier is omitted for entries of type "mask" and
   * "other".  The user or group identifier is also omitted for the owner and
   * owning group.  The permission field is a 3-character sequence where the
   * first character is 'r' to grant read access, the second character is 'w' to
   * grant write access, and the third character is 'x' to grant execute
   * permission.  If access is not granted, the '-' character is used to denote
   * that the permission is denied. For example, the following ACL grants read,
   * write, and execute rights to the file owner and john.doe@contoso, the read
   * right to the owning group, and nothing to everyone else:
   * "user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx".
   * Invalid in conjunction with x-ms-permissions.
   *
   * @param {string} [options.ifMatch] Optional for Flush Data and Set
   * Properties, but invalid for Append Data.  An ETag value. Specify this header
   * to perform the operation only if the resource's ETag matches the value
   * specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional for Flush Data and Set
   * Properties, but invalid for Append Data.  An ETag value or the special
   * wildcard ("*") value. Specify this header to perform the operation only if
   * the resource's ETag does not match the value specified. The ETag must be
   * specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional for Flush Data and Set
   * Properties, but invalid for Append Data. A date and time value. Specify this
   * header to perform the operation only if the resource has been modified since
   * the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional for Flush Data and Set
   * Properties, but invalid for Append Data. A date and time value. Specify this
   * header to perform the operation only if the resource has not been modified
   * since the specified date and time.
   *
   * @param {object} [options.requestBody] Valid only for append operations.  The
   * data to be uploaded and appended to the file.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  update(action, filesystem, path, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._update(action, filesystem, path, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._update(action, filesystem, path, options, optionalCallback);
    }
  }

  /**
   * @summary Lease Path
   *
   * Create and manage a lease to restrict write and delete access to the path.
   * This operation supports conditional HTTP requests.  For more information,
   * see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} xMsLeaseAction There are five lease actions: "acquire",
   * "break", "change", "renew", and "release". Use "acquire" and specify the
   * "x-ms-proposed-lease-id" and "x-ms-lease-duration" to acquire a new lease.
   * Use "break" to break an existing lease. When a lease is broken, the lease
   * break period is allowed to elapse, during which time no lease operation
   * except break and release can be performed on the file. When a lease is
   * successfully broken, the response indicates the interval in seconds until a
   * new lease can be acquired. Use "change" and specify the current lease ID in
   * "x-ms-lease-id" and the new lease ID in "x-ms-proposed-lease-id" to change
   * the lease ID of an active lease. Use "renew" and specify the "x-ms-lease-id"
   * to renew an existing lease. Use "release" and specify the "x-ms-lease-id" to
   * release a lease. Possible values include: 'acquire', 'break', 'change',
   * 'renew', 'release'
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.xMsLeaseDuration] The lease duration is required to
   * acquire a lease, and specifies the duration of the lease in seconds.  The
   * lease duration must be between 15 and 60 seconds or -1 for infinite lease.
   *
   * @param {number} [options.xMsLeaseBreakPeriod] The lease break period
   * duration is optional to break a lease, and  specifies the break period of
   * the lease in seconds.  The lease break  duration must be between 0 and 60
   * seconds.
   *
   * @param {string} [options.xMsLeaseId] Required when "x-ms-lease-action" is
   * "renew", "change" or "release". For the renew and release actions, this must
   * match the current lease ID.
   *
   * @param {string} [options.xMsProposedLeaseId] Required when
   * "x-ms-lease-action" is "acquire" or "change".  A lease will be acquired with
   * this lease ID if the operation is successful.
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  leaseWithHttpOperationResponse(xMsLeaseAction, filesystem, path, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._lease(xMsLeaseAction, filesystem, path, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lease Path
   *
   * Create and manage a lease to restrict write and delete access to the path.
   * This operation supports conditional HTTP requests.  For more information,
   * see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} xMsLeaseAction There are five lease actions: "acquire",
   * "break", "change", "renew", and "release". Use "acquire" and specify the
   * "x-ms-proposed-lease-id" and "x-ms-lease-duration" to acquire a new lease.
   * Use "break" to break an existing lease. When a lease is broken, the lease
   * break period is allowed to elapse, during which time no lease operation
   * except break and release can be performed on the file. When a lease is
   * successfully broken, the response indicates the interval in seconds until a
   * new lease can be acquired. Use "change" and specify the current lease ID in
   * "x-ms-lease-id" and the new lease ID in "x-ms-proposed-lease-id" to change
   * the lease ID of an active lease. Use "renew" and specify the "x-ms-lease-id"
   * to renew an existing lease. Use "release" and specify the "x-ms-lease-id" to
   * release a lease. Possible values include: 'acquire', 'break', 'change',
   * 'renew', 'release'
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.xMsLeaseDuration] The lease duration is required to
   * acquire a lease, and specifies the duration of the lease in seconds.  The
   * lease duration must be between 15 and 60 seconds or -1 for infinite lease.
   *
   * @param {number} [options.xMsLeaseBreakPeriod] The lease break period
   * duration is optional to break a lease, and  specifies the break period of
   * the lease in seconds.  The lease break  duration must be between 0 and 60
   * seconds.
   *
   * @param {string} [options.xMsLeaseId] Required when "x-ms-lease-action" is
   * "renew", "change" or "release". For the renew and release actions, this must
   * match the current lease ID.
   *
   * @param {string} [options.xMsProposedLeaseId] Required when
   * "x-ms-lease-action" is "acquire" or "change".  A lease will be acquired with
   * this lease ID if the operation is successful.
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  lease(xMsLeaseAction, filesystem, path, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._lease(xMsLeaseAction, filesystem, path, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._lease(xMsLeaseAction, filesystem, path, options, optionalCallback);
    }
  }

  /**
   * @summary Read File
   *
   * Read the contents of a file.  For read operations, range requests are
   * supported. This operation supports conditional HTTP requests.  For more
   * information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.range] The HTTP Range request header specifies one
   * or more byte ranges of the resource to be retrieved.
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  readWithHttpOperationResponse(filesystem, path, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._read(filesystem, path, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Read File
   *
   * Read the contents of a file.  For read operations, range requests are
   * supported. This operation supports conditional HTTP requests.  For more
   * information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.range] The HTTP Range request header specifies one
   * or more byte ranges of the resource to be retrieved.
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  read(filesystem, path, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._read(filesystem, path, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._read(filesystem, path, options, optionalCallback);
    }
  }

  /**
   * @summary Get Properties | Get Access Control List
   *
   * Get the properties for a file or directory, and optionally include the
   * access control list.  This operation supports conditional HTTP requests.
   * For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.action] Optional. If the value is
   * "getAccessControl" the access control list is returned in the response
   * headers (Hierarchical Namespace must be enabled for the account). Possible
   * values include: 'getAccessControl'
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPropertiesWithHttpOperationResponse(filesystem, path, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getProperties(filesystem, path, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get Properties | Get Access Control List
   *
   * Get the properties for a file or directory, and optionally include the
   * access control list.  This operation supports conditional HTTP requests.
   * For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.action] Optional. If the value is
   * "getAccessControl" the access control list is returned in the response
   * headers (Hierarchical Namespace must be enabled for the account). Possible
   * values include: 'getAccessControl'
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getProperties(filesystem, path, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getProperties(filesystem, path, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getProperties(filesystem, path, options, optionalCallback);
    }
  }

  /**
   * @summary Delete File | Delete Directory
   *
   * Delete the file or directory. This operation supports conditional HTTP
   * requests.  For more information, see [Specifying Conditional Headers for
   * Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.recursive] Required and valid only when the
   * resource is a directory.  If "true", all paths beneath the directory will be
   * deleted. If "false" and the directory is non-empty, an error occurs.
   *
   * @param {string} [options.continuation] Optional.  When deleting a directory,
   * the number of paths that are deleted with each invocation is limited.  If
   * the number of paths to be deleted exceeds this limit, a continuation token
   * is returned in this response header.  When a continuation token is returned
   * in the response, it must be specified in a subsequent invocation of the
   * delete operation to continue deleting the directory.
   *
   * @param {string} [options.xMsLeaseId] The lease ID must be specified if there
   * is an active lease.
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMethodWithHttpOperationResponse(filesystem, path, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMethod(filesystem, path, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete File | Delete Directory
   *
   * Delete the file or directory. This operation supports conditional HTTP
   * requests.  For more information, see [Specifying Conditional Headers for
   * Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param {string} filesystem The filesystem identifier.
   *
   * @param {string} path The file or directory path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.recursive] Required and valid only when the
   * resource is a directory.  If "true", all paths beneath the directory will be
   * deleted. If "false" and the directory is non-empty, an error occurs.
   *
   * @param {string} [options.continuation] Optional.  When deleting a directory,
   * the number of paths that are deleted with each invocation is limited.  If
   * the number of paths to be deleted exceeds this limit, a continuation token
   * is returned in this response header.  When a continuation token is returned
   * in the response, it must be specified in a subsequent invocation of the
   * delete operation to continue deleting the directory.
   *
   * @param {string} [options.xMsLeaseId] The lease ID must be specified if there
   * is an active lease.
   *
   * @param {string} [options.ifMatch] Optional.  An ETag value. Specify this
   * header to perform the operation only if the resource's ETag matches the
   * value specified. The ETag must be specified in quotes.
   *
   * @param {string} [options.ifNoneMatch] Optional.  An ETag value or the
   * special wildcard ("*") value. Specify this header to perform the operation
   * only if the resource's ETag does not match the value specified. The ETag
   * must be specified in quotes.
   *
   * @param {string} [options.ifModifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has been
   * modified since the specified date and time.
   *
   * @param {string} [options.ifUnmodifiedSince] Optional. A date and time value.
   * Specify this header to perform the operation only if the resource has not
   * been modified since the specified date and time.
   *
   * @param {string} [options.xMsClientRequestId] A UUID recorded in the
   * analytics logs for troubleshooting and correlation.
   *
   * @param {number} [options.timeout] An optional operation timeout value in
   * seconds. The period begins when the request is received by the service. If
   * the timeout value elapses before the operation completes, the operation
   * fails.
   *
   * @param {string} [options.xMsDate] Specifies the Coordinated Universal Time
   * (UTC) for the request.  This is required when using shared key
   * authorization.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(filesystem, path, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMethod(filesystem, path, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMethod(filesystem, path, options, optionalCallback);
    }
  }

}

module.exports = PathOperations;
