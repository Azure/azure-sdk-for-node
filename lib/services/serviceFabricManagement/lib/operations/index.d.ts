/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
*/

import { ServiceClientOptions, RequestOptions, ServiceCallback, HttpOperationResponse } from 'ms-rest';
import * as models from '../models';


/**
 * @class
 * Clusters
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the ServiceFabricManagementClient.
 */
export interface Clusters {


    /**
     * @summary Create a ServiceFabric cluster
     *
     * Create cluster resource
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} cluster The cluster resource.
     *
     * @param {array} [cluster.availableClusterVersions] The Service Fabric runtime
     * versions available for this cluster.
     *
     * @param {string} [cluster.clusterState] Possible values include:
     * 'WaitingForNodes', 'Deploying', 'BaselineUpgrade',
     * 'UpdatingUserConfiguration', 'UpdatingUserCertificate',
     * 'UpdatingInfrastructure', 'EnforcingClusterVersion',
     * 'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
     *
     * @param {string} [cluster.clusterCodeVersion] The Service Fabric runtime
     * version of the cluster. This property can only by set the user when
     * **upgradeMode** is set to 'Manual'. To get list of available Service Fabric
     * versions for new clusters use [ClusterVersion API](./ClusterVersion.md). To
     * get the list of available version for existing clusters use
     * **availableClusterVersions**.
     *
     * @param {object} [cluster.certificate] The certificate to use for securing
     * the cluster. The certificate provided will be used for  node to node
     * security within the cluster, SSL certificate for cluster management endpoint
     * and default  admin client.
     *
     * @param {string} [cluster.reliabilityLevel] Possible values include: 'None',
     * 'Bronze', 'Silver', 'Gold', 'Platinum'
     *
     * @param {string} [cluster.upgradeMode] Possible values include: 'Automatic',
     * 'Manual'
     *
     * @param {array} [cluster.clientCertificateThumbprints] The list of client
     * certificates referenced by thumbprint that are allowed to manage the
     * cluster.
     *
     * @param {array} [cluster.clientCertificateCommonNames] The list of client
     * certificates referenced by common name that are allowed to manage the
     * cluster.
     *
     * @param {array} [cluster.fabricSettings] The list of custom fabric settings
     * to configure the cluster.
     *
     * @param {object} [cluster.reverseProxyCertificate] The server certificate
     * used by reverse proxy.
     *
     * @param {string} cluster.reverseProxyCertificate.thumbprint Thumbprint of the
     * primary certificate.
     *
     * @param {string} [cluster.reverseProxyCertificate.thumbprintSecondary]
     * Thumbprint of the secondary certificate.
     *
     * @param {string} [cluster.reverseProxyCertificate.x509StoreName] The local
     * certificate store location. Possible values include: 'AddressBook',
     * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
     * 'TrustedPeople', 'TrustedPublisher'
     *
     * @param {string} cluster.managementEndpoint The http management endpoint of
     * the cluster.
     *
     * @param {array} cluster.nodeTypes The list of node types in the cluster.
     *
     * @param {object} [cluster.azureActiveDirectory] The AAD authentication
     * settings of the cluster.
     *
     * @param {string} [cluster.azureActiveDirectory.tenantId] Azure active
     * directory tenant id.
     *
     * @param {string} [cluster.azureActiveDirectory.clusterApplication] Azure
     * active directory cluster application id.
     *
     * @param {string} [cluster.azureActiveDirectory.clientApplication] Azure
     * active directory client application id.
     *
     * @param {string} [cluster.vmImage] The VM image VMSS has been configured
     * with. Generic names such as Windows or Linux can be used.
     *
     * @param {object} [cluster.diagnosticsStorageAccountConfig] The storage
     * account information for storing Service Fabric diagnostic logs.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.storageAccountName
     * The Azure storage account name.
     *
     * @param {string}
     * cluster.diagnosticsStorageAccountConfig.protectedAccountKeyName The
     * protected diagnostics storage key name.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.blobEndpoint The
     * blob endpoint of the azure storage account.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.queueEndpoint The
     * queue endpoint of the azure storage account.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.tableEndpoint The
     * table endpoint of the azure storage account.
     *
     * @param {object} [cluster.upgradeDescription] The policy to use when
     * upgrading the cluster.
     *
     * @param {boolean} [cluster.upgradeDescription.forceRestart] If true, then
     * processes are forcefully restarted during upgrade even when the code version
     * has not changed (the upgrade only changes configuration or data).
     *
     * @param {string} cluster.upgradeDescription.upgradeReplicaSetCheckTimeout The
     * maximum amount of time to block processing of an upgrade domain and revent
     * loss of availability when there are unexpected issues. When this timeout
     * expires, processing of the upgrade domain will proceed regardless of
     * availability loss issues. The timeout is reset at the start of each upgrade
     * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckWaitDuration The
     * length of time to wait after completing an upgrade domain before performing
     * health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckStableDuration The
     * amount of time that the application or cluster must remain healthy before
     * the upgrade proceeds to the next upgrade domain. The duration can be in
     * either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckRetryTimeout The
     * amount of time to retry health evaluation when the application or cluster is
     * unhealthy before the upgrade rolls back. The timeout can be in either
     * hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.upgradeTimeout The amount of time
     * the overall upgrade has to complete before the upgrade rolls back. The
     * timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.upgradeDomainTimeout The amount
     * of time each upgrade domain has to complete before the upgrade rolls back.
     * The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {object} cluster.upgradeDescription.healthPolicy The cluster health
     * policy used when upgrading the cluster.
     *
     * @param {number}
     * [cluster.upgradeDescription.healthPolicy.maxPercentUnhealthyNodes] The
     * maximum allowed percentage of unhealthy nodes before reporting an error. For
     * example, to allow 10% of nodes to be unhealthy, this value would be 10.
     *
     * @param {number}
     * [cluster.upgradeDescription.healthPolicy.maxPercentUnhealthyApplications]
     * The maximum allowed percentage of unhealthy applications before reporting an
     * error. For example, to allow 10% of applications to be unhealthy, this value
     * would be 10.
     *
     * @param {object} [cluster.upgradeDescription.deltaHealthPolicy] The delta
     * health policy used when upgrading the cluster.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes
     * The maximum allowed percentage of nodes health degradation allowed during
     * cluster upgrades. The delta is measured between the state of the nodes at
     * the beginning of upgrade and the state of the nodes at the time of the
     * health evaluation. The check is performed after every upgrade domain upgrade
     * completion to make sure the global state of the cluster is within tolerated
     * limits.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes
     * The maximum allowed percentage of upgrade domain nodes health degradation
     * allowed during cluster upgrades. The delta is measured between the state of
     * the upgrade domain nodes at the beginning of upgrade and the state of the
     * upgrade domain nodes at the time of the health evaluation. The check is
     * performed after every upgrade domain upgrade completion for all completed
     * upgrade domains to make sure the state of the upgrade domains is within
     * tolerated limits.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications
     * The maximum allowed percentage of applications health degradation allowed
     * during cluster upgrades. The delta is measured between the state of the
     * applications at the beginning of upgrade and the state of the applications
     * at the time of the health evaluation. The check is performed after every
     * upgrade domain upgrade completion to make sure the global state of the
     * cluster is within tolerated limits. System services are not included in
     * this.
     *
     * @param {array} [cluster.addOnFeatures] The list of add-on features to enable
     * in the cluster.
     *
     * @param {string} cluster.location Resource location.
     *
     * @param {object} [cluster.tags] Resource tags.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Cluster>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(resourceGroupName: string, clusterName: string, cluster: models.Cluster, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Cluster>>;

    /**
     * @summary Create a ServiceFabric cluster
     *
     * Create cluster resource
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} cluster The cluster resource.
     *
     * @param {array} [cluster.availableClusterVersions] The Service Fabric runtime
     * versions available for this cluster.
     *
     * @param {string} [cluster.clusterState] Possible values include:
     * 'WaitingForNodes', 'Deploying', 'BaselineUpgrade',
     * 'UpdatingUserConfiguration', 'UpdatingUserCertificate',
     * 'UpdatingInfrastructure', 'EnforcingClusterVersion',
     * 'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
     *
     * @param {string} [cluster.clusterCodeVersion] The Service Fabric runtime
     * version of the cluster. This property can only by set the user when
     * **upgradeMode** is set to 'Manual'. To get list of available Service Fabric
     * versions for new clusters use [ClusterVersion API](./ClusterVersion.md). To
     * get the list of available version for existing clusters use
     * **availableClusterVersions**.
     *
     * @param {object} [cluster.certificate] The certificate to use for securing
     * the cluster. The certificate provided will be used for  node to node
     * security within the cluster, SSL certificate for cluster management endpoint
     * and default  admin client.
     *
     * @param {string} [cluster.reliabilityLevel] Possible values include: 'None',
     * 'Bronze', 'Silver', 'Gold', 'Platinum'
     *
     * @param {string} [cluster.upgradeMode] Possible values include: 'Automatic',
     * 'Manual'
     *
     * @param {array} [cluster.clientCertificateThumbprints] The list of client
     * certificates referenced by thumbprint that are allowed to manage the
     * cluster.
     *
     * @param {array} [cluster.clientCertificateCommonNames] The list of client
     * certificates referenced by common name that are allowed to manage the
     * cluster.
     *
     * @param {array} [cluster.fabricSettings] The list of custom fabric settings
     * to configure the cluster.
     *
     * @param {object} [cluster.reverseProxyCertificate] The server certificate
     * used by reverse proxy.
     *
     * @param {string} cluster.reverseProxyCertificate.thumbprint Thumbprint of the
     * primary certificate.
     *
     * @param {string} [cluster.reverseProxyCertificate.thumbprintSecondary]
     * Thumbprint of the secondary certificate.
     *
     * @param {string} [cluster.reverseProxyCertificate.x509StoreName] The local
     * certificate store location. Possible values include: 'AddressBook',
     * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
     * 'TrustedPeople', 'TrustedPublisher'
     *
     * @param {string} cluster.managementEndpoint The http management endpoint of
     * the cluster.
     *
     * @param {array} cluster.nodeTypes The list of node types in the cluster.
     *
     * @param {object} [cluster.azureActiveDirectory] The AAD authentication
     * settings of the cluster.
     *
     * @param {string} [cluster.azureActiveDirectory.tenantId] Azure active
     * directory tenant id.
     *
     * @param {string} [cluster.azureActiveDirectory.clusterApplication] Azure
     * active directory cluster application id.
     *
     * @param {string} [cluster.azureActiveDirectory.clientApplication] Azure
     * active directory client application id.
     *
     * @param {string} [cluster.vmImage] The VM image VMSS has been configured
     * with. Generic names such as Windows or Linux can be used.
     *
     * @param {object} [cluster.diagnosticsStorageAccountConfig] The storage
     * account information for storing Service Fabric diagnostic logs.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.storageAccountName
     * The Azure storage account name.
     *
     * @param {string}
     * cluster.diagnosticsStorageAccountConfig.protectedAccountKeyName The
     * protected diagnostics storage key name.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.blobEndpoint The
     * blob endpoint of the azure storage account.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.queueEndpoint The
     * queue endpoint of the azure storage account.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.tableEndpoint The
     * table endpoint of the azure storage account.
     *
     * @param {object} [cluster.upgradeDescription] The policy to use when
     * upgrading the cluster.
     *
     * @param {boolean} [cluster.upgradeDescription.forceRestart] If true, then
     * processes are forcefully restarted during upgrade even when the code version
     * has not changed (the upgrade only changes configuration or data).
     *
     * @param {string} cluster.upgradeDescription.upgradeReplicaSetCheckTimeout The
     * maximum amount of time to block processing of an upgrade domain and revent
     * loss of availability when there are unexpected issues. When this timeout
     * expires, processing of the upgrade domain will proceed regardless of
     * availability loss issues. The timeout is reset at the start of each upgrade
     * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckWaitDuration The
     * length of time to wait after completing an upgrade domain before performing
     * health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckStableDuration The
     * amount of time that the application or cluster must remain healthy before
     * the upgrade proceeds to the next upgrade domain. The duration can be in
     * either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckRetryTimeout The
     * amount of time to retry health evaluation when the application or cluster is
     * unhealthy before the upgrade rolls back. The timeout can be in either
     * hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.upgradeTimeout The amount of time
     * the overall upgrade has to complete before the upgrade rolls back. The
     * timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.upgradeDomainTimeout The amount
     * of time each upgrade domain has to complete before the upgrade rolls back.
     * The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {object} cluster.upgradeDescription.healthPolicy The cluster health
     * policy used when upgrading the cluster.
     *
     * @param {number}
     * [cluster.upgradeDescription.healthPolicy.maxPercentUnhealthyNodes] The
     * maximum allowed percentage of unhealthy nodes before reporting an error. For
     * example, to allow 10% of nodes to be unhealthy, this value would be 10.
     *
     * @param {number}
     * [cluster.upgradeDescription.healthPolicy.maxPercentUnhealthyApplications]
     * The maximum allowed percentage of unhealthy applications before reporting an
     * error. For example, to allow 10% of applications to be unhealthy, this value
     * would be 10.
     *
     * @param {object} [cluster.upgradeDescription.deltaHealthPolicy] The delta
     * health policy used when upgrading the cluster.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes
     * The maximum allowed percentage of nodes health degradation allowed during
     * cluster upgrades. The delta is measured between the state of the nodes at
     * the beginning of upgrade and the state of the nodes at the time of the
     * health evaluation. The check is performed after every upgrade domain upgrade
     * completion to make sure the global state of the cluster is within tolerated
     * limits.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes
     * The maximum allowed percentage of upgrade domain nodes health degradation
     * allowed during cluster upgrades. The delta is measured between the state of
     * the upgrade domain nodes at the beginning of upgrade and the state of the
     * upgrade domain nodes at the time of the health evaluation. The check is
     * performed after every upgrade domain upgrade completion for all completed
     * upgrade domains to make sure the state of the upgrade domains is within
     * tolerated limits.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications
     * The maximum allowed percentage of applications health degradation allowed
     * during cluster upgrades. The delta is measured between the state of the
     * applications at the beginning of upgrade and the state of the applications
     * at the time of the health evaluation. The check is performed after every
     * upgrade domain upgrade completion to make sure the global state of the
     * cluster is within tolerated limits. System services are not included in
     * this.
     *
     * @param {array} [cluster.addOnFeatures] The list of add-on features to enable
     * in the cluster.
     *
     * @param {string} cluster.location Resource location.
     *
     * @param {object} [cluster.tags] Resource tags.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Cluster} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Cluster} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Cluster} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    create(resourceGroupName: string, clusterName: string, cluster: models.Cluster, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.Cluster>;
    create(resourceGroupName: string, clusterName: string, cluster: models.Cluster, callback: ServiceCallback<models.Cluster>): void;
    create(resourceGroupName: string, clusterName: string, cluster: models.Cluster, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Cluster>): void;


    /**
     * @summary Delete cluster resource
     *
     * Delete cluster resource
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(resourceGroupName: string, clusterName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * @summary Delete cluster resource
     *
     * Delete cluster resource
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(resourceGroupName: string, clusterName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(resourceGroupName: string, clusterName: string, callback: ServiceCallback<void>): void;
    deleteMethod(resourceGroupName: string, clusterName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * @summary Get cluster resource
     *
     * Get cluster resource
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Cluster>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(resourceGroupName: string, clusterName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Cluster>>;

    /**
     * @summary Get cluster resource
     *
     * Get cluster resource
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Cluster} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Cluster} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Cluster} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(resourceGroupName: string, clusterName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.Cluster>;
    get(resourceGroupName: string, clusterName: string, callback: ServiceCallback<models.Cluster>): void;
    get(resourceGroupName: string, clusterName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Cluster>): void;


    /**
     * @summary Update cluster configuration
     *
     * Update cluster configuration
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} clusterUpdateParameters The parameters which contains the
     * property value and property name which used to update the cluster
     * configuration.
     *
     * @param {string} [clusterUpdateParameters.reliabilityLevel] The reliability
     * level sets the replica set size of system services. Learn about
     * [ReliabilityLevel](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-capacity).
     * Possible values include: 'Bronze', 'Silver', 'Gold'
     *
     * @param {string} [clusterUpdateParameters.upgradeMode] The upgrade mode of
     * the cluster. This indicates if the cluster should be automatically upgraded
     * when new Service Fabric runtime version is available. Possible values
     * include: 'Automatic', 'Manual'
     *
     * @param {string} [clusterUpdateParameters.clusterCodeVersion] The Service
     * Fabric runtime version of the cluster. This property can only by set the
     * user when **upgradeMode** is set to 'Manual'. To get list of available
     * Service Fabric versions for new clusters use [ClusterVersion
     * API](./ClusterVersion.md). To get the list of available version for existing
     * clusters use **availableClusterVersions**.
     *
     * @param {object} [clusterUpdateParameters.certificate] The certificate to use
     * for securing the cluster. The certificate provided will be used for  node to
     * node security within the cluster, SSL certificate for cluster management
     * endpoint and default  admin client.
     *
     * @param {array} [clusterUpdateParameters.clientCertificateThumbprints] The
     * list of client certificates referenced by thumbprint that are allowed to
     * manage the cluster. This will overwrite the existing list.
     *
     * @param {array} [clusterUpdateParameters.clientCertificateCommonNames] The
     * list of client certificates referenced by common name that are allowed to
     * manage the cluster. This will overwrite the existing list.
     *
     * @param {array} [clusterUpdateParameters.fabricSettings] The list of custom
     * fabric settings to configure the cluster. This will overwrite the existing
     * list.
     *
     * @param {object} [clusterUpdateParameters.reverseProxyCertificate] The server
     * certificate used by reverse proxy.
     *
     * @param {string} clusterUpdateParameters.reverseProxyCertificate.thumbprint
     * Thumbprint of the primary certificate.
     *
     * @param {string}
     * [clusterUpdateParameters.reverseProxyCertificate.thumbprintSecondary]
     * Thumbprint of the secondary certificate.
     *
     * @param {string}
     * [clusterUpdateParameters.reverseProxyCertificate.x509StoreName] The local
     * certificate store location. Possible values include: 'AddressBook',
     * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
     * 'TrustedPeople', 'TrustedPublisher'
     *
     * @param {array} [clusterUpdateParameters.nodeTypes] The list of node types in
     * the cluster. This will overwrite the existing list.
     *
     * @param {object} [clusterUpdateParameters.upgradeDescription] The policy to
     * use when upgrading the cluster.
     *
     * @param {boolean} [clusterUpdateParameters.upgradeDescription.forceRestart]
     * If true, then processes are forcefully restarted during upgrade even when
     * the code version has not changed (the upgrade only changes configuration or
     * data).
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.upgradeReplicaSetCheckTimeout The
     * maximum amount of time to block processing of an upgrade domain and revent
     * loss of availability when there are unexpected issues. When this timeout
     * expires, processing of the upgrade domain will proceed regardless of
     * availability loss issues. The timeout is reset at the start of each upgrade
     * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckWaitDuration The
     * length of time to wait after completing an upgrade domain before performing
     * health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckStableDuration The
     * amount of time that the application or cluster must remain healthy before
     * the upgrade proceeds to the next upgrade domain. The duration can be in
     * either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckRetryTimeout The
     * amount of time to retry health evaluation when the application or cluster is
     * unhealthy before the upgrade rolls back. The timeout can be in either
     * hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} clusterUpdateParameters.upgradeDescription.upgradeTimeout
     * The amount of time the overall upgrade has to complete before the upgrade
     * rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.upgradeDomainTimeout The amount
     * of time each upgrade domain has to complete before the upgrade rolls back.
     * The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {object} clusterUpdateParameters.upgradeDescription.healthPolicy The
     * cluster health policy used when upgrading the cluster.
     *
     * @param {number}
     * [clusterUpdateParameters.upgradeDescription.healthPolicy.maxPercentUnhealthyNodes]
     * The maximum allowed percentage of unhealthy nodes before reporting an error.
     * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
     *
     * @param {number}
     * [clusterUpdateParameters.upgradeDescription.healthPolicy.maxPercentUnhealthyApplications]
     * The maximum allowed percentage of unhealthy applications before reporting an
     * error. For example, to allow 10% of applications to be unhealthy, this value
     * would be 10.
     *
     * @param {object}
     * [clusterUpdateParameters.upgradeDescription.deltaHealthPolicy] The delta
     * health policy used when upgrading the cluster.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes
     * The maximum allowed percentage of nodes health degradation allowed during
     * cluster upgrades. The delta is measured between the state of the nodes at
     * the beginning of upgrade and the state of the nodes at the time of the
     * health evaluation. The check is performed after every upgrade domain upgrade
     * completion to make sure the global state of the cluster is within tolerated
     * limits.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes
     * The maximum allowed percentage of upgrade domain nodes health degradation
     * allowed during cluster upgrades. The delta is measured between the state of
     * the upgrade domain nodes at the beginning of upgrade and the state of the
     * upgrade domain nodes at the time of the health evaluation. The check is
     * performed after every upgrade domain upgrade completion for all completed
     * upgrade domains to make sure the state of the upgrade domains is within
     * tolerated limits.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications
     * The maximum allowed percentage of applications health degradation allowed
     * during cluster upgrades. The delta is measured between the state of the
     * applications at the beginning of upgrade and the state of the applications
     * at the time of the health evaluation. The check is performed after every
     * upgrade domain upgrade completion to make sure the global state of the
     * cluster is within tolerated limits. System services are not included in
     * this.
     *
     * @param {array} [clusterUpdateParameters.addOnFeatures] The list of add-on
     * features to enable in the cluster.
     *
     * @param {object} [clusterUpdateParameters.tags] Cluster update parameters
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Cluster>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(resourceGroupName: string, clusterName: string, clusterUpdateParameters: models.ClusterUpdateParameters, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Cluster>>;

    /**
     * @summary Update cluster configuration
     *
     * Update cluster configuration
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} clusterUpdateParameters The parameters which contains the
     * property value and property name which used to update the cluster
     * configuration.
     *
     * @param {string} [clusterUpdateParameters.reliabilityLevel] The reliability
     * level sets the replica set size of system services. Learn about
     * [ReliabilityLevel](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-capacity).
     * Possible values include: 'Bronze', 'Silver', 'Gold'
     *
     * @param {string} [clusterUpdateParameters.upgradeMode] The upgrade mode of
     * the cluster. This indicates if the cluster should be automatically upgraded
     * when new Service Fabric runtime version is available. Possible values
     * include: 'Automatic', 'Manual'
     *
     * @param {string} [clusterUpdateParameters.clusterCodeVersion] The Service
     * Fabric runtime version of the cluster. This property can only by set the
     * user when **upgradeMode** is set to 'Manual'. To get list of available
     * Service Fabric versions for new clusters use [ClusterVersion
     * API](./ClusterVersion.md). To get the list of available version for existing
     * clusters use **availableClusterVersions**.
     *
     * @param {object} [clusterUpdateParameters.certificate] The certificate to use
     * for securing the cluster. The certificate provided will be used for  node to
     * node security within the cluster, SSL certificate for cluster management
     * endpoint and default  admin client.
     *
     * @param {array} [clusterUpdateParameters.clientCertificateThumbprints] The
     * list of client certificates referenced by thumbprint that are allowed to
     * manage the cluster. This will overwrite the existing list.
     *
     * @param {array} [clusterUpdateParameters.clientCertificateCommonNames] The
     * list of client certificates referenced by common name that are allowed to
     * manage the cluster. This will overwrite the existing list.
     *
     * @param {array} [clusterUpdateParameters.fabricSettings] The list of custom
     * fabric settings to configure the cluster. This will overwrite the existing
     * list.
     *
     * @param {object} [clusterUpdateParameters.reverseProxyCertificate] The server
     * certificate used by reverse proxy.
     *
     * @param {string} clusterUpdateParameters.reverseProxyCertificate.thumbprint
     * Thumbprint of the primary certificate.
     *
     * @param {string}
     * [clusterUpdateParameters.reverseProxyCertificate.thumbprintSecondary]
     * Thumbprint of the secondary certificate.
     *
     * @param {string}
     * [clusterUpdateParameters.reverseProxyCertificate.x509StoreName] The local
     * certificate store location. Possible values include: 'AddressBook',
     * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
     * 'TrustedPeople', 'TrustedPublisher'
     *
     * @param {array} [clusterUpdateParameters.nodeTypes] The list of node types in
     * the cluster. This will overwrite the existing list.
     *
     * @param {object} [clusterUpdateParameters.upgradeDescription] The policy to
     * use when upgrading the cluster.
     *
     * @param {boolean} [clusterUpdateParameters.upgradeDescription.forceRestart]
     * If true, then processes are forcefully restarted during upgrade even when
     * the code version has not changed (the upgrade only changes configuration or
     * data).
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.upgradeReplicaSetCheckTimeout The
     * maximum amount of time to block processing of an upgrade domain and revent
     * loss of availability when there are unexpected issues. When this timeout
     * expires, processing of the upgrade domain will proceed regardless of
     * availability loss issues. The timeout is reset at the start of each upgrade
     * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckWaitDuration The
     * length of time to wait after completing an upgrade domain before performing
     * health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckStableDuration The
     * amount of time that the application or cluster must remain healthy before
     * the upgrade proceeds to the next upgrade domain. The duration can be in
     * either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckRetryTimeout The
     * amount of time to retry health evaluation when the application or cluster is
     * unhealthy before the upgrade rolls back. The timeout can be in either
     * hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} clusterUpdateParameters.upgradeDescription.upgradeTimeout
     * The amount of time the overall upgrade has to complete before the upgrade
     * rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.upgradeDomainTimeout The amount
     * of time each upgrade domain has to complete before the upgrade rolls back.
     * The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {object} clusterUpdateParameters.upgradeDescription.healthPolicy The
     * cluster health policy used when upgrading the cluster.
     *
     * @param {number}
     * [clusterUpdateParameters.upgradeDescription.healthPolicy.maxPercentUnhealthyNodes]
     * The maximum allowed percentage of unhealthy nodes before reporting an error.
     * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
     *
     * @param {number}
     * [clusterUpdateParameters.upgradeDescription.healthPolicy.maxPercentUnhealthyApplications]
     * The maximum allowed percentage of unhealthy applications before reporting an
     * error. For example, to allow 10% of applications to be unhealthy, this value
     * would be 10.
     *
     * @param {object}
     * [clusterUpdateParameters.upgradeDescription.deltaHealthPolicy] The delta
     * health policy used when upgrading the cluster.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes
     * The maximum allowed percentage of nodes health degradation allowed during
     * cluster upgrades. The delta is measured between the state of the nodes at
     * the beginning of upgrade and the state of the nodes at the time of the
     * health evaluation. The check is performed after every upgrade domain upgrade
     * completion to make sure the global state of the cluster is within tolerated
     * limits.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes
     * The maximum allowed percentage of upgrade domain nodes health degradation
     * allowed during cluster upgrades. The delta is measured between the state of
     * the upgrade domain nodes at the beginning of upgrade and the state of the
     * upgrade domain nodes at the time of the health evaluation. The check is
     * performed after every upgrade domain upgrade completion for all completed
     * upgrade domains to make sure the state of the upgrade domains is within
     * tolerated limits.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications
     * The maximum allowed percentage of applications health degradation allowed
     * during cluster upgrades. The delta is measured between the state of the
     * applications at the beginning of upgrade and the state of the applications
     * at the time of the health evaluation. The check is performed after every
     * upgrade domain upgrade completion to make sure the global state of the
     * cluster is within tolerated limits. System services are not included in
     * this.
     *
     * @param {array} [clusterUpdateParameters.addOnFeatures] The list of add-on
     * features to enable in the cluster.
     *
     * @param {object} [clusterUpdateParameters.tags] Cluster update parameters
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Cluster} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Cluster} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Cluster} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    update(resourceGroupName: string, clusterName: string, clusterUpdateParameters: models.ClusterUpdateParameters, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.Cluster>;
    update(resourceGroupName: string, clusterName: string, clusterUpdateParameters: models.ClusterUpdateParameters, callback: ServiceCallback<models.Cluster>): void;
    update(resourceGroupName: string, clusterName: string, clusterUpdateParameters: models.ClusterUpdateParameters, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Cluster>): void;


    /**
     * @summary List cluster resource by resource group
     *
     * List cluster resource by resource group
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ClusterListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listByResourceGroupWithHttpOperationResponse(resourceGroupName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterListResult>>;

    /**
     * @summary List cluster resource by resource group
     *
     * List cluster resource by resource group
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ClusterListResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ClusterListResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ClusterListResult} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    listByResourceGroup(resourceGroupName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterListResult>;
    listByResourceGroup(resourceGroupName: string, callback: ServiceCallback<models.ClusterListResult>): void;
    listByResourceGroup(resourceGroupName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterListResult>): void;


    /**
     * @summary List cluster resource
     *
     * List cluster resource
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ClusterListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterListResult>>;

    /**
     * @summary List cluster resource
     *
     * List cluster resource
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ClusterListResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ClusterListResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ClusterListResult} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterListResult>;
    list(callback: ServiceCallback<models.ClusterListResult>): void;
    list(options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterListResult>): void;


    /**
     * @summary Create a ServiceFabric cluster
     *
     * Create cluster resource
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} cluster The cluster resource.
     *
     * @param {array} [cluster.availableClusterVersions] The Service Fabric runtime
     * versions available for this cluster.
     *
     * @param {string} [cluster.clusterState] Possible values include:
     * 'WaitingForNodes', 'Deploying', 'BaselineUpgrade',
     * 'UpdatingUserConfiguration', 'UpdatingUserCertificate',
     * 'UpdatingInfrastructure', 'EnforcingClusterVersion',
     * 'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
     *
     * @param {string} [cluster.clusterCodeVersion] The Service Fabric runtime
     * version of the cluster. This property can only by set the user when
     * **upgradeMode** is set to 'Manual'. To get list of available Service Fabric
     * versions for new clusters use [ClusterVersion API](./ClusterVersion.md). To
     * get the list of available version for existing clusters use
     * **availableClusterVersions**.
     *
     * @param {object} [cluster.certificate] The certificate to use for securing
     * the cluster. The certificate provided will be used for  node to node
     * security within the cluster, SSL certificate for cluster management endpoint
     * and default  admin client.
     *
     * @param {string} [cluster.reliabilityLevel] Possible values include: 'None',
     * 'Bronze', 'Silver', 'Gold', 'Platinum'
     *
     * @param {string} [cluster.upgradeMode] Possible values include: 'Automatic',
     * 'Manual'
     *
     * @param {array} [cluster.clientCertificateThumbprints] The list of client
     * certificates referenced by thumbprint that are allowed to manage the
     * cluster.
     *
     * @param {array} [cluster.clientCertificateCommonNames] The list of client
     * certificates referenced by common name that are allowed to manage the
     * cluster.
     *
     * @param {array} [cluster.fabricSettings] The list of custom fabric settings
     * to configure the cluster.
     *
     * @param {object} [cluster.reverseProxyCertificate] The server certificate
     * used by reverse proxy.
     *
     * @param {string} cluster.reverseProxyCertificate.thumbprint Thumbprint of the
     * primary certificate.
     *
     * @param {string} [cluster.reverseProxyCertificate.thumbprintSecondary]
     * Thumbprint of the secondary certificate.
     *
     * @param {string} [cluster.reverseProxyCertificate.x509StoreName] The local
     * certificate store location. Possible values include: 'AddressBook',
     * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
     * 'TrustedPeople', 'TrustedPublisher'
     *
     * @param {string} cluster.managementEndpoint The http management endpoint of
     * the cluster.
     *
     * @param {array} cluster.nodeTypes The list of node types in the cluster.
     *
     * @param {object} [cluster.azureActiveDirectory] The AAD authentication
     * settings of the cluster.
     *
     * @param {string} [cluster.azureActiveDirectory.tenantId] Azure active
     * directory tenant id.
     *
     * @param {string} [cluster.azureActiveDirectory.clusterApplication] Azure
     * active directory cluster application id.
     *
     * @param {string} [cluster.azureActiveDirectory.clientApplication] Azure
     * active directory client application id.
     *
     * @param {string} [cluster.vmImage] The VM image VMSS has been configured
     * with. Generic names such as Windows or Linux can be used.
     *
     * @param {object} [cluster.diagnosticsStorageAccountConfig] The storage
     * account information for storing Service Fabric diagnostic logs.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.storageAccountName
     * The Azure storage account name.
     *
     * @param {string}
     * cluster.diagnosticsStorageAccountConfig.protectedAccountKeyName The
     * protected diagnostics storage key name.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.blobEndpoint The
     * blob endpoint of the azure storage account.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.queueEndpoint The
     * queue endpoint of the azure storage account.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.tableEndpoint The
     * table endpoint of the azure storage account.
     *
     * @param {object} [cluster.upgradeDescription] The policy to use when
     * upgrading the cluster.
     *
     * @param {boolean} [cluster.upgradeDescription.forceRestart] If true, then
     * processes are forcefully restarted during upgrade even when the code version
     * has not changed (the upgrade only changes configuration or data).
     *
     * @param {string} cluster.upgradeDescription.upgradeReplicaSetCheckTimeout The
     * maximum amount of time to block processing of an upgrade domain and revent
     * loss of availability when there are unexpected issues. When this timeout
     * expires, processing of the upgrade domain will proceed regardless of
     * availability loss issues. The timeout is reset at the start of each upgrade
     * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckWaitDuration The
     * length of time to wait after completing an upgrade domain before performing
     * health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckStableDuration The
     * amount of time that the application or cluster must remain healthy before
     * the upgrade proceeds to the next upgrade domain. The duration can be in
     * either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckRetryTimeout The
     * amount of time to retry health evaluation when the application or cluster is
     * unhealthy before the upgrade rolls back. The timeout can be in either
     * hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.upgradeTimeout The amount of time
     * the overall upgrade has to complete before the upgrade rolls back. The
     * timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.upgradeDomainTimeout The amount
     * of time each upgrade domain has to complete before the upgrade rolls back.
     * The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {object} cluster.upgradeDescription.healthPolicy The cluster health
     * policy used when upgrading the cluster.
     *
     * @param {number}
     * [cluster.upgradeDescription.healthPolicy.maxPercentUnhealthyNodes] The
     * maximum allowed percentage of unhealthy nodes before reporting an error. For
     * example, to allow 10% of nodes to be unhealthy, this value would be 10.
     *
     * @param {number}
     * [cluster.upgradeDescription.healthPolicy.maxPercentUnhealthyApplications]
     * The maximum allowed percentage of unhealthy applications before reporting an
     * error. For example, to allow 10% of applications to be unhealthy, this value
     * would be 10.
     *
     * @param {object} [cluster.upgradeDescription.deltaHealthPolicy] The delta
     * health policy used when upgrading the cluster.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes
     * The maximum allowed percentage of nodes health degradation allowed during
     * cluster upgrades. The delta is measured between the state of the nodes at
     * the beginning of upgrade and the state of the nodes at the time of the
     * health evaluation. The check is performed after every upgrade domain upgrade
     * completion to make sure the global state of the cluster is within tolerated
     * limits.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes
     * The maximum allowed percentage of upgrade domain nodes health degradation
     * allowed during cluster upgrades. The delta is measured between the state of
     * the upgrade domain nodes at the beginning of upgrade and the state of the
     * upgrade domain nodes at the time of the health evaluation. The check is
     * performed after every upgrade domain upgrade completion for all completed
     * upgrade domains to make sure the state of the upgrade domains is within
     * tolerated limits.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications
     * The maximum allowed percentage of applications health degradation allowed
     * during cluster upgrades. The delta is measured between the state of the
     * applications at the beginning of upgrade and the state of the applications
     * at the time of the health evaluation. The check is performed after every
     * upgrade domain upgrade completion to make sure the global state of the
     * cluster is within tolerated limits. System services are not included in
     * this.
     *
     * @param {array} [cluster.addOnFeatures] The list of add-on features to enable
     * in the cluster.
     *
     * @param {string} cluster.location Resource location.
     *
     * @param {object} [cluster.tags] Resource tags.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Cluster>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    beginCreateWithHttpOperationResponse(resourceGroupName: string, clusterName: string, cluster: models.Cluster, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Cluster>>;

    /**
     * @summary Create a ServiceFabric cluster
     *
     * Create cluster resource
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} cluster The cluster resource.
     *
     * @param {array} [cluster.availableClusterVersions] The Service Fabric runtime
     * versions available for this cluster.
     *
     * @param {string} [cluster.clusterState] Possible values include:
     * 'WaitingForNodes', 'Deploying', 'BaselineUpgrade',
     * 'UpdatingUserConfiguration', 'UpdatingUserCertificate',
     * 'UpdatingInfrastructure', 'EnforcingClusterVersion',
     * 'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
     *
     * @param {string} [cluster.clusterCodeVersion] The Service Fabric runtime
     * version of the cluster. This property can only by set the user when
     * **upgradeMode** is set to 'Manual'. To get list of available Service Fabric
     * versions for new clusters use [ClusterVersion API](./ClusterVersion.md). To
     * get the list of available version for existing clusters use
     * **availableClusterVersions**.
     *
     * @param {object} [cluster.certificate] The certificate to use for securing
     * the cluster. The certificate provided will be used for  node to node
     * security within the cluster, SSL certificate for cluster management endpoint
     * and default  admin client.
     *
     * @param {string} [cluster.reliabilityLevel] Possible values include: 'None',
     * 'Bronze', 'Silver', 'Gold', 'Platinum'
     *
     * @param {string} [cluster.upgradeMode] Possible values include: 'Automatic',
     * 'Manual'
     *
     * @param {array} [cluster.clientCertificateThumbprints] The list of client
     * certificates referenced by thumbprint that are allowed to manage the
     * cluster.
     *
     * @param {array} [cluster.clientCertificateCommonNames] The list of client
     * certificates referenced by common name that are allowed to manage the
     * cluster.
     *
     * @param {array} [cluster.fabricSettings] The list of custom fabric settings
     * to configure the cluster.
     *
     * @param {object} [cluster.reverseProxyCertificate] The server certificate
     * used by reverse proxy.
     *
     * @param {string} cluster.reverseProxyCertificate.thumbprint Thumbprint of the
     * primary certificate.
     *
     * @param {string} [cluster.reverseProxyCertificate.thumbprintSecondary]
     * Thumbprint of the secondary certificate.
     *
     * @param {string} [cluster.reverseProxyCertificate.x509StoreName] The local
     * certificate store location. Possible values include: 'AddressBook',
     * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
     * 'TrustedPeople', 'TrustedPublisher'
     *
     * @param {string} cluster.managementEndpoint The http management endpoint of
     * the cluster.
     *
     * @param {array} cluster.nodeTypes The list of node types in the cluster.
     *
     * @param {object} [cluster.azureActiveDirectory] The AAD authentication
     * settings of the cluster.
     *
     * @param {string} [cluster.azureActiveDirectory.tenantId] Azure active
     * directory tenant id.
     *
     * @param {string} [cluster.azureActiveDirectory.clusterApplication] Azure
     * active directory cluster application id.
     *
     * @param {string} [cluster.azureActiveDirectory.clientApplication] Azure
     * active directory client application id.
     *
     * @param {string} [cluster.vmImage] The VM image VMSS has been configured
     * with. Generic names such as Windows or Linux can be used.
     *
     * @param {object} [cluster.diagnosticsStorageAccountConfig] The storage
     * account information for storing Service Fabric diagnostic logs.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.storageAccountName
     * The Azure storage account name.
     *
     * @param {string}
     * cluster.diagnosticsStorageAccountConfig.protectedAccountKeyName The
     * protected diagnostics storage key name.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.blobEndpoint The
     * blob endpoint of the azure storage account.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.queueEndpoint The
     * queue endpoint of the azure storage account.
     *
     * @param {string} cluster.diagnosticsStorageAccountConfig.tableEndpoint The
     * table endpoint of the azure storage account.
     *
     * @param {object} [cluster.upgradeDescription] The policy to use when
     * upgrading the cluster.
     *
     * @param {boolean} [cluster.upgradeDescription.forceRestart] If true, then
     * processes are forcefully restarted during upgrade even when the code version
     * has not changed (the upgrade only changes configuration or data).
     *
     * @param {string} cluster.upgradeDescription.upgradeReplicaSetCheckTimeout The
     * maximum amount of time to block processing of an upgrade domain and revent
     * loss of availability when there are unexpected issues. When this timeout
     * expires, processing of the upgrade domain will proceed regardless of
     * availability loss issues. The timeout is reset at the start of each upgrade
     * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckWaitDuration The
     * length of time to wait after completing an upgrade domain before performing
     * health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckStableDuration The
     * amount of time that the application or cluster must remain healthy before
     * the upgrade proceeds to the next upgrade domain. The duration can be in
     * either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.healthCheckRetryTimeout The
     * amount of time to retry health evaluation when the application or cluster is
     * unhealthy before the upgrade rolls back. The timeout can be in either
     * hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.upgradeTimeout The amount of time
     * the overall upgrade has to complete before the upgrade rolls back. The
     * timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} cluster.upgradeDescription.upgradeDomainTimeout The amount
     * of time each upgrade domain has to complete before the upgrade rolls back.
     * The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {object} cluster.upgradeDescription.healthPolicy The cluster health
     * policy used when upgrading the cluster.
     *
     * @param {number}
     * [cluster.upgradeDescription.healthPolicy.maxPercentUnhealthyNodes] The
     * maximum allowed percentage of unhealthy nodes before reporting an error. For
     * example, to allow 10% of nodes to be unhealthy, this value would be 10.
     *
     * @param {number}
     * [cluster.upgradeDescription.healthPolicy.maxPercentUnhealthyApplications]
     * The maximum allowed percentage of unhealthy applications before reporting an
     * error. For example, to allow 10% of applications to be unhealthy, this value
     * would be 10.
     *
     * @param {object} [cluster.upgradeDescription.deltaHealthPolicy] The delta
     * health policy used when upgrading the cluster.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes
     * The maximum allowed percentage of nodes health degradation allowed during
     * cluster upgrades. The delta is measured between the state of the nodes at
     * the beginning of upgrade and the state of the nodes at the time of the
     * health evaluation. The check is performed after every upgrade domain upgrade
     * completion to make sure the global state of the cluster is within tolerated
     * limits.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes
     * The maximum allowed percentage of upgrade domain nodes health degradation
     * allowed during cluster upgrades. The delta is measured between the state of
     * the upgrade domain nodes at the beginning of upgrade and the state of the
     * upgrade domain nodes at the time of the health evaluation. The check is
     * performed after every upgrade domain upgrade completion for all completed
     * upgrade domains to make sure the state of the upgrade domains is within
     * tolerated limits.
     *
     * @param {number}
     * cluster.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications
     * The maximum allowed percentage of applications health degradation allowed
     * during cluster upgrades. The delta is measured between the state of the
     * applications at the beginning of upgrade and the state of the applications
     * at the time of the health evaluation. The check is performed after every
     * upgrade domain upgrade completion to make sure the global state of the
     * cluster is within tolerated limits. System services are not included in
     * this.
     *
     * @param {array} [cluster.addOnFeatures] The list of add-on features to enable
     * in the cluster.
     *
     * @param {string} cluster.location Resource location.
     *
     * @param {object} [cluster.tags] Resource tags.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Cluster} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Cluster} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Cluster} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    beginCreate(resourceGroupName: string, clusterName: string, cluster: models.Cluster, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.Cluster>;
    beginCreate(resourceGroupName: string, clusterName: string, cluster: models.Cluster, callback: ServiceCallback<models.Cluster>): void;
    beginCreate(resourceGroupName: string, clusterName: string, cluster: models.Cluster, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Cluster>): void;


    /**
     * @summary Update cluster configuration
     *
     * Update cluster configuration
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} clusterUpdateParameters The parameters which contains the
     * property value and property name which used to update the cluster
     * configuration.
     *
     * @param {string} [clusterUpdateParameters.reliabilityLevel] The reliability
     * level sets the replica set size of system services. Learn about
     * [ReliabilityLevel](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-capacity).
     * Possible values include: 'Bronze', 'Silver', 'Gold'
     *
     * @param {string} [clusterUpdateParameters.upgradeMode] The upgrade mode of
     * the cluster. This indicates if the cluster should be automatically upgraded
     * when new Service Fabric runtime version is available. Possible values
     * include: 'Automatic', 'Manual'
     *
     * @param {string} [clusterUpdateParameters.clusterCodeVersion] The Service
     * Fabric runtime version of the cluster. This property can only by set the
     * user when **upgradeMode** is set to 'Manual'. To get list of available
     * Service Fabric versions for new clusters use [ClusterVersion
     * API](./ClusterVersion.md). To get the list of available version for existing
     * clusters use **availableClusterVersions**.
     *
     * @param {object} [clusterUpdateParameters.certificate] The certificate to use
     * for securing the cluster. The certificate provided will be used for  node to
     * node security within the cluster, SSL certificate for cluster management
     * endpoint and default  admin client.
     *
     * @param {array} [clusterUpdateParameters.clientCertificateThumbprints] The
     * list of client certificates referenced by thumbprint that are allowed to
     * manage the cluster. This will overwrite the existing list.
     *
     * @param {array} [clusterUpdateParameters.clientCertificateCommonNames] The
     * list of client certificates referenced by common name that are allowed to
     * manage the cluster. This will overwrite the existing list.
     *
     * @param {array} [clusterUpdateParameters.fabricSettings] The list of custom
     * fabric settings to configure the cluster. This will overwrite the existing
     * list.
     *
     * @param {object} [clusterUpdateParameters.reverseProxyCertificate] The server
     * certificate used by reverse proxy.
     *
     * @param {string} clusterUpdateParameters.reverseProxyCertificate.thumbprint
     * Thumbprint of the primary certificate.
     *
     * @param {string}
     * [clusterUpdateParameters.reverseProxyCertificate.thumbprintSecondary]
     * Thumbprint of the secondary certificate.
     *
     * @param {string}
     * [clusterUpdateParameters.reverseProxyCertificate.x509StoreName] The local
     * certificate store location. Possible values include: 'AddressBook',
     * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
     * 'TrustedPeople', 'TrustedPublisher'
     *
     * @param {array} [clusterUpdateParameters.nodeTypes] The list of node types in
     * the cluster. This will overwrite the existing list.
     *
     * @param {object} [clusterUpdateParameters.upgradeDescription] The policy to
     * use when upgrading the cluster.
     *
     * @param {boolean} [clusterUpdateParameters.upgradeDescription.forceRestart]
     * If true, then processes are forcefully restarted during upgrade even when
     * the code version has not changed (the upgrade only changes configuration or
     * data).
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.upgradeReplicaSetCheckTimeout The
     * maximum amount of time to block processing of an upgrade domain and revent
     * loss of availability when there are unexpected issues. When this timeout
     * expires, processing of the upgrade domain will proceed regardless of
     * availability loss issues. The timeout is reset at the start of each upgrade
     * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckWaitDuration The
     * length of time to wait after completing an upgrade domain before performing
     * health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckStableDuration The
     * amount of time that the application or cluster must remain healthy before
     * the upgrade proceeds to the next upgrade domain. The duration can be in
     * either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckRetryTimeout The
     * amount of time to retry health evaluation when the application or cluster is
     * unhealthy before the upgrade rolls back. The timeout can be in either
     * hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} clusterUpdateParameters.upgradeDescription.upgradeTimeout
     * The amount of time the overall upgrade has to complete before the upgrade
     * rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.upgradeDomainTimeout The amount
     * of time each upgrade domain has to complete before the upgrade rolls back.
     * The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {object} clusterUpdateParameters.upgradeDescription.healthPolicy The
     * cluster health policy used when upgrading the cluster.
     *
     * @param {number}
     * [clusterUpdateParameters.upgradeDescription.healthPolicy.maxPercentUnhealthyNodes]
     * The maximum allowed percentage of unhealthy nodes before reporting an error.
     * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
     *
     * @param {number}
     * [clusterUpdateParameters.upgradeDescription.healthPolicy.maxPercentUnhealthyApplications]
     * The maximum allowed percentage of unhealthy applications before reporting an
     * error. For example, to allow 10% of applications to be unhealthy, this value
     * would be 10.
     *
     * @param {object}
     * [clusterUpdateParameters.upgradeDescription.deltaHealthPolicy] The delta
     * health policy used when upgrading the cluster.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes
     * The maximum allowed percentage of nodes health degradation allowed during
     * cluster upgrades. The delta is measured between the state of the nodes at
     * the beginning of upgrade and the state of the nodes at the time of the
     * health evaluation. The check is performed after every upgrade domain upgrade
     * completion to make sure the global state of the cluster is within tolerated
     * limits.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes
     * The maximum allowed percentage of upgrade domain nodes health degradation
     * allowed during cluster upgrades. The delta is measured between the state of
     * the upgrade domain nodes at the beginning of upgrade and the state of the
     * upgrade domain nodes at the time of the health evaluation. The check is
     * performed after every upgrade domain upgrade completion for all completed
     * upgrade domains to make sure the state of the upgrade domains is within
     * tolerated limits.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications
     * The maximum allowed percentage of applications health degradation allowed
     * during cluster upgrades. The delta is measured between the state of the
     * applications at the beginning of upgrade and the state of the applications
     * at the time of the health evaluation. The check is performed after every
     * upgrade domain upgrade completion to make sure the global state of the
     * cluster is within tolerated limits. System services are not included in
     * this.
     *
     * @param {array} [clusterUpdateParameters.addOnFeatures] The list of add-on
     * features to enable in the cluster.
     *
     * @param {object} [clusterUpdateParameters.tags] Cluster update parameters
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Cluster>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    beginUpdateWithHttpOperationResponse(resourceGroupName: string, clusterName: string, clusterUpdateParameters: models.ClusterUpdateParameters, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Cluster>>;

    /**
     * @summary Update cluster configuration
     *
     * Update cluster configuration
     *
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} clusterUpdateParameters The parameters which contains the
     * property value and property name which used to update the cluster
     * configuration.
     *
     * @param {string} [clusterUpdateParameters.reliabilityLevel] The reliability
     * level sets the replica set size of system services. Learn about
     * [ReliabilityLevel](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-capacity).
     * Possible values include: 'Bronze', 'Silver', 'Gold'
     *
     * @param {string} [clusterUpdateParameters.upgradeMode] The upgrade mode of
     * the cluster. This indicates if the cluster should be automatically upgraded
     * when new Service Fabric runtime version is available. Possible values
     * include: 'Automatic', 'Manual'
     *
     * @param {string} [clusterUpdateParameters.clusterCodeVersion] The Service
     * Fabric runtime version of the cluster. This property can only by set the
     * user when **upgradeMode** is set to 'Manual'. To get list of available
     * Service Fabric versions for new clusters use [ClusterVersion
     * API](./ClusterVersion.md). To get the list of available version for existing
     * clusters use **availableClusterVersions**.
     *
     * @param {object} [clusterUpdateParameters.certificate] The certificate to use
     * for securing the cluster. The certificate provided will be used for  node to
     * node security within the cluster, SSL certificate for cluster management
     * endpoint and default  admin client.
     *
     * @param {array} [clusterUpdateParameters.clientCertificateThumbprints] The
     * list of client certificates referenced by thumbprint that are allowed to
     * manage the cluster. This will overwrite the existing list.
     *
     * @param {array} [clusterUpdateParameters.clientCertificateCommonNames] The
     * list of client certificates referenced by common name that are allowed to
     * manage the cluster. This will overwrite the existing list.
     *
     * @param {array} [clusterUpdateParameters.fabricSettings] The list of custom
     * fabric settings to configure the cluster. This will overwrite the existing
     * list.
     *
     * @param {object} [clusterUpdateParameters.reverseProxyCertificate] The server
     * certificate used by reverse proxy.
     *
     * @param {string} clusterUpdateParameters.reverseProxyCertificate.thumbprint
     * Thumbprint of the primary certificate.
     *
     * @param {string}
     * [clusterUpdateParameters.reverseProxyCertificate.thumbprintSecondary]
     * Thumbprint of the secondary certificate.
     *
     * @param {string}
     * [clusterUpdateParameters.reverseProxyCertificate.x509StoreName] The local
     * certificate store location. Possible values include: 'AddressBook',
     * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
     * 'TrustedPeople', 'TrustedPublisher'
     *
     * @param {array} [clusterUpdateParameters.nodeTypes] The list of node types in
     * the cluster. This will overwrite the existing list.
     *
     * @param {object} [clusterUpdateParameters.upgradeDescription] The policy to
     * use when upgrading the cluster.
     *
     * @param {boolean} [clusterUpdateParameters.upgradeDescription.forceRestart]
     * If true, then processes are forcefully restarted during upgrade even when
     * the code version has not changed (the upgrade only changes configuration or
     * data).
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.upgradeReplicaSetCheckTimeout The
     * maximum amount of time to block processing of an upgrade domain and revent
     * loss of availability when there are unexpected issues. When this timeout
     * expires, processing of the upgrade domain will proceed regardless of
     * availability loss issues. The timeout is reset at the start of each upgrade
     * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckWaitDuration The
     * length of time to wait after completing an upgrade domain before performing
     * health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckStableDuration The
     * amount of time that the application or cluster must remain healthy before
     * the upgrade proceeds to the next upgrade domain. The duration can be in
     * either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.healthCheckRetryTimeout The
     * amount of time to retry health evaluation when the application or cluster is
     * unhealthy before the upgrade rolls back. The timeout can be in either
     * hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {string} clusterUpdateParameters.upgradeDescription.upgradeTimeout
     * The amount of time the overall upgrade has to complete before the upgrade
     * rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
     * format.
     *
     * @param {string}
     * clusterUpdateParameters.upgradeDescription.upgradeDomainTimeout The amount
     * of time each upgrade domain has to complete before the upgrade rolls back.
     * The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     *
     * @param {object} clusterUpdateParameters.upgradeDescription.healthPolicy The
     * cluster health policy used when upgrading the cluster.
     *
     * @param {number}
     * [clusterUpdateParameters.upgradeDescription.healthPolicy.maxPercentUnhealthyNodes]
     * The maximum allowed percentage of unhealthy nodes before reporting an error.
     * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
     *
     * @param {number}
     * [clusterUpdateParameters.upgradeDescription.healthPolicy.maxPercentUnhealthyApplications]
     * The maximum allowed percentage of unhealthy applications before reporting an
     * error. For example, to allow 10% of applications to be unhealthy, this value
     * would be 10.
     *
     * @param {object}
     * [clusterUpdateParameters.upgradeDescription.deltaHealthPolicy] The delta
     * health policy used when upgrading the cluster.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes
     * The maximum allowed percentage of nodes health degradation allowed during
     * cluster upgrades. The delta is measured between the state of the nodes at
     * the beginning of upgrade and the state of the nodes at the time of the
     * health evaluation. The check is performed after every upgrade domain upgrade
     * completion to make sure the global state of the cluster is within tolerated
     * limits.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes
     * The maximum allowed percentage of upgrade domain nodes health degradation
     * allowed during cluster upgrades. The delta is measured between the state of
     * the upgrade domain nodes at the beginning of upgrade and the state of the
     * upgrade domain nodes at the time of the health evaluation. The check is
     * performed after every upgrade domain upgrade completion for all completed
     * upgrade domains to make sure the state of the upgrade domains is within
     * tolerated limits.
     *
     * @param {number}
     * clusterUpdateParameters.upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications
     * The maximum allowed percentage of applications health degradation allowed
     * during cluster upgrades. The delta is measured between the state of the
     * applications at the beginning of upgrade and the state of the applications
     * at the time of the health evaluation. The check is performed after every
     * upgrade domain upgrade completion to make sure the global state of the
     * cluster is within tolerated limits. System services are not included in
     * this.
     *
     * @param {array} [clusterUpdateParameters.addOnFeatures] The list of add-on
     * features to enable in the cluster.
     *
     * @param {object} [clusterUpdateParameters.tags] Cluster update parameters
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Cluster} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Cluster} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Cluster} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    beginUpdate(resourceGroupName: string, clusterName: string, clusterUpdateParameters: models.ClusterUpdateParameters, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.Cluster>;
    beginUpdate(resourceGroupName: string, clusterName: string, clusterUpdateParameters: models.ClusterUpdateParameters, callback: ServiceCallback<models.Cluster>): void;
    beginUpdate(resourceGroupName: string, clusterName: string, clusterUpdateParameters: models.ClusterUpdateParameters, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Cluster>): void;
}

/**
 * @class
 * ClusterVersions
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the ServiceFabricManagementClient.
 */
export interface ClusterVersions {


    /**
     * @summary Get cluster code versions
     *
     * Get cluster code versions by location
     *
     *
     * @param {string} location The location for the cluster code versions, this is
     * different from cluster location
     *
     * @param {string} clusterVersion The cluster code version
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ClusterCodeVersionsListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(location: string, clusterVersion: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterCodeVersionsListResult>>;

    /**
     * @summary Get cluster code versions
     *
     * Get cluster code versions by location
     *
     *
     * @param {string} location The location for the cluster code versions, this is
     * different from cluster location
     *
     * @param {string} clusterVersion The cluster code version
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ClusterCodeVersionsListResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ClusterCodeVersionsListResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ClusterCodeVersionsListResult} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(location: string, clusterVersion: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterCodeVersionsListResult>;
    get(location: string, clusterVersion: string, callback: ServiceCallback<models.ClusterCodeVersionsListResult>): void;
    get(location: string, clusterVersion: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterCodeVersionsListResult>): void;


    /**
     * @summary Get cluster code versions by environment
     *
     * Get cluster code versions by environment
     *
     *
     * @param {string} location The location for the cluster code versions, this is
     * different from cluster location
     *
     * @param {string} environment Cluster operating system, the default means all.
     * Possible values include: 'Windows', 'Linux'
     *
     * @param {string} clusterVersion The cluster code version
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ClusterCodeVersionsListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getByEnvironmentWithHttpOperationResponse(location: string, environment: string, clusterVersion: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterCodeVersionsListResult>>;

    /**
     * @summary Get cluster code versions by environment
     *
     * Get cluster code versions by environment
     *
     *
     * @param {string} location The location for the cluster code versions, this is
     * different from cluster location
     *
     * @param {string} environment Cluster operating system, the default means all.
     * Possible values include: 'Windows', 'Linux'
     *
     * @param {string} clusterVersion The cluster code version
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ClusterCodeVersionsListResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ClusterCodeVersionsListResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ClusterCodeVersionsListResult} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    getByEnvironment(location: string, environment: string, clusterVersion: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterCodeVersionsListResult>;
    getByEnvironment(location: string, environment: string, clusterVersion: string, callback: ServiceCallback<models.ClusterCodeVersionsListResult>): void;
    getByEnvironment(location: string, environment: string, clusterVersion: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterCodeVersionsListResult>): void;


    /**
     * @summary List cluster code versions by location
     *
     * List cluster code versions by location
     *
     *
     * @param {string} location The location for the cluster code versions, this is
     * different from cluster location
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ClusterCodeVersionsListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(location: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterCodeVersionsListResult>>;

    /**
     * @summary List cluster code versions by location
     *
     * List cluster code versions by location
     *
     *
     * @param {string} location The location for the cluster code versions, this is
     * different from cluster location
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ClusterCodeVersionsListResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ClusterCodeVersionsListResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ClusterCodeVersionsListResult} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(location: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterCodeVersionsListResult>;
    list(location: string, callback: ServiceCallback<models.ClusterCodeVersionsListResult>): void;
    list(location: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterCodeVersionsListResult>): void;


    /**
     * @summary List cluster code versions by environment
     *
     * List cluster code versions by environment
     *
     *
     * @param {string} location The location for the cluster code versions, this is
     * different from cluster location
     *
     * @param {string} environment Cluster operating system, the default means all.
     * Possible values include: 'Windows', 'Linux'
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ClusterCodeVersionsListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listByEnvironmentWithHttpOperationResponse(location: string, environment: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterCodeVersionsListResult>>;

    /**
     * @summary List cluster code versions by environment
     *
     * List cluster code versions by environment
     *
     *
     * @param {string} location The location for the cluster code versions, this is
     * different from cluster location
     *
     * @param {string} environment Cluster operating system, the default means all.
     * Possible values include: 'Windows', 'Linux'
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ClusterCodeVersionsListResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ClusterCodeVersionsListResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ClusterCodeVersionsListResult} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    listByEnvironment(location: string, environment: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterCodeVersionsListResult>;
    listByEnvironment(location: string, environment: string, callback: ServiceCallback<models.ClusterCodeVersionsListResult>): void;
    listByEnvironment(location: string, environment: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterCodeVersionsListResult>): void;
}

/**
 * @class
 * Operations
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the ServiceFabricManagementClient.
 */
export interface Operations {


    /**
     * @summary Lists all of the available ServiceFabric Resource Manager REST API
     * operations.
     *
     * @param {string} apiVersion The version of the ServiceFabric resouce provider
     * api
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<OperationListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(apiVersion: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.OperationListResult>>;

    /**
     * @summary Lists all of the available ServiceFabric Resource Manager REST API
     * operations.
     *
     * @param {string} apiVersion The version of the ServiceFabric resouce provider
     * api
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {OperationListResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {OperationListResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link OperationListResult} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(apiVersion: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.OperationListResult>;
    list(apiVersion: string, callback: ServiceCallback<models.OperationListResult>): void;
    list(apiVersion: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.OperationListResult>): void;


    /**
     * @summary Lists all of the available ServiceFabric Resource Manager REST API
     * operations.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<OperationListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.OperationListResult>>;

    /**
     * @summary Lists all of the available ServiceFabric Resource Manager REST API
     * operations.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {OperationListResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {OperationListResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link OperationListResult} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    listNext(nextPageLink: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.OperationListResult>;
    listNext(nextPageLink: string, callback: ServiceCallback<models.OperationListResult>): void;
    listNext(nextPageLink: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.OperationListResult>): void;
}

/**
 * @class
 * ApplicationType
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the ServiceFabricManagementClient.
 */
export interface ApplicationType {


    /**
     * Returns an application type name resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationTypeResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationTypeResource>>;

    /**
     * Returns an application type name resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ApplicationTypeResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ApplicationTypeResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ApplicationTypeResource} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationTypeResource>;
    get(resourceGroupName: string, clusterName: string, applicationTypeName: string, callback: ServiceCallback<models.ApplicationTypeResource>): void;
    get(resourceGroupName: string, clusterName: string, applicationTypeName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationTypeResource>): void;


    /**
     * Creates the application type name resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} parameters The application type name resource.
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationTypeResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    putWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: models.ApplicationTypeResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationTypeResource>>;

    /**
     * Creates the application type name resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} parameters The application type name resource.
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ApplicationTypeResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ApplicationTypeResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ApplicationTypeResource} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    put(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: models.ApplicationTypeResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationTypeResource>;
    put(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: models.ApplicationTypeResource, callback: ServiceCallback<models.ApplicationTypeResource>): void;
    put(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: models.ApplicationTypeResource, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationTypeResource>): void;


    /**
     * Updates the application type name resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} parameters The application type name resource for patch
     * operations.
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationTypeResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: models.ApplicationTypeResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationTypeResource>>;

    /**
     * Updates the application type name resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} parameters The application type name resource for patch
     * operations.
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ApplicationTypeResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ApplicationTypeResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ApplicationTypeResource} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    patch(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: models.ApplicationTypeResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationTypeResource>;
    patch(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: models.ApplicationTypeResource, callback: ServiceCallback<models.ApplicationTypeResource>): void;
    patch(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: models.ApplicationTypeResource, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationTypeResource>): void;


    /**
     * Deletes the application type name resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Deletes the application type name resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(resourceGroupName: string, clusterName: string, applicationTypeName: string, callback: ServiceCallback<void>): void;
    deleteMethod(resourceGroupName: string, clusterName: string, applicationTypeName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Returns all application type names in the specified cluster.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationTypeResourceList>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(resourceGroupName: string, clusterName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationTypeResourceList>>;

    /**
     * Returns all application type names in the specified cluster.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ApplicationTypeResourceList} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ApplicationTypeResourceList} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ApplicationTypeResourceList} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(resourceGroupName: string, clusterName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationTypeResourceList>;
    list(resourceGroupName: string, clusterName: string, callback: ServiceCallback<models.ApplicationTypeResourceList>): void;
    list(resourceGroupName: string, clusterName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationTypeResourceList>): void;
}

/**
 * @class
 * Version
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the ServiceFabricManagementClient.
 */
export interface Version {


    /**
     * Returns an application type version resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {string} version The application type version.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<VersionResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.VersionResource>>;

    /**
     * Returns an application type version resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {string} version The application type version.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {VersionResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {VersionResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link VersionResource} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.VersionResource>;
    get(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, callback: ServiceCallback<models.VersionResource>): void;
    get(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.VersionResource>): void;


    /**
     * Provisions an application type version resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {string} version The application type version.
     *
     * @param {object} parameters The application type version resource.
     *
     * @param {string} [parameters.appPackageUrl] The URL to the application
     * package
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<VersionResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    putWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: models.VersionResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.VersionResource>>;

    /**
     * Provisions an application type version resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {string} version The application type version.
     *
     * @param {object} parameters The application type version resource.
     *
     * @param {string} [parameters.appPackageUrl] The URL to the application
     * package
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {VersionResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {VersionResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link VersionResource} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    put(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: models.VersionResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.VersionResource>;
    put(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: models.VersionResource, callback: ServiceCallback<models.VersionResource>): void;
    put(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: models.VersionResource, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.VersionResource>): void;


    /**
     * Updates an application type version resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {string} version The application type version.
     *
     * @param {object} parameters The application type version resource for patch
     * operations.
     *
     * @param {string} [parameters.appPackageUrl] The URL to the application
     * package
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<VersionResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: models.VersionResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.VersionResource>>;

    /**
     * Updates an application type version resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {string} version The application type version.
     *
     * @param {object} parameters The application type version resource for patch
     * operations.
     *
     * @param {string} [parameters.appPackageUrl] The URL to the application
     * package
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {VersionResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {VersionResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link VersionResource} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    patch(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: models.VersionResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.VersionResource>;
    patch(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: models.VersionResource, callback: ServiceCallback<models.VersionResource>): void;
    patch(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: models.VersionResource, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.VersionResource>): void;


    /**
     * Unprovisions an application type version resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {string} version The application type version.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Unprovisions an application type version resource.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {string} version The application type version.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, callback: ServiceCallback<void>): void;
    deleteMethod(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Returns all versions for the specified application type.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<VersionResourceList>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.VersionResourceList>>;

    /**
     * Returns all versions for the specified application type.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationTypeName The name of the application type name
     * resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {VersionResourceList} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {VersionResourceList} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link VersionResourceList} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.VersionResourceList>;
    list(resourceGroupName: string, clusterName: string, applicationTypeName: string, callback: ServiceCallback<models.VersionResourceList>): void;
    list(resourceGroupName: string, clusterName: string, applicationTypeName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.VersionResourceList>): void;
}

/**
 * @class
 * Application
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the ServiceFabricManagementClient.
 */
export interface Application {


    /**
     * Returns an application resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationResource>>;

    /**
     * Returns an application resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ApplicationResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ApplicationResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ApplicationResource} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(resourceGroupName: string, clusterName: string, applicationName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationResource>;
    get(resourceGroupName: string, clusterName: string, applicationName: string, callback: ServiceCallback<models.ApplicationResource>): void;
    get(resourceGroupName: string, clusterName: string, applicationName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationResource>): void;


    /**
     * Creates or updates an application resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} parameters The application resource.
     *
     * @param {string} [parameters.typeVersion]
     *
     * @param {array} [parameters.parameters]
     *
     * @param {object} [parameters.upgradePolicy]
     *
     * @param {number} [parameters.upgradePolicy.upgradeReplicaSetCheckTimeout]
     *
     * @param {boolean} [parameters.upgradePolicy.forceRestart]
     *
     * @param {object} [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckWaitDuration]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckStableDuration]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckRetryTimeout]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeTimeout]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeDomainTimeout]
     *
     * @param {object} [parameters.upgradePolicy.applicationHealthPolicy]
     *
     * @param {boolean}
     * [parameters.upgradePolicy.applicationHealthPolicy.considerWarningAsError]
     * Indicates whether warnings are treated with the same severity as errors.
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
     * The maximum allowed percentage of unhealthy deployed applications. Allowed
     * values are Byte values from zero to 100.
     * The percentage represents the maximum tolerated percentage of deployed
     * applications that can be unhealthy before the application is considered in
     * error.
     * This is calculated by dividing the number of unhealthy deployed applications
     * over the number of nodes where the application is currently deployed on in
     * the cluster.
     * The computation rounds up to tolerate one failure on small numbers of nodes.
     * Default percentage is zero.
     *
     *
     * @param {object}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
     * The maximum allowed percentage of unhealthy partitions per service. Allowed
     * values are Byte values from zero to 100
     *
     * The percentage represents the maximum tolerated percentage of partitions
     * that can be unhealthy before the service is considered in error.
     * If the percentage is respected but there is at least one unhealthy
     * partition, the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy partitions
     * over the total number of partitions in the service.
     * The computation rounds up to tolerate one failure on small numbers of
     * partitions. Default percentage is zero.
     *
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
     * The maximum allowed percentage of unhealthy replicas per partition. Allowed
     * values are Byte values from zero to 100.
     *
     * The percentage represents the maximum tolerated percentage of replicas that
     * can be unhealthy before the partition is considered in error.
     * If the percentage is respected but there is at least one unhealthy replica,
     * the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy replicas
     * over the total number of replicas in the partition.
     * The computation rounds up to tolerate one failure on small numbers of
     * replicas. Default percentage is zero.
     *
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
     * The maximum maximum allowed percentage of unhealthy services. Allowed values
     * are Byte values from zero to 100.
     *
     * The percentage represents the maximum tolerated percentage of services that
     * can be unhealthy before the application is considered in error.
     * If the percentage is respected but there is at least one unhealthy service,
     * the health is evaluated as Warning.
     * This is calculated by dividing the number of unhealthy services of the
     * specific service type over the total number of services of the specific
     * service type.
     * The computation rounds up to tolerate one failure on small numbers of
     * services. Default percentage is zero.
     *
     *
     * @param {array}
     * [parameters.upgradePolicy.applicationHealthPolicy.serviceTypeHealthPolicyMap]
     *
     * @param {number} [parameters.minimumNodes] The minimum number of nodes where
     * Service Fabric will reserve capacity for this application. Note that this
     * does not mean that the services of this application will be placed on all of
     * those nodes. If this property is set to zero, no capacity will be reserved.
     * The value of this property cannot be more than the value of the MaximumNodes
     * property.
     *
     * @param {number} [parameters.maximumNodes] The maximum number of nodes where
     * Service Fabric will reserve capacity for this application. Note that this
     * does not mean that the services of this application will be placed on all of
     * those nodes. By default, the value of this property is zero and it means
     * that the services can be placed on any node.
     *
     * @param {boolean} [parameters.removeApplicationCapacity] The version of the
     * application type
     *
     * @param {array} [parameters.metrics]
     *
     * @param {string} [parameters.typeName]
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    putWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationName: string, parameters: models.ApplicationResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationResource>>;

    /**
     * Creates or updates an application resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} parameters The application resource.
     *
     * @param {string} [parameters.typeVersion]
     *
     * @param {array} [parameters.parameters]
     *
     * @param {object} [parameters.upgradePolicy]
     *
     * @param {number} [parameters.upgradePolicy.upgradeReplicaSetCheckTimeout]
     *
     * @param {boolean} [parameters.upgradePolicy.forceRestart]
     *
     * @param {object} [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckWaitDuration]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckStableDuration]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckRetryTimeout]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeTimeout]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeDomainTimeout]
     *
     * @param {object} [parameters.upgradePolicy.applicationHealthPolicy]
     *
     * @param {boolean}
     * [parameters.upgradePolicy.applicationHealthPolicy.considerWarningAsError]
     * Indicates whether warnings are treated with the same severity as errors.
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
     * The maximum allowed percentage of unhealthy deployed applications. Allowed
     * values are Byte values from zero to 100.
     * The percentage represents the maximum tolerated percentage of deployed
     * applications that can be unhealthy before the application is considered in
     * error.
     * This is calculated by dividing the number of unhealthy deployed applications
     * over the number of nodes where the application is currently deployed on in
     * the cluster.
     * The computation rounds up to tolerate one failure on small numbers of nodes.
     * Default percentage is zero.
     *
     *
     * @param {object}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
     * The maximum allowed percentage of unhealthy partitions per service. Allowed
     * values are Byte values from zero to 100
     *
     * The percentage represents the maximum tolerated percentage of partitions
     * that can be unhealthy before the service is considered in error.
     * If the percentage is respected but there is at least one unhealthy
     * partition, the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy partitions
     * over the total number of partitions in the service.
     * The computation rounds up to tolerate one failure on small numbers of
     * partitions. Default percentage is zero.
     *
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
     * The maximum allowed percentage of unhealthy replicas per partition. Allowed
     * values are Byte values from zero to 100.
     *
     * The percentage represents the maximum tolerated percentage of replicas that
     * can be unhealthy before the partition is considered in error.
     * If the percentage is respected but there is at least one unhealthy replica,
     * the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy replicas
     * over the total number of replicas in the partition.
     * The computation rounds up to tolerate one failure on small numbers of
     * replicas. Default percentage is zero.
     *
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
     * The maximum maximum allowed percentage of unhealthy services. Allowed values
     * are Byte values from zero to 100.
     *
     * The percentage represents the maximum tolerated percentage of services that
     * can be unhealthy before the application is considered in error.
     * If the percentage is respected but there is at least one unhealthy service,
     * the health is evaluated as Warning.
     * This is calculated by dividing the number of unhealthy services of the
     * specific service type over the total number of services of the specific
     * service type.
     * The computation rounds up to tolerate one failure on small numbers of
     * services. Default percentage is zero.
     *
     *
     * @param {array}
     * [parameters.upgradePolicy.applicationHealthPolicy.serviceTypeHealthPolicyMap]
     *
     * @param {number} [parameters.minimumNodes] The minimum number of nodes where
     * Service Fabric will reserve capacity for this application. Note that this
     * does not mean that the services of this application will be placed on all of
     * those nodes. If this property is set to zero, no capacity will be reserved.
     * The value of this property cannot be more than the value of the MaximumNodes
     * property.
     *
     * @param {number} [parameters.maximumNodes] The maximum number of nodes where
     * Service Fabric will reserve capacity for this application. Note that this
     * does not mean that the services of this application will be placed on all of
     * those nodes. By default, the value of this property is zero and it means
     * that the services can be placed on any node.
     *
     * @param {boolean} [parameters.removeApplicationCapacity] The version of the
     * application type
     *
     * @param {array} [parameters.metrics]
     *
     * @param {string} [parameters.typeName]
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ApplicationResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ApplicationResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ApplicationResource} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    put(resourceGroupName: string, clusterName: string, applicationName: string, parameters: models.ApplicationResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationResource>;
    put(resourceGroupName: string, clusterName: string, applicationName: string, parameters: models.ApplicationResource, callback: ServiceCallback<models.ApplicationResource>): void;
    put(resourceGroupName: string, clusterName: string, applicationName: string, parameters: models.ApplicationResource, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationResource>): void;


    /**
     * Updates an application resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} parameters The application resource for patch operations.
     *
     * @param {string} [parameters.typeVersion]
     *
     * @param {array} [parameters.parameters]
     *
     * @param {object} [parameters.upgradePolicy]
     *
     * @param {number} [parameters.upgradePolicy.upgradeReplicaSetCheckTimeout]
     *
     * @param {boolean} [parameters.upgradePolicy.forceRestart]
     *
     * @param {object} [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckWaitDuration]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckStableDuration]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckRetryTimeout]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeTimeout]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeDomainTimeout]
     *
     * @param {object} [parameters.upgradePolicy.applicationHealthPolicy]
     *
     * @param {boolean}
     * [parameters.upgradePolicy.applicationHealthPolicy.considerWarningAsError]
     * Indicates whether warnings are treated with the same severity as errors.
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
     * The maximum allowed percentage of unhealthy deployed applications. Allowed
     * values are Byte values from zero to 100.
     * The percentage represents the maximum tolerated percentage of deployed
     * applications that can be unhealthy before the application is considered in
     * error.
     * This is calculated by dividing the number of unhealthy deployed applications
     * over the number of nodes where the application is currently deployed on in
     * the cluster.
     * The computation rounds up to tolerate one failure on small numbers of nodes.
     * Default percentage is zero.
     *
     *
     * @param {object}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
     * The maximum allowed percentage of unhealthy partitions per service. Allowed
     * values are Byte values from zero to 100
     *
     * The percentage represents the maximum tolerated percentage of partitions
     * that can be unhealthy before the service is considered in error.
     * If the percentage is respected but there is at least one unhealthy
     * partition, the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy partitions
     * over the total number of partitions in the service.
     * The computation rounds up to tolerate one failure on small numbers of
     * partitions. Default percentage is zero.
     *
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
     * The maximum allowed percentage of unhealthy replicas per partition. Allowed
     * values are Byte values from zero to 100.
     *
     * The percentage represents the maximum tolerated percentage of replicas that
     * can be unhealthy before the partition is considered in error.
     * If the percentage is respected but there is at least one unhealthy replica,
     * the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy replicas
     * over the total number of replicas in the partition.
     * The computation rounds up to tolerate one failure on small numbers of
     * replicas. Default percentage is zero.
     *
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
     * The maximum maximum allowed percentage of unhealthy services. Allowed values
     * are Byte values from zero to 100.
     *
     * The percentage represents the maximum tolerated percentage of services that
     * can be unhealthy before the application is considered in error.
     * If the percentage is respected but there is at least one unhealthy service,
     * the health is evaluated as Warning.
     * This is calculated by dividing the number of unhealthy services of the
     * specific service type over the total number of services of the specific
     * service type.
     * The computation rounds up to tolerate one failure on small numbers of
     * services. Default percentage is zero.
     *
     *
     * @param {array}
     * [parameters.upgradePolicy.applicationHealthPolicy.serviceTypeHealthPolicyMap]
     *
     * @param {number} [parameters.minimumNodes] The minimum number of nodes where
     * Service Fabric will reserve capacity for this application. Note that this
     * does not mean that the services of this application will be placed on all of
     * those nodes. If this property is set to zero, no capacity will be reserved.
     * The value of this property cannot be more than the value of the MaximumNodes
     * property.
     *
     * @param {number} [parameters.maximumNodes] The maximum number of nodes where
     * Service Fabric will reserve capacity for this application. Note that this
     * does not mean that the services of this application will be placed on all of
     * those nodes. By default, the value of this property is zero and it means
     * that the services can be placed on any node.
     *
     * @param {boolean} [parameters.removeApplicationCapacity] The version of the
     * application type
     *
     * @param {array} [parameters.metrics]
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationResourceUpdate>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationName: string, parameters: models.ApplicationResourceUpdate, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationResourceUpdate>>;

    /**
     * Updates an application resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} parameters The application resource for patch operations.
     *
     * @param {string} [parameters.typeVersion]
     *
     * @param {array} [parameters.parameters]
     *
     * @param {object} [parameters.upgradePolicy]
     *
     * @param {number} [parameters.upgradePolicy.upgradeReplicaSetCheckTimeout]
     *
     * @param {boolean} [parameters.upgradePolicy.forceRestart]
     *
     * @param {object} [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckWaitDuration]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckStableDuration]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckRetryTimeout]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeTimeout]
     *
     * @param {string}
     * [parameters.upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeDomainTimeout]
     *
     * @param {object} [parameters.upgradePolicy.applicationHealthPolicy]
     *
     * @param {boolean}
     * [parameters.upgradePolicy.applicationHealthPolicy.considerWarningAsError]
     * Indicates whether warnings are treated with the same severity as errors.
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
     * The maximum allowed percentage of unhealthy deployed applications. Allowed
     * values are Byte values from zero to 100.
     * The percentage represents the maximum tolerated percentage of deployed
     * applications that can be unhealthy before the application is considered in
     * error.
     * This is calculated by dividing the number of unhealthy deployed applications
     * over the number of nodes where the application is currently deployed on in
     * the cluster.
     * The computation rounds up to tolerate one failure on small numbers of nodes.
     * Default percentage is zero.
     *
     *
     * @param {object}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
     * The maximum allowed percentage of unhealthy partitions per service. Allowed
     * values are Byte values from zero to 100
     *
     * The percentage represents the maximum tolerated percentage of partitions
     * that can be unhealthy before the service is considered in error.
     * If the percentage is respected but there is at least one unhealthy
     * partition, the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy partitions
     * over the total number of partitions in the service.
     * The computation rounds up to tolerate one failure on small numbers of
     * partitions. Default percentage is zero.
     *
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
     * The maximum allowed percentage of unhealthy replicas per partition. Allowed
     * values are Byte values from zero to 100.
     *
     * The percentage represents the maximum tolerated percentage of replicas that
     * can be unhealthy before the partition is considered in error.
     * If the percentage is respected but there is at least one unhealthy replica,
     * the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy replicas
     * over the total number of replicas in the partition.
     * The computation rounds up to tolerate one failure on small numbers of
     * replicas. Default percentage is zero.
     *
     *
     * @param {number}
     * [parameters.upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
     * The maximum maximum allowed percentage of unhealthy services. Allowed values
     * are Byte values from zero to 100.
     *
     * The percentage represents the maximum tolerated percentage of services that
     * can be unhealthy before the application is considered in error.
     * If the percentage is respected but there is at least one unhealthy service,
     * the health is evaluated as Warning.
     * This is calculated by dividing the number of unhealthy services of the
     * specific service type over the total number of services of the specific
     * service type.
     * The computation rounds up to tolerate one failure on small numbers of
     * services. Default percentage is zero.
     *
     *
     * @param {array}
     * [parameters.upgradePolicy.applicationHealthPolicy.serviceTypeHealthPolicyMap]
     *
     * @param {number} [parameters.minimumNodes] The minimum number of nodes where
     * Service Fabric will reserve capacity for this application. Note that this
     * does not mean that the services of this application will be placed on all of
     * those nodes. If this property is set to zero, no capacity will be reserved.
     * The value of this property cannot be more than the value of the MaximumNodes
     * property.
     *
     * @param {number} [parameters.maximumNodes] The maximum number of nodes where
     * Service Fabric will reserve capacity for this application. Note that this
     * does not mean that the services of this application will be placed on all of
     * those nodes. By default, the value of this property is zero and it means
     * that the services can be placed on any node.
     *
     * @param {boolean} [parameters.removeApplicationCapacity] The version of the
     * application type
     *
     * @param {array} [parameters.metrics]
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ApplicationResourceUpdate} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ApplicationResourceUpdate} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ApplicationResourceUpdate} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    patch(resourceGroupName: string, clusterName: string, applicationName: string, parameters: models.ApplicationResourceUpdate, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationResourceUpdate>;
    patch(resourceGroupName: string, clusterName: string, applicationName: string, parameters: models.ApplicationResourceUpdate, callback: ServiceCallback<models.ApplicationResourceUpdate>): void;
    patch(resourceGroupName: string, clusterName: string, applicationName: string, parameters: models.ApplicationResourceUpdate, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationResourceUpdate>): void;


    /**
     * Deletes an application resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Deletes an application resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(resourceGroupName: string, clusterName: string, applicationName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(resourceGroupName: string, clusterName: string, applicationName: string, callback: ServiceCallback<void>): void;
    deleteMethod(resourceGroupName: string, clusterName: string, applicationName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Returns all application resources in the specified cluster.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationResourceList>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(resourceGroupName: string, clusterName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationResourceList>>;

    /**
     * Returns all application resources in the specified cluster.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ApplicationResourceList} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ApplicationResourceList} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ApplicationResourceList} for more
     *                      information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(resourceGroupName: string, clusterName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationResourceList>;
    list(resourceGroupName: string, clusterName: string, callback: ServiceCallback<models.ApplicationResourceList>): void;
    list(resourceGroupName: string, clusterName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationResourceList>): void;
}

/**
 * @class
 * Service
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the ServiceFabricManagementClient.
 */
export interface Service {


    /**
     * Returns a service resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {string} serviceName The name of the service resource in the format
     * of {applicationName}~{serviceName}.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ServiceResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceResource>>;

    /**
     * Returns a service resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {string} serviceName The name of the service resource in the format
     * of {applicationName}~{serviceName}.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ServiceResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ServiceResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ServiceResource} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceResource>;
    get(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, callback: ServiceCallback<models.ServiceResource>): void;
    get(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceResource>): void;


    /**
     * Creates or updates a service resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {string} serviceName The name of the service resource in the format
     * of {applicationName}~{serviceName}.
     *
     * @param {object} parameters The service resource.
     *
     * @param {string} [parameters.placementConstraints] The placement constraints
     * as a string. Placement constraints are boolean expressions on node
     * properties and allow for restricting a service to particular nodes based on
     * the service requirements. For example, to place a service on nodes where
     * NodeType is blue specify the following: "NodeColor == blue)".
     *
     * @param {array} [parameters.correlationScheme]
     *
     * @param {array} [parameters.serviceLoadMetrics]
     *
     * @param {array} [parameters.servicePlacementPolicies]
     *
     * @param {string} [parameters.defaultMoveCost] Possible values include:
     * 'Zero', 'Low', 'Medium', 'High'
     *
     * @param {string} [parameters.serviceKind] Possible values include: 'Invalid',
     * 'Stateless', 'Stateful'
     *
     * @param {string} [parameters.serviceTypeName] The name of the service type
     *
     * @param {object} [parameters.partitionDescription]
     *
     * @param {string} parameters.partitionDescription.partitionScheme Polymorphic
     * Discriminator
     *
     * @param {string} parameters.serviceResourceType Polymorphic Discriminator
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ServiceResource>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    putWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: models.ServiceResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceResource>>;

    /**
     * Creates or updates a service resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {string} serviceName The name of the service resource in the format
     * of {applicationName}~{serviceName}.
     *
     * @param {object} parameters The service resource.
     *
     * @param {string} [parameters.placementConstraints] The placement constraints
     * as a string. Placement constraints are boolean expressions on node
     * properties and allow for restricting a service to particular nodes based on
     * the service requirements. For example, to place a service on nodes where
     * NodeType is blue specify the following: "NodeColor == blue)".
     *
     * @param {array} [parameters.correlationScheme]
     *
     * @param {array} [parameters.serviceLoadMetrics]
     *
     * @param {array} [parameters.servicePlacementPolicies]
     *
     * @param {string} [parameters.defaultMoveCost] Possible values include:
     * 'Zero', 'Low', 'Medium', 'High'
     *
     * @param {string} [parameters.serviceKind] Possible values include: 'Invalid',
     * 'Stateless', 'Stateful'
     *
     * @param {string} [parameters.serviceTypeName] The name of the service type
     *
     * @param {object} [parameters.partitionDescription]
     *
     * @param {string} parameters.partitionDescription.partitionScheme Polymorphic
     * Discriminator
     *
     * @param {string} parameters.serviceResourceType Polymorphic Discriminator
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ServiceResource} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ServiceResource} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ServiceResource} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    put(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: models.ServiceResource, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceResource>;
    put(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: models.ServiceResource, callback: ServiceCallback<models.ServiceResource>): void;
    put(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: models.ServiceResource, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceResource>): void;


    /**
     * Updates a service resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {string} serviceName The name of the service resource in the format
     * of {applicationName}~{serviceName}.
     *
     * @param {object} parameters The service resource for patch operations.
     *
     * @param {string} [parameters.placementConstraints] The placement constraints
     * as a string. Placement constraints are boolean expressions on node
     * properties and allow for restricting a service to particular nodes based on
     * the service requirements. For example, to place a service on nodes where
     * NodeType is blue specify the following: "NodeColor == blue)".
     *
     * @param {array} [parameters.correlationScheme]
     *
     * @param {array} [parameters.serviceLoadMetrics]
     *
     * @param {array} [parameters.servicePlacementPolicies]
     *
     * @param {string} [parameters.defaultMoveCost] Possible values include:
     * 'Zero', 'Low', 'Medium', 'High'
     *
     * @param {string} parameters.serviceResourceType Polymorphic Discriminator
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ServiceResourceUpdate>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: models.ServiceResourceUpdate, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceResourceUpdate>>;

    /**
     * Updates a service resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {string} serviceName The name of the service resource in the format
     * of {applicationName}~{serviceName}.
     *
     * @param {object} parameters The service resource for patch operations.
     *
     * @param {string} [parameters.placementConstraints] The placement constraints
     * as a string. Placement constraints are boolean expressions on node
     * properties and allow for restricting a service to particular nodes based on
     * the service requirements. For example, to place a service on nodes where
     * NodeType is blue specify the following: "NodeColor == blue)".
     *
     * @param {array} [parameters.correlationScheme]
     *
     * @param {array} [parameters.serviceLoadMetrics]
     *
     * @param {array} [parameters.servicePlacementPolicies]
     *
     * @param {string} [parameters.defaultMoveCost] Possible values include:
     * 'Zero', 'Low', 'Medium', 'High'
     *
     * @param {string} parameters.serviceResourceType Polymorphic Discriminator
     *
     * @param {string} parameters.location Resource location.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ServiceResourceUpdate} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ServiceResourceUpdate} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ServiceResourceUpdate} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    patch(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: models.ServiceResourceUpdate, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceResourceUpdate>;
    patch(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: models.ServiceResourceUpdate, callback: ServiceCallback<models.ServiceResourceUpdate>): void;
    patch(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: models.ServiceResourceUpdate, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceResourceUpdate>): void;


    /**
     * Deletes a service resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {string} serviceName The name of the service resource in the format
     * of {applicationName}~{serviceName}.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Deletes a service resource with the specified name.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {string} serviceName The name of the service resource in the format
     * of {applicationName}~{serviceName}.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, callback: ServiceCallback<void>): void;
    deleteMethod(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Returns all service resources in the specified application.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ServiceResourceList>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(resourceGroupName: string, clusterName: string, applicationName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceResourceList>>;

    /**
     * Returns all service resources in the specified application.
     *
     * @param {string} resourceGroupName The name of the resource group.
     *
     * @param {string} clusterName The name of the cluster resource
     *
     * @param {string} applicationName The name of the application resource.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {ServiceResourceList} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {ServiceResourceList} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link ServiceResourceList} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(resourceGroupName: string, clusterName: string, applicationName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceResourceList>;
    list(resourceGroupName: string, clusterName: string, applicationName: string, callback: ServiceCallback<models.ServiceResourceList>): void;
    list(resourceGroupName: string, clusterName: string, applicationName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceResourceList>): void;
}
