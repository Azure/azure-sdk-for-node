/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { BaseResource, CloudError } from "ms-rest-azure";
import * as moment from "moment";

export {

  BaseResource,
  CloudError
};

/**
 * Key Vault container for a certificate that is purchased through Azure.
 */
export interface AppServiceCertificate {
  /**
   * Key Vault resource Id.
   */
  keyVaultId?: string;
  /**
   * Key Vault secret name.
   */
  keyVaultSecretName?: string;
  /**
   * Status of the Key Vault secret. Possible values include: 'Initialized',
   * 'WaitingOnCertificateOrder', 'Succeeded', 'CertificateOrderFailed',
   * 'OperationNotPermittedOnKeyVault', 'AzureServiceUnauthorizedToAccessKeyVault',
   * 'KeyVaultDoesNotExist', 'KeyVaultSecretDoesNotExist', 'UnknownError', 'ExternalPrivateKey',
   * 'Unknown'
   */
  readonly provisioningState?: string;
}

/**
 * Azure resource. This resource is tracked in Azure Resource Manager
 */
export interface Resource extends BaseResource {
  /**
   * Resource Id.
   */
  readonly id?: string;
  /**
   * Resource Name.
   */
  readonly name?: string;
  /**
   * Kind of resource.
   */
  kind?: string;
  /**
   * Resource Location.
   */
  location: string;
  /**
   * Resource type.
   */
  readonly type?: string;
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Key Vault container ARM resource for a certificate that is purchased through Azure.
 */
export interface AppServiceCertificateResource extends Resource {
  /**
   * Key Vault resource Id.
   */
  keyVaultId?: string;
  /**
   * Key Vault secret name.
   */
  keyVaultSecretName?: string;
  /**
   * Status of the Key Vault secret. Possible values include: 'Initialized',
   * 'WaitingOnCertificateOrder', 'Succeeded', 'CertificateOrderFailed',
   * 'OperationNotPermittedOnKeyVault', 'AzureServiceUnauthorizedToAccessKeyVault',
   * 'KeyVaultDoesNotExist', 'KeyVaultSecretDoesNotExist', 'UnknownError', 'ExternalPrivateKey',
   * 'Unknown'
   */
  readonly provisioningState?: string;
}

/**
 * SSL certificate details.
 */
export interface CertificateDetails {
  /**
   * Certificate Version.
   */
  readonly version?: number;
  /**
   * Certificate Serial Number.
   */
  readonly serialNumber?: string;
  /**
   * Certificate Thumbprint.
   */
  readonly thumbprint?: string;
  /**
   * Certificate Subject.
   */
  readonly subject?: string;
  /**
   * Date Certificate is valid from.
   */
  readonly notBefore?: Date;
  /**
   * Date Certificate is valid to.
   */
  readonly notAfter?: Date;
  /**
   * Certificate Signature algorithm.
   */
  readonly signatureAlgorithm?: string;
  /**
   * Certificate Issuer.
   */
  readonly issuer?: string;
  /**
   * Raw certificate data.
   */
  readonly rawData?: string;
}

/**
 * SSL certificate purchase order.
 */
export interface AppServiceCertificateOrder extends Resource {
  /**
   * State of the Key Vault secret.
   */
  certificates?: { [propertyName: string]: AppServiceCertificate };
  /**
   * Certificate distinguished name.
   */
  distinguishedName?: string;
  /**
   * Domain verification token.
   */
  readonly domainVerificationToken?: string;
  /**
   * Duration in years (must be between 1 and 3).
   */
  validityInYears?: number;
  /**
   * Certificate key size.
   */
  keySize?: number;
  /**
   * Certificate product type. Possible values include: 'StandardDomainValidatedSsl',
   * 'StandardDomainValidatedWildCardSsl'
   */
  productType: string;
  /**
   * <code>true</code> if the certificate should be automatically renewed when it expires;
   * otherwise, <code>false</code>.
   */
  autoRenew?: boolean;
  /**
   * Status of certificate order. Possible values include: 'Succeeded', 'Failed', 'Canceled',
   * 'InProgress', 'Deleting'
   */
  readonly provisioningState?: string;
  /**
   * Current order status. Possible values include: 'Pendingissuance', 'Issued', 'Revoked',
   * 'Canceled', 'Denied', 'Pendingrevocation', 'PendingRekey', 'Unused', 'Expired', 'NotSubmitted'
   */
  readonly status?: string;
  /**
   * Signed certificate.
   */
  readonly signedCertificate?: CertificateDetails;
  /**
   * Last CSR that was created for this order.
   */
  csr?: string;
  /**
   * Intermediate certificate.
   */
  readonly intermediate?: CertificateDetails;
  /**
   * Root certificate.
   */
  readonly root?: CertificateDetails;
  /**
   * Current serial number of the certificate.
   */
  readonly serialNumber?: string;
  /**
   * Certificate last issuance time.
   */
  readonly lastCertificateIssuanceTime?: Date;
  /**
   * Certificate expiration time.
   */
  readonly expirationTime?: Date;
  /**
   * <code>true</code> if private key is external; otherwise, <code>false</code>.
   */
  readonly isPrivateKeyExternal?: boolean;
  /**
   * Reasons why App Service Certificate is not renewable at the current moment.
   */
  readonly appServiceCertificateNotRenewableReasons?: string[];
  /**
   * Time stamp when the certificate would be auto renewed next
   */
  readonly nextAutoRenewalTimeStamp?: Date;
}

/**
 * Azure proxy only resource. This resource is not tracked by Azure Resource Manager.
 */
export interface ProxyOnlyResource extends BaseResource {
  /**
   * Resource Id.
   */
  readonly id?: string;
  /**
   * Resource Name.
   */
  readonly name?: string;
  /**
   * Kind of resource.
   */
  kind?: string;
  /**
   * Resource type.
   */
  readonly type?: string;
}

/**
 * ARM resource for a certificate order that is purchased through Azure.
 */
export interface AppServiceCertificateOrderPatchResource extends ProxyOnlyResource {
  /**
   * State of the Key Vault secret.
   */
  certificates?: { [propertyName: string]: AppServiceCertificate };
  /**
   * Certificate distinguished name.
   */
  distinguishedName?: string;
  /**
   * Domain verification token.
   */
  readonly domainVerificationToken?: string;
  /**
   * Duration in years (must be between 1 and 3).
   */
  validityInYears?: number;
  /**
   * Certificate key size.
   */
  keySize?: number;
  /**
   * Certificate product type. Possible values include: 'StandardDomainValidatedSsl',
   * 'StandardDomainValidatedWildCardSsl'
   */
  productType: string;
  /**
   * <code>true</code> if the certificate should be automatically renewed when it expires;
   * otherwise, <code>false</code>.
   */
  autoRenew?: boolean;
  /**
   * Status of certificate order. Possible values include: 'Succeeded', 'Failed', 'Canceled',
   * 'InProgress', 'Deleting'
   */
  readonly provisioningState?: string;
  /**
   * Current order status. Possible values include: 'Pendingissuance', 'Issued', 'Revoked',
   * 'Canceled', 'Denied', 'Pendingrevocation', 'PendingRekey', 'Unused', 'Expired', 'NotSubmitted'
   */
  readonly status?: string;
  /**
   * Signed certificate.
   */
  readonly signedCertificate?: CertificateDetails;
  /**
   * Last CSR that was created for this order.
   */
  csr?: string;
  /**
   * Intermediate certificate.
   */
  readonly intermediate?: CertificateDetails;
  /**
   * Root certificate.
   */
  readonly root?: CertificateDetails;
  /**
   * Current serial number of the certificate.
   */
  readonly serialNumber?: string;
  /**
   * Certificate last issuance time.
   */
  readonly lastCertificateIssuanceTime?: Date;
  /**
   * Certificate expiration time.
   */
  readonly expirationTime?: Date;
  /**
   * <code>true</code> if private key is external; otherwise, <code>false</code>.
   */
  readonly isPrivateKeyExternal?: boolean;
  /**
   * Reasons why App Service Certificate is not renewable at the current moment.
   */
  readonly appServiceCertificateNotRenewableReasons?: string[];
  /**
   * Time stamp when the certificate would be auto renewed next
   */
  readonly nextAutoRenewalTimeStamp?: Date;
}

/**
 * Key Vault container ARM resource for a certificate that is purchased through Azure.
 */
export interface AppServiceCertificatePatchResource extends ProxyOnlyResource {
  /**
   * Key Vault resource Id.
   */
  keyVaultId?: string;
  /**
   * Key Vault secret name.
   */
  keyVaultSecretName?: string;
  /**
   * Status of the Key Vault secret. Possible values include: 'Initialized',
   * 'WaitingOnCertificateOrder', 'Succeeded', 'CertificateOrderFailed',
   * 'OperationNotPermittedOnKeyVault', 'AzureServiceUnauthorizedToAccessKeyVault',
   * 'KeyVaultDoesNotExist', 'KeyVaultSecretDoesNotExist', 'UnknownError', 'ExternalPrivateKey',
   * 'Unknown'
   */
  readonly provisioningState?: string;
}

/**
 * SSL certificate email.
 */
export interface CertificateEmail extends ProxyOnlyResource {
  /**
   * Email id.
   */
  emailId?: string;
  /**
   * Time stamp.
   */
  timeStamp?: Date;
}

/**
 * Certificate order action.
 */
export interface CertificateOrderAction extends ProxyOnlyResource {
  /**
   * Action type. Possible values include: 'CertificateIssued', 'CertificateOrderCanceled',
   * 'CertificateOrderCreated', 'CertificateRevoked', 'DomainValidationComplete', 'FraudDetected',
   * 'OrgNameChange', 'OrgValidationComplete', 'SanDrop', 'FraudCleared', 'CertificateExpired',
   * 'CertificateExpirationWarning', 'FraudDocumentationRequired', 'Unknown'
   */
  readonly actionType?: string;
  /**
   * Time at which the certificate action was performed.
   */
  readonly createdAt?: Date;
}

/**
 * Class representing certificate reissue request.
 */
export interface ReissueCertificateOrderRequest extends ProxyOnlyResource {
  /**
   * Certificate Key Size.
   */
  keySize?: number;
  /**
   * Delay in hours to revoke existing certificate after the new certificate is issued.
   */
  delayExistingRevokeInHours?: number;
  /**
   * Csr to be used for re-key operation.
   */
  csr?: string;
  /**
   * Should we change the ASC type (from managed private key to external private key and vice
   * versa).
   */
  isPrivateKeyExternal?: boolean;
}

/**
 * Class representing certificate renew request.
 */
export interface RenewCertificateOrderRequest extends ProxyOnlyResource {
  /**
   * Certificate Key Size.
   */
  keySize?: number;
  /**
   * Csr to be used for re-key operation.
   */
  csr?: string;
  /**
   * Should we change the ASC type (from managed private key to external private key and vice
   * versa).
   */
  isPrivateKeyExternal?: boolean;
}

/**
 * Site seal
 */
export interface SiteSeal {
  /**
   * HTML snippet
   */
  html: string;
}

/**
 * Site seal request.
 */
export interface SiteSealRequest {
  /**
   * If <code>true</code> use the light color theme for site seal; otherwise, use the default color
   * theme.
   */
  lightTheme?: boolean;
  /**
   * Locale of site seal.
   */
  locale?: string;
}

/**
 * Virtual Network route contract used to pass routing information for a Virtual Network.
 */
export interface VnetRoute extends ProxyOnlyResource {
  /**
   * The starting address for this route. This may also include a CIDR notation, in which case the
   * end address must not be specified.
   */
  startAddress?: string;
  /**
   * The ending address for this route. If the start address is specified in CIDR notation, this
   * must be omitted.
   */
  endAddress?: string;
  /**
   * The type of route this is:
   * DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
   * INHERITED - Routes inherited from the real Virtual Network routes
   * STATIC - Static route set on the app only
   *
   * These values will be used for syncing an app's routes with those from a Virtual Network.
   * Possible values include: 'DEFAULT', 'INHERITED', 'STATIC'
   */
  routeType?: string;
}

/**
 * Virtual Network information contract.
 */
export interface VnetInfo extends ProxyOnlyResource {
  /**
   * The Virtual Network's resource ID.
   */
  vnetResourceId?: string;
  /**
   * The client certificate thumbprint.
   */
  readonly certThumbprint?: string;
  /**
   * A certificate file (.cer) blob containing the public key of the private key used to
   * authenticate a
   * Point-To-Site VPN connection.
   */
  certBlob?: Buffer;
  /**
   * The routes that this Virtual Network connection uses.
   */
  readonly routes?: VnetRoute[];
  /**
   * <code>true</code> if a resync is required; otherwise, <code>false</code>.
   */
  readonly resyncRequired?: boolean;
  /**
   * DNS servers to be used by this Virtual Network. This should be a comma-separated list of IP
   * addresses.
   */
  dnsServers?: string;
}

/**
 * The Virtual Network gateway contract. This is used to give the Virtual Network gateway access to
 * the VPN package.
 */
export interface VnetGateway extends ProxyOnlyResource {
  /**
   * The Virtual Network name.
   */
  vnetName?: string;
  /**
   * The URI where the VPN package can be downloaded.
   */
  vpnPackageUri: string;
}

/**
 * User credentials used for publishing activity.
 */
export interface User extends ProxyOnlyResource {
  /**
   * Username used for publishing.
   */
  publishingUserName: string;
  /**
   * Password used for publishing.
   */
  publishingPassword?: string;
  /**
   * Password hash used for publishing.
   */
  publishingPasswordHash?: string;
  /**
   * Password hash salt used for publishing.
   */
  publishingPasswordHashSalt?: string;
  /**
   * Url of SCM site.
   */
  scmUri?: string;
}

/**
 * A snapshot of an app.
 */
export interface Snapshot extends ProxyOnlyResource {
  /**
   * The time the snapshot was taken.
   */
  readonly time?: string;
}

/**
 * Metrics availability and retention.
 */
export interface ResourceMetricAvailability {
  /**
   * Time grain .
   */
  readonly timeGrain?: string;
  /**
   * Retention period for the current time grain.
   */
  readonly retention?: string;
}

/**
 * Metadata for the metrics.
 */
export interface ResourceMetricDefinition extends ProxyOnlyResource {
  /**
   * Unit of the metric.
   */
  readonly unit?: string;
  /**
   * Primary aggregation type.
   */
  readonly primaryAggregationType?: string;
  /**
   * List of time grains supported for the metric together with retention period.
   */
  readonly metricAvailabilities?: ResourceMetricAvailability[];
  /**
   * Resource URI.
   */
  readonly resourceUri?: string;
  /**
   * Resource metric definition properties.
   */
  readonly properties?: { [propertyName: string]: string };
}

/**
 * Push settings for the App.
 */
export interface PushSettings extends ProxyOnlyResource {
  /**
   * Gets or sets a flag indicating whether the Push endpoint is enabled.
   */
  isPushEnabled: boolean;
  /**
   * Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   */
  tagWhitelistJson?: string;
  /**
   * Gets or sets a JSON string containing a list of tags that require user authentication to be
   * used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   */
  tagsRequiringAuth?: string;
  /**
   * Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user
   * claims in the push registration endpoint.
   */
  dynamicTagsJson?: string;
}

/**
 * A domain specific resource identifier.
 */
export interface Identifier extends ProxyOnlyResource {
  /**
   * String representation of the identity.
   */
  identifierId?: string;
}

/**
 * Hybrid Connection key contract. This has the send key name and value for a Hybrid Connection.
 */
export interface HybridConnectionKey extends ProxyOnlyResource {
  /**
   * The name of the send key.
   */
  readonly sendKeyName?: string;
  /**
   * The value of the send key.
   */
  readonly sendKeyValue?: string;
}

/**
 * Hybrid Connection contract. This is used to configure a Hybrid Connection.
 */
export interface HybridConnection extends ProxyOnlyResource {
  /**
   * The name of the Service Bus namespace.
   */
  serviceBusNamespace?: string;
  /**
   * The name of the Service Bus relay.
   */
  relayName?: string;
  /**
   * The ARM URI to the Service Bus relay.
   */
  relayArmUri?: string;
  /**
   * The hostname of the endpoint.
   */
  hostname?: string;
  /**
   * The port of the endpoint.
   */
  port?: number;
  /**
   * The name of the Service Bus key which has Send permissions. This is used to authenticate to
   * Service Bus.
   */
  sendKeyName?: string;
  /**
   * The value of the Service Bus key. This is used to authenticate to Service Bus. In ARM this key
   * will not be returned
   * normally, use the POST /listKeys API instead.
   */
  sendKeyValue?: string;
  /**
   * The suffix for the service bus endpoint. By default this is .servicebus.windows.net
   */
  serviceBusSuffix?: string;
}

/**
 * A deleted app.
 */
export interface DeletedSite extends ProxyOnlyResource {
  /**
   * Numeric id for the deleted site
   */
  readonly deletedSiteId?: number;
  /**
   * Time in UTC when the app was deleted.
   */
  readonly deletedTimestamp?: string;
  /**
   * Subscription containing the deleted site
   */
  readonly subscription?: string;
  /**
   * ResourceGroup that contained the deleted site
   */
  readonly resourceGroup?: string;
  /**
   * Name of the deleted site
   */
  readonly deletedSiteName?: string;
  /**
   * Slot of the deleted site
   */
  readonly slot?: string;
  /**
   * Kind of site that was deleted
   */
  readonly deletedSiteKind?: string;
  /**
   * Geo Region of the deleted site
   */
  readonly geoRegionName?: string;
}

/**
 * Managed service identity.
 */
export interface ManagedServiceIdentity {
  /**
   * Type of managed service identity. Possible values include: 'SystemAssigned', 'UserAssigned'
   */
  type?: string;
  /**
   * Tenant of managed service identity.
   */
  readonly tenantId?: string;
  /**
   * Principal Id of managed service identity.
   */
  readonly principalId?: string;
  /**
   * Array of UserAssigned managed service identities.
   */
  identityIds?: string[];
}

/**
 * The status of the last successful slot swap operation.
 */
export interface SlotSwapStatus {
  /**
   * The time the last successful slot swap completed.
   */
  readonly timestampUtc?: Date;
  /**
   * The source slot of the last swap operation.
   */
  readonly sourceSlotName?: string;
  /**
   * The destination slot of the last swap operation.
   */
  readonly destinationSlotName?: string;
}

/**
 * Information needed for cloning operation.
 */
export interface CloningInfo {
  /**
   * Correlation ID of cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   */
  correlationId?: string;
  /**
   * <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
   */
  overwrite?: boolean;
  /**
   * <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
   */
  cloneCustomHostNames?: boolean;
  /**
   * <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
   */
  cloneSourceControl?: boolean;
  /**
   * ARM resource ID of the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   */
  sourceWebAppId: string;
  /**
   * App Service Environment.
   */
  hostingEnvironment?: string;
  /**
   * Application setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are retained.
   */
  appSettingsOverrides?: { [propertyName: string]: string };
  /**
   * <code>true</code> to configure load balancing for source and destination app.
   */
  configureLoadBalancing?: boolean;
  /**
   * ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource
   * ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   */
  trafficManagerProfileId?: string;
  /**
   * Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does
   * not already exist.
   */
  trafficManagerProfileName?: string;
}

/**
 * Specification for an App Service Environment to use for this resource.
 */
export interface HostingEnvironmentProfile {
  /**
   * Resource ID of the App Service Environment.
   */
  id?: string;
  /**
   * Name of the App Service Environment.
   */
  readonly name?: string;
  /**
   * Resource type of the App Service Environment.
   */
  readonly type?: string;
}

/**
 * IP security restriction on an app.
 */
export interface IpSecurityRestriction {
  /**
   * IP address the security restriction is valid for.
   * It can be in form of pure ipv4 address (required SubnetMask property) or
   * CIDR notation such as ipv4/mask (leading bit match). For CIDR,
   * SubnetMask property must not be specified.
   */
  ipAddress: string;
  /**
   * Subnet mask for the range of IP addresses the restriction is valid for.
   */
  subnetMask?: string;
  /**
   * Allow or Deny access for this IP range.
   */
  action?: string;
  /**
   * Defines what this IP filter will be used for. This is to support IP filtering on proxies.
   * Possible values include: 'Default', 'XffProxy'
   */
  tag?: string;
  /**
   * Priority of IP restriction rule.
   */
  priority?: number;
  /**
   * IP restriction rule name.
   */
  name?: string;
  /**
   * IP restriction rule description.
   */
  description?: string;
}

/**
 * Information about the formal API definition for the app.
 */
export interface ApiDefinitionInfo {
  /**
   * The URL of the API definition.
   */
  url?: string;
}

/**
 * Cross-Origin Resource Sharing (CORS) settings for the app.
 */
export interface CorsSettings {
  /**
   * Gets or sets the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   */
  allowedOrigins?: string[];
}

/**
 * Custom action to be executed
 * when an auto heal rule is triggered.
 */
export interface AutoHealCustomAction {
  /**
   * Executable to be run.
   */
  exe?: string;
  /**
   * Parameters for the executable.
   */
  parameters?: string;
}

/**
 * Actions which to take by the auto-heal module when a rule is triggered.
 */
export interface AutoHealActions {
  /**
   * Predefined action to be taken. Possible values include: 'Recycle', 'LogEvent', 'CustomAction'
   */
  actionType?: string;
  /**
   * Custom action to be taken.
   */
  customAction?: AutoHealCustomAction;
  /**
   * Minimum time the process must execute
   * before taking the action
   */
  minProcessExecutionTime?: string;
}

/**
 * Trigger based on request execution time.
 */
export interface SlowRequestsBasedTrigger {
  /**
   * Time taken.
   */
  timeTaken?: string;
  /**
   * Request Count.
   */
  count?: number;
  /**
   * Time interval.
   */
  timeInterval?: string;
}

/**
 * Trigger based on status code.
 */
export interface StatusCodesBasedTrigger {
  /**
   * HTTP status code.
   */
  status?: number;
  /**
   * Request Sub Status.
   */
  subStatus?: number;
  /**
   * Win32 error code.
   */
  win32Status?: number;
  /**
   * Request Count.
   */
  count?: number;
  /**
   * Time interval.
   */
  timeInterval?: string;
}

/**
 * Trigger based on total requests.
 */
export interface RequestsBasedTrigger {
  /**
   * Request Count.
   */
  count?: number;
  /**
   * Time interval.
   */
  timeInterval?: string;
}

/**
 * Triggers for auto-heal.
 */
export interface AutoHealTriggers {
  /**
   * A rule based on total requests.
   */
  requests?: RequestsBasedTrigger;
  /**
   * A rule based on private bytes.
   */
  privateBytesInKB?: number;
  /**
   * A rule based on status codes.
   */
  statusCodes?: StatusCodesBasedTrigger[];
  /**
   * A rule based on request execution time.
   */
  slowRequests?: SlowRequestsBasedTrigger;
}

/**
 * Rules that can be defined for auto-heal.
 */
export interface AutoHealRules {
  /**
   * Conditions that describe when to execute the auto-heal actions.
   */
  triggers?: AutoHealTriggers;
  /**
   * Actions to be executed when a rule is triggered.
   */
  actions?: AutoHealActions;
}

/**
 * Metric limits set on an app.
 */
export interface SiteLimits {
  /**
   * Maximum allowed CPU usage percentage.
   */
  maxPercentageCpu?: number;
  /**
   * Maximum allowed memory usage in MB.
   */
  maxMemoryInMb?: number;
  /**
   * Maximum allowed disk size usage in MB.
   */
  maxDiskSizeInMb?: number;
}

/**
 * Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to
 * gradually change routing % based on performance.
 */
export interface RampUpRule {
  /**
   * Hostname of a slot to which the traffic will be redirected if decided to. E.g.
   * myapp-stage.azurewebsites.net.
   */
  actionHostName?: string;
  /**
   * Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
   */
  reroutePercentage?: number;
  /**
   * In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code>
   * until it reaches
   * <code>MinReroutePercentage</code> or <code>MaxReroutePercentage</code>. Site metrics are
   * checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.
   * Custom decision algorithm can be provided in TiPCallback site extension which URL can be
   * specified in <code>ChangeDecisionCallbackUrl</code>.
   */
  changeStep?: number;
  /**
   * Specifies interval in minutes to reevaluate ReroutePercentage.
   */
  changeIntervalInMinutes?: number;
  /**
   * Specifies lower boundary above which ReroutePercentage will stay.
   */
  minReroutePercentage?: number;
  /**
   * Specifies upper boundary below which ReroutePercentage will stay.
   */
  maxReroutePercentage?: number;
  /**
   * Custom decision algorithm can be provided in TiPCallback site extension which URL can be
   * specified. See TiPCallback site extension for the scaffold and contracts.
   * https://www.siteextensions.net/packages/TiPCallback/
   */
  changeDecisionCallbackUrl?: string;
  /**
   * Name of the routing rule. The recommended name would be to point to the slot which will
   * receive the traffic in the experiment.
   */
  name?: string;
}

/**
 * Routing rules in production experiments.
 */
export interface Experiments {
  /**
   * List of ramp-up rules.
   */
  rampUpRules?: RampUpRule[];
}

/**
 * Directory for virtual application.
 */
export interface VirtualDirectory {
  /**
   * Path to virtual application.
   */
  virtualPath?: string;
  /**
   * Physical path.
   */
  physicalPath?: string;
}

/**
 * Virtual application in an app.
 */
export interface VirtualApplication {
  /**
   * Virtual path.
   */
  virtualPath?: string;
  /**
   * Physical path.
   */
  physicalPath?: string;
  /**
   * <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
   */
  preloadEnabled?: boolean;
  /**
   * Virtual directories for virtual application.
   */
  virtualDirectories?: VirtualDirectory[];
}

/**
 * The IIS handler mappings used to define which handler processes HTTP requests with certain
 * extension.
 * For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php
 * extension.
 */
export interface HandlerMapping {
  /**
   * Requests with this extension will be handled using the specified FastCGI application.
   */
  extension?: string;
  /**
   * The absolute path to the FastCGI application.
   */
  scriptProcessor?: string;
  /**
   * Command-line arguments to be passed to the script processor.
   */
  argumentsProperty?: string;
}

/**
 * MachineKey of an app.
 */
export interface SiteMachineKey {
  /**
   * MachineKey validation.
   */
  validation?: string;
  /**
   * Validation key.
   */
  validationKey?: string;
  /**
   * Algorithm used for decryption.
   */
  decryption?: string;
  /**
   * Decryption key.
   */
  decryptionKey?: string;
}

/**
 * Database connection string information.
 */
export interface ConnStringInfo {
  /**
   * Name of connection string.
   */
  name?: string;
  /**
   * Connection string value.
   */
  connectionString?: string;
  /**
   * Type of database. Possible values include: 'MySql', 'SQLServer', 'SQLAzure', 'Custom',
   * 'NotificationHub', 'ServiceBus', 'EventHub', 'ApiHub', 'DocDb', 'RedisCache', 'PostgreSQL'
   */
  type?: string;
}

/**
 * Azure Files or Blob Storage access information value for dictionary storage.
 */
export interface AzureStorageInfoValue {
  /**
   * Type of storage. Possible values include: 'AzureFiles', 'AzureBlob'
   */
  type?: string;
  /**
   * Name of the storage account.
   */
  accountName?: string;
  /**
   * Name of the file share (container name, for Blob storage).
   */
  shareName?: string;
  /**
   * Access key for the storage account.
   */
  accessKey?: string;
  /**
   * Path to mount the storage within the site's runtime environment.
   */
  mountPath?: string;
  /**
   * State of the storage account. Possible values include: 'Ok', 'InvalidCredentials',
   * 'InvalidShare'
   */
  readonly state?: string;
}

/**
 * Name value pair.
 */
export interface NameValuePair {
  /**
   * Pair name.
   */
  name?: string;
  /**
   * Pair value.
   */
  value?: string;
}

/**
 * Configuration of an App Service app.
 */
export interface SiteConfig {
  /**
   * Number of workers.
   */
  numberOfWorkers?: number;
  /**
   * Default documents.
   */
  defaultDocuments?: string[];
  /**
   * .NET Framework version.
   */
  netFrameworkVersion?: string;
  /**
   * Version of PHP.
   */
  phpVersion?: string;
  /**
   * Version of Python.
   */
  pythonVersion?: string;
  /**
   * Version of Node.js.
   */
  nodeVersion?: string;
  /**
   * Linux App Framework and version
   */
  linuxFxVersion?: string;
  /**
   * Xenon App Framework and version
   */
  windowsFxVersion?: string;
  /**
   * <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
   */
  requestTracingEnabled?: boolean;
  /**
   * Request tracing expiration time.
   */
  requestTracingExpirationTime?: Date;
  /**
   * <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
   */
  remoteDebuggingEnabled?: boolean;
  /**
   * Remote debugging version.
   */
  remoteDebuggingVersion?: string;
  /**
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
   */
  httpLoggingEnabled?: boolean;
  /**
   * HTTP logs directory size limit.
   */
  logsDirectorySizeLimit?: number;
  /**
   * <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
   */
  detailedErrorLoggingEnabled?: boolean;
  /**
   * Publishing user name.
   */
  publishingUsername?: string;
  /**
   * Application settings.
   */
  appSettings?: NameValuePair[];
  /**
   * User-provided Azure storage accounts.
   */
  azureStorageAccounts?: { [propertyName: string]: AzureStorageInfoValue };
  /**
   * Connection strings.
   */
  connectionStrings?: ConnStringInfo[];
  /**
   * Site MachineKey.
   */
  readonly machineKey?: SiteMachineKey;
  /**
   * Handler mappings.
   */
  handlerMappings?: HandlerMapping[];
  /**
   * Document root.
   */
  documentRoot?: string;
  /**
   * SCM type. Possible values include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub',
   * 'CodePlexGit', 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   */
  scmType?: string;
  /**
   * <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
   */
  use32BitWorkerProcess?: boolean;
  /**
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
   */
  webSocketsEnabled?: boolean;
  /**
   * <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
   */
  alwaysOn?: boolean;
  /**
   * Java version.
   */
  javaVersion?: string;
  /**
   * Java container.
   */
  javaContainer?: string;
  /**
   * Java container version.
   */
  javaContainerVersion?: string;
  /**
   * App command line to launch.
   */
  appCommandLine?: string;
  /**
   * Managed pipeline mode. Possible values include: 'Integrated', 'Classic'
   */
  managedPipelineMode?: string;
  /**
   * Virtual applications.
   */
  virtualApplications?: VirtualApplication[];
  /**
   * Site load balancing. Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   */
  loadBalancing?: string;
  /**
   * This is work around for polymophic types.
   */
  experiments?: Experiments;
  /**
   * Site limits.
   */
  limits?: SiteLimits;
  /**
   * <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
   */
  autoHealEnabled?: boolean;
  /**
   * Auto Heal rules.
   */
  autoHealRules?: AutoHealRules;
  /**
   * Tracing options.
   */
  tracingOptions?: string;
  /**
   * Virtual Network name.
   */
  vnetName?: string;
  /**
   * Cross-Origin Resource Sharing (CORS) settings.
   */
  cors?: CorsSettings;
  /**
   * Push endpoint settings.
   */
  push?: PushSettings;
  /**
   * Information about the formal API definition for the app.
   */
  apiDefinition?: ApiDefinitionInfo;
  /**
   * Auto-swap slot name.
   */
  autoSwapSlotName?: string;
  /**
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
   */
  localMySqlEnabled?: boolean;
  /**
   * Managed Service Identity Id
   */
  managedServiceIdentityId?: number;
  /**
   * Explicit Managed Service Identity Id
   */
  xManagedServiceIdentityId?: number;
  /**
   * IP security restrictions.
   */
  ipSecurityRestrictions?: IpSecurityRestriction[];
  /**
   * Http20Enabled: configures a web site to allow clients to connect over http2.0
   */
  http20Enabled?: boolean;
  /**
   * MinTlsVersion: configures the minimum version of TLS required for SSL requests. Possible
   * values include: '1.0', '1.1', '1.2'
   */
  minTlsVersion?: string;
  /**
   * State of FTP / FTPS service. Possible values include: 'AllAllowed', 'FtpsOnly', 'Disabled'
   */
  ftpsState?: string;
  /**
   * Number of reserved instances.
   * This setting only applies to the Consumption Plan
   */
  reservedInstanceCount?: number;
}

/**
 * SSL-enabled hostname.
 */
export interface HostNameSslState {
  /**
   * Hostname.
   */
  name?: string;
  /**
   * SSL type. Possible values include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
   */
  sslState?: string;
  /**
   * Virtual IP address assigned to the hostname if IP based SSL is enabled.
   */
  virtualIP?: string;
  /**
   * SSL certificate thumbprint.
   */
  thumbprint?: string;
  /**
   * Set to <code>true</code> to update existing hostname.
   */
  toUpdate?: boolean;
  /**
   * Indicates whether the hostname is a standard or repository hostname. Possible values include:
   * 'Standard', 'Repository'
   */
  hostType?: string;
}

/**
 * A web app, a mobile app backend, or an API app.
 */
export interface Site extends Resource {
  /**
   * Current state of the app.
   */
  readonly state?: string;
  /**
   * Hostnames associated with the app.
   */
  readonly hostNames?: string[];
  /**
   * Name of the repository site.
   */
  readonly repositorySiteName?: string;
  /**
   * State indicating whether the app has exceeded its quota usage. Read-only. Possible values
   * include: 'Normal', 'Exceeded'
   */
  readonly usageState?: string;
  /**
   * <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to
   * false disables the app (takes the app offline).
   */
  enabled?: boolean;
  /**
   * Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled.
   * Otherwise,
   * the app is not served on those hostnames.
   */
  readonly enabledHostNames?: string[];
  /**
   * Management information availability state for the app. Possible values include: 'Normal',
   * 'Limited', 'DisasterRecoveryMode'
   */
  readonly availabilityState?: string;
  /**
   * Hostname SSL states are used to manage the SSL bindings for app's hostnames.
   */
  hostNameSslStates?: HostNameSslState[];
  /**
   * Resource ID of the associated App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   */
  serverFarmId?: string;
  /**
   * <code>true</code> if reserved; otherwise, <code>false</code>.
   */
  reserved?: boolean;
  /**
   * Obsolete: Hyper-V sandbox.
   */
  isXenon?: boolean;
  /**
   * Hyper-V sandbox.
   */
  hyperV?: boolean;
  /**
   * Last time the app was modified, in UTC. Read-only.
   */
  readonly lastModifiedTimeUtc?: Date;
  /**
   * Configuration of the app.
   */
  siteConfig?: SiteConfig;
  /**
   * Azure Traffic Manager hostnames associated with the app. Read-only.
   */
  readonly trafficManagerHostNames?: string[];
  /**
   * <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise,
   * <code>false</code>. The default is <code>false</code>.
   */
  scmSiteAlsoStopped?: boolean;
  /**
   * Specifies which deployment slot this app will swap into. Read-only.
   */
  readonly targetSwapSlot?: string;
  /**
   * App Service Environment to use for the app.
   */
  hostingEnvironmentProfile?: HostingEnvironmentProfile;
  /**
   * <code>true</code> to enable client affinity; <code>false</code> to stop sending session
   * affinity cookies, which route client requests in the same session to the same instance.
   * Default is <code>true</code>.
   */
  clientAffinityEnabled?: boolean;
  /**
   * <code>true</code> to enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
   */
  clientCertEnabled?: boolean;
  /**
   * <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
   */
  hostNamesDisabled?: boolean;
  /**
   * List of IP addresses that the app uses for outbound connections (e.g. database access).
   * Includes VIPs from tenants that site can be hosted with current settings. Read-only.
   */
  readonly outboundIpAddresses?: string;
  /**
   * List of IP addresses that the app uses for outbound connections (e.g. database access).
   * Includes VIPs from all tenants. Read-only.
   */
  readonly possibleOutboundIpAddresses?: string;
  /**
   * Size of the function container.
   */
  containerSize?: number;
  /**
   * Maximum allowed daily memory-time quota (applicable on dynamic apps only).
   */
  dailyMemoryTimeQuota?: number;
  /**
   * App suspended till in case memory-time quota is exceeded.
   */
  readonly suspendedTill?: Date;
  /**
   * Maximum number of workers.
   * This only applies to Functions container.
   */
  readonly maxNumberOfWorkers?: number;
  /**
   * If specified during app creation, the app is cloned from a source app.
   */
  cloningInfo?: CloningInfo;
  /**
   * Name of the resource group the app belongs to. Read-only.
   */
  readonly resourceGroup?: string;
  /**
   * <code>true</code> if the app is a default container; otherwise, <code>false</code>.
   */
  readonly isDefaultContainer?: boolean;
  /**
   * Default hostname of the app. Read-only.
   */
  readonly defaultHostName?: string;
  /**
   * Status of the last deployment slot swap operation.
   */
  readonly slotSwapStatus?: SlotSwapStatus;
  /**
   * HttpsOnly: configures a web site to accept only https requests. Issues redirect for
   * http requests
   */
  httpsOnly?: boolean;
  identity?: ManagedServiceIdentity;
}

/**
 * Describes the capabilities/features allowed for a specific SKU.
*/
export interface Capability {
  /**
   * Name of the SKU capability.
  */
  name?: string;
  /**
   * Value of the SKU capability.
  */
  value?: string;
  /**
   * Reason of the SKU capability.
  */
  reason?: string;
}

/**
 * Description of the App Service plan scale options.
*/
export interface SkuCapacity {
  /**
   * Minimum number of workers for this App Service plan SKU.
  */
  minimum?: number;
  /**
   * Maximum number of workers for this App Service plan SKU.
  */
  maximum?: number;
  /**
   * Default number of workers for this App Service plan SKU.
  */
  default?: number;
  /**
   * Available scale configurations for an App Service plan.
  */
  scaleType?: string;
}

/**
 * Description of a SKU for a scalable resource.
*/
export interface SkuDescription {
  /**
   * Name of the resource SKU.
  */
  name?: string;
  /**
   * Service tier of the resource SKU.
  */
  tier?: string;
  /**
   * Size specifier of the resource SKU.
  */
  size?: string;
  /**
   * Family code of the resource SKU.
  */
  family?: string;
  /**
   * Current number of instances assigned to the resource.
  */
  capacity?: number;
  /**
   * Min, max, and default scale values of the SKU.
  */
  skuCapacity?: SkuCapacity;
  /**
   * Locations of the SKU.
  */
  locations?: string[];
  /**
   * Capabilities of the SKU, e.g., is traffic manager enabled?
  */
  capabilities?: Capability[];
}

/**
 * App Service plan.
*/
export interface AppServicePlan extends Resource {
  /**
   * Target worker tier assigned to the App Service plan.
  */
  workerTierName?: string;
  /**
   * App Service plan status. Possible values include: 'Ready', 'Pending', 'Creating'
  */
  readonly status?: string;
  /**
   * App Service plan subscription.
  */
  readonly subscription?: string;
  /**
   * App Service plan administration site.
  */
  adminSiteName?: string;
  /**
   * Specification for the App Service Environment to use for the App Service plan.
  */
  hostingEnvironmentProfile?: HostingEnvironmentProfile;
  /**
   * Maximum number of instances that can be assigned to this App Service plan.
  */
  readonly maximumNumberOfWorkers?: number;
  /**
   * Geographical location for the App Service plan.
  */
  readonly geoRegion?: string;
  /**
   * If <code>true</code>, apps assigned to this App Service plan can be scaled independently.
   * If <code>false</code>, apps assigned to this App Service plan will scale to all instances of
   * the plan.
  */
  perSiteScaling?: boolean;
  /**
   * Maximum number of total workers allowed for this ElasticScaleEnabled App Service Plan
  */
  maximumElasticWorkerCount?: number;
  /**
   * Number of apps assigned to this App Service plan.
  */
  readonly numberOfSites?: number;
  /**
   * If <code>true</code>, this App Service Plan owns spot instances.
  */
  isSpot?: boolean;
  /**
   * The time when the server farm expires. Valid only if it is a spot server farm.
  */
  spotExpirationTime?: Date;
  /**
   * The time when the server farm free offer expires.
  */
  freeOfferExpirationTime?: Date;
  /**
   * Resource group of the App Service plan.
  */
  readonly resourceGroup?: string;
  /**
   * If Linux app service plan <code>true</code>, <code>false</code> otherwise.
  */
  reserved?: boolean;
  /**
   * Obsolete: If Hyper-V container app service plan <code>true</code>, <code>false</code>
   * otherwise.
  */
  isXenon?: boolean;
  /**
   * If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
  */
  hyperV?: boolean;
  /**
   * Scaling worker count.
  */
  targetWorkerCount?: number;
  /**
   * Scaling worker size ID.
  */
  targetWorkerSizeId?: number;
  /**
   * Provisioning state of the App Service Environment. Possible values include: 'Succeeded',
   * 'Failed', 'Canceled', 'InProgress', 'Deleting'
  */
  readonly provisioningState?: string;
  sku?: SkuDescription;
}

/**
 * Detailed errors.
*/
export interface DefaultErrorResponseErrorDetailsItem {
  /**
   * Standardized string to programmatically identify the error.
  */
  readonly code?: string;
  /**
   * Detailed error description and debugging information.
  */
  readonly message?: string;
  /**
   * Detailed error description and debugging information.
  */
  readonly target?: string;
}

/**
 * Error model.
*/
export interface DefaultErrorResponseError {
  /**
   * Standardized string to programmatically identify the error.
  */
  readonly code?: string;
  /**
   * Detailed error description and debugging information.
  */
  readonly message?: string;
  /**
   * Detailed error description and debugging information.
  */
  readonly target?: string;
  details?: DefaultErrorResponseErrorDetailsItem[];
  /**
   * More information to debug error.
  */
  readonly innererror?: string;
}

/**
 * App Service error response.
*/
export interface DefaultErrorResponse {
  /**
   * Error model.
  */
  readonly error?: DefaultErrorResponseError;
}

/**
 * Identifies an object.
*/
export interface NameIdentifier {
  /**
   * Name of the object.
  */
  name?: string;
}

/**
 * Log Definition of a single resource metric.
*/
export interface LogSpecification {
  name?: string;
  displayName?: string;
  blobDuration?: string;
}

/**
 * Retention policy of a resource metric.
*/
export interface MetricAvailability {
  timeGrain?: string;
  blobDuration?: string;
}

/**
 * Dimension of a resource metric. For e.g. instance specific HTTP requests for a web app,
 * where instance name is dimension of the metric HTTP request
*/
export interface Dimension {
  name?: string;
  displayName?: string;
  internalName?: string;
  toBeExportedForShoebox?: boolean;
}

/**
 * Definition of a single resource metric.
*/
export interface MetricSpecification {
  name?: string;
  displayName?: string;
  displayDescription?: string;
  unit?: string;
  aggregationType?: string;
  supportsInstanceLevelAggregation?: boolean;
  enableRegionalMdmAccount?: boolean;
  sourceMdmAccount?: string;
  sourceMdmNamespace?: string;
  metricFilterPattern?: string;
  fillGapWithZero?: boolean;
  isInternal?: boolean;
  dimensions?: Dimension[];
  category?: string;
  availabilities?: MetricAvailability[];
}

/**
 * Resource metrics service provided by Microsoft.Insights resource provider.
*/
export interface ServiceSpecification {
  metricSpecifications?: MetricSpecification[];
  logSpecifications?: LogSpecification[];
}

/**
 * Properties available for a Microsoft.Web resource provider operation.
*/
export interface CsmOperationDescriptionProperties {
  serviceSpecification?: ServiceSpecification;
}

/**
 * Meta data about operation used for display in portal.
*/
export interface CsmOperationDisplay {
  provider?: string;
  resource?: string;
  operation?: string;
  description?: string;
}

/**
 * Description of an operation available for Microsoft.Web resource provider.
*/
export interface CsmOperationDescription {
  name?: string;
  display?: CsmOperationDisplay;
  origin?: string;
  properties?: CsmOperationDescriptionProperties;
}

/**
 * Address information for domain registration.
*/
export interface Address {
  /**
   * First line of an Address.
  */
  address1: string;
  /**
   * The second line of the Address. Optional.
  */
  address2?: string;
  /**
   * The city for the address.
  */
  city: string;
  /**
   * The country for the address.
  */
  country: string;
  /**
   * The postal code for the address.
  */
  postalCode: string;
  /**
   * The state or province for the address.
  */
  state: string;
}

/**
 * Contact information for domain registration. If 'Domain Privacy' option is not selected then the
 * contact information is made publicly available through the Whois
 * directories as per ICANN requirements.
*/
export interface Contact {
  /**
   * Mailing address.
  */
  addressMailing?: Address;
  /**
   * Email address.
  */
  email: string;
  /**
   * Fax number.
  */
  fax?: string;
  /**
   * Job title.
  */
  jobTitle?: string;
  /**
   * First name.
  */
  nameFirst: string;
  /**
   * Last name.
  */
  nameLast: string;
  /**
   * Middle name.
  */
  nameMiddle?: string;
  /**
   * Organization contact belongs to.
  */
  organization?: string;
  /**
   * Phone number.
  */
  phone: string;
}

/**
 * Details of a hostname derived from a domain.
*/
export interface HostName {
  /**
   * Name of the hostname.
  */
  name?: string;
  /**
   * List of apps the hostname is assigned to. This list will have more than one app only if the
   * hostname is pointing to a Traffic Manager.
  */
  siteNames?: string[];
  /**
   * Name of the Azure resource the hostname is assigned to. If it is assigned to a Traffic Manager
   * then it will be the Traffic Manager name otherwise it will be the app name.
  */
  azureResourceName?: string;
  /**
   * Type of the Azure resource the hostname is assigned to. Possible values include: 'Website',
   * 'TrafficManager'
  */
  azureResourceType?: string;
  /**
   * Type of the DNS record. Possible values include: 'CName', 'A'
  */
  customHostNameDnsRecordType?: string;
  /**
   * Type of the hostname. Possible values include: 'Verified', 'Managed'
  */
  hostNameType?: string;
}

/**
 * Domain purchase consent object, representing acceptance of applicable legal agreements.
*/
export interface DomainPurchaseConsent {
  /**
   * List of applicable legal agreement keys. This list can be retrieved using ListLegalAgreements
   * API under <code>TopLevelDomain</code> resource.
  */
  agreementKeys?: string[];
  /**
   * Client IP address.
  */
  agreedBy?: string;
  /**
   * Timestamp when the agreements were accepted.
  */
  agreedAt?: Date;
}

/**
 * Information about a domain.
*/
export interface Domain extends Resource {
  /**
   * Administrative contact.
  */
  contactAdmin: Contact;
  /**
   * Billing contact.
  */
  contactBilling: Contact;
  /**
   * Registrant contact.
  */
  contactRegistrant: Contact;
  /**
   * Technical contact.
  */
  contactTech: Contact;
  /**
   * Domain registration status. Possible values include: 'Active', 'Awaiting', 'Cancelled',
   * 'Confiscated', 'Disabled', 'Excluded', 'Expired', 'Failed', 'Held', 'Locked', 'Parked',
   * 'Pending', 'Reserved', 'Reverted', 'Suspended', 'Transferred', 'Unknown', 'Unlocked',
   * 'Unparked', 'Updated', 'JsonConverterFailed'
  */
  readonly registrationStatus?: string;
  /**
   * Domain provisioning state. Possible values include: 'Succeeded', 'Failed', 'Canceled',
   * 'InProgress', 'Deleting'
  */
  readonly provisioningState?: string;
  /**
   * Name servers.
  */
  readonly nameServers?: string[];
  /**
   * <code>true</code> if domain privacy is enabled for this domain; otherwise, <code>false</code>.
  */
  privacy?: boolean;
  /**
   * Domain creation timestamp.
  */
  readonly createdTime?: Date;
  /**
   * Domain expiration timestamp.
  */
  readonly expirationTime?: Date;
  /**
   * Timestamp when the domain was renewed last time.
  */
  readonly lastRenewedTime?: Date;
  /**
   * <code>true</code> if the domain should be automatically renewed; otherwise,
   * <code>false</code>.
  */
  autoRenew?: boolean;
  /**
   * <code>true</code> if Azure can assign this domain to App Service apps; otherwise,
   * <code>false</code>. This value will be <code>true</code> if domain registration status is
   * active and
   * it is hosted on name servers Azure has programmatic access to.
  */
  readonly readyForDnsRecordManagement?: boolean;
  /**
   * All hostnames derived from the domain and assigned to Azure resources.
  */
  readonly managedHostNames?: HostName[];
  /**
   * Legal agreement consent.
  */
  consent: DomainPurchaseConsent;
  /**
   * Reasons why domain is not renewable.
  */
  readonly domainNotRenewableReasons?: string[];
  /**
   * Current DNS type. Possible values include: 'AzureDns', 'DefaultDomainRegistrarDns'
  */
  dnsType?: string;
  /**
   * Azure DNS Zone to use
  */
  dnsZoneId?: string;
  /**
   * Target DNS type (would be used for migration). Possible values include: 'AzureDns',
   * 'DefaultDomainRegistrarDns'
  */
  targetDnsType?: string;
  authCode?: string;
}

/**
 * Domain availablility check result.
*/
export interface DomainAvailablilityCheckResult {
  /**
   * Name of the domain.
  */
  name?: string;
  /**
   * <code>true</code> if domain can be purchased using CreateDomain API; otherwise,
   * <code>false</code>.
  */
  available?: boolean;
  /**
   * Valid values are Regular domain: Azure will charge the full price of domain registration,
   * SoftDeleted: Purchasing this domain will simply restore it and this operation will not cost
   * anything. Possible values include: 'Regular', 'SoftDeleted'
  */
  domainType?: string;
}

/**
 * Single sign-on request information for domain management.
*/
export interface DomainControlCenterSsoRequest {
  /**
   * URL where the single sign-on request is to be made.
  */
  readonly url?: string;
  /**
   * Post parameter key.
  */
  readonly postParameterKey?: string;
  /**
   * Post parameter value. Client should use 'application/x-www-form-urlencoded' encoding for this
   * value.
  */
  readonly postParameterValue?: string;
}

/**
 * Domain ownership Identifier.
*/
export interface DomainOwnershipIdentifier extends ProxyOnlyResource {
  /**
   * Ownership Id.
  */
  ownershipId?: string;
}

/**
 * ARM resource for a domain.
*/
export interface DomainPatchResource extends ProxyOnlyResource {
  /**
   * Administrative contact.
  */
  contactAdmin: Contact;
  /**
   * Billing contact.
  */
  contactBilling: Contact;
  /**
   * Registrant contact.
  */
  contactRegistrant: Contact;
  /**
   * Technical contact.
  */
  contactTech: Contact;
  /**
   * Domain registration status. Possible values include: 'Active', 'Awaiting', 'Cancelled',
   * 'Confiscated', 'Disabled', 'Excluded', 'Expired', 'Failed', 'Held', 'Locked', 'Parked',
   * 'Pending', 'Reserved', 'Reverted', 'Suspended', 'Transferred', 'Unknown', 'Unlocked',
   * 'Unparked', 'Updated', 'JsonConverterFailed'
  */
  readonly registrationStatus?: string;
  /**
   * Domain provisioning state. Possible values include: 'Succeeded', 'Failed', 'Canceled',
   * 'InProgress', 'Deleting'
  */
  readonly provisioningState?: string;
  /**
   * Name servers.
  */
  readonly nameServers?: string[];
  /**
   * <code>true</code> if domain privacy is enabled for this domain; otherwise, <code>false</code>.
  */
  privacy?: boolean;
  /**
   * Domain creation timestamp.
  */
  readonly createdTime?: Date;
  /**
   * Domain expiration timestamp.
  */
  readonly expirationTime?: Date;
  /**
   * Timestamp when the domain was renewed last time.
  */
  readonly lastRenewedTime?: Date;
  /**
   * <code>true</code> if the domain should be automatically renewed; otherwise,
   * <code>false</code>.
  */
  autoRenew?: boolean;
  /**
   * <code>true</code> if Azure can assign this domain to App Service apps; otherwise,
   * <code>false</code>. This value will be <code>true</code> if domain registration status is
   * active and
   * it is hosted on name servers Azure has programmatic access to.
  */
  readonly readyForDnsRecordManagement?: boolean;
  /**
   * All hostnames derived from the domain and assigned to Azure resources.
  */
  readonly managedHostNames?: HostName[];
  /**
   * Legal agreement consent.
  */
  consent: DomainPurchaseConsent;
  /**
   * Reasons why domain is not renewable.
  */
  readonly domainNotRenewableReasons?: string[];
  /**
   * Current DNS type. Possible values include: 'AzureDns', 'DefaultDomainRegistrarDns'
  */
  dnsType?: string;
  /**
   * Azure DNS Zone to use
  */
  dnsZoneId?: string;
  /**
   * Target DNS type (would be used for migration). Possible values include: 'AzureDns',
   * 'DefaultDomainRegistrarDns'
  */
  targetDnsType?: string;
  authCode?: string;
}

/**
 * Domain recommendation search parameters.
*/
export interface DomainRecommendationSearchParameters {
  /**
   * Keywords to be used for generating domain recommendations.
  */
  keywords?: string;
  /**
   * Maximum number of recommendations.
  */
  maxDomainRecommendations?: number;
}

/**
 * Legal agreement for a top level domain.
*/
export interface TldLegalAgreement {
  /**
   * Unique identifier for the agreement.
  */
  agreementKey: string;
  /**
   * Agreement title.
  */
  title: string;
  /**
   * Agreement details.
  */
  content: string;
  /**
   * URL where a copy of the agreement details is hosted.
  */
  url?: string;
}

/**
 * A top level domain object.
*/
export interface TopLevelDomain extends ProxyOnlyResource {
  /**
   * If <code>true</code>, then the top level domain supports domain privacy; otherwise,
   * <code>false</code>.
  */
  privacy?: boolean;
}

/**
 * Options for retrieving the list of top level domain legal agreements.
*/
export interface TopLevelDomainAgreementOption {
  /**
   * If <code>true</code>, then the list of agreements will include agreements for domain privacy
   * as well; otherwise, <code>false</code>.
  */
  includePrivacy?: boolean;
  /**
   * If <code>true</code>, then the list of agreements will include agreements for domain transfer
   * as well; otherwise, <code>false</code>.
  */
  forTransfer?: boolean;
}

/**
 * SSL certificate for an app.
*/
export interface Certificate extends Resource {
  /**
   * Friendly name of the certificate.
  */
  readonly friendlyName?: string;
  /**
   * Subject name of the certificate.
  */
  readonly subjectName?: string;
  /**
   * Host names the certificate applies to.
  */
  hostNames?: string[];
  /**
   * Pfx blob.
  */
  pfxBlob?: Buffer;
  /**
   * App name.
  */
  readonly siteName?: string;
  /**
   * Self link.
  */
  readonly selfLink?: string;
  /**
   * Certificate issuer.
  */
  readonly issuer?: string;
  /**
   * Certificate issue Date.
  */
  readonly issueDate?: Date;
  /**
   * Certificate expriration date.
  */
  readonly expirationDate?: Date;
  /**
   * Certificate password.
  */
  password: string;
  /**
   * Certificate thumbprint.
  */
  readonly thumbprint?: string;
  /**
   * Is the certificate valid?.
  */
  readonly valid?: boolean;
  /**
   * Raw bytes of .cer file
  */
  readonly cerBlob?: Buffer;
  /**
   * Public key hash.
  */
  readonly publicKeyHash?: string;
  /**
   * Specification for the App Service Environment to use for the certificate.
  */
  readonly hostingEnvironmentProfile?: HostingEnvironmentProfile;
  /**
   * Key Vault Csm resource Id.
  */
  keyVaultId?: string;
  /**
   * Key Vault secret name.
  */
  keyVaultSecretName?: string;
  /**
   * Status of the Key Vault secret. Possible values include: 'Initialized',
   * 'WaitingOnCertificateOrder', 'Succeeded', 'CertificateOrderFailed',
   * 'OperationNotPermittedOnKeyVault', 'AzureServiceUnauthorizedToAccessKeyVault',
   * 'KeyVaultDoesNotExist', 'KeyVaultSecretDoesNotExist', 'UnknownError', 'ExternalPrivateKey',
   * 'Unknown'
  */
  readonly keyVaultSecretStatus?: string;
  /**
   * Resource ID of the associated App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
  */
  serverFarmId?: string;
}

/**
 * ARM resource for a certificate.
*/
export interface CertificatePatchResource extends ProxyOnlyResource {
  /**
   * Friendly name of the certificate.
  */
  readonly friendlyName?: string;
  /**
   * Subject name of the certificate.
  */
  readonly subjectName?: string;
  /**
   * Host names the certificate applies to.
  */
  hostNames?: string[];
  /**
   * Pfx blob.
  */
  pfxBlob?: Buffer;
  /**
   * App name.
  */
  readonly siteName?: string;
  /**
   * Self link.
  */
  readonly selfLink?: string;
  /**
   * Certificate issuer.
  */
  readonly issuer?: string;
  /**
   * Certificate issue Date.
  */
  readonly issueDate?: Date;
  /**
   * Certificate expriration date.
  */
  readonly expirationDate?: Date;
  /**
   * Certificate password.
  */
  password: string;
  /**
   * Certificate thumbprint.
  */
  readonly thumbprint?: string;
  /**
   * Is the certificate valid?.
  */
  readonly valid?: boolean;
  /**
   * Raw bytes of .cer file
  */
  readonly cerBlob?: Buffer;
  /**
   * Public key hash.
  */
  readonly publicKeyHash?: string;
  /**
   * Specification for the App Service Environment to use for the certificate.
  */
  readonly hostingEnvironmentProfile?: HostingEnvironmentProfile;
  /**
   * Key Vault Csm resource Id.
  */
  keyVaultId?: string;
  /**
   * Key Vault secret name.
  */
  keyVaultSecretName?: string;
  /**
   * Status of the Key Vault secret. Possible values include: 'Initialized',
   * 'WaitingOnCertificateOrder', 'Succeeded', 'CertificateOrderFailed',
   * 'OperationNotPermittedOnKeyVault', 'AzureServiceUnauthorizedToAccessKeyVault',
   * 'KeyVaultDoesNotExist', 'KeyVaultSecretDoesNotExist', 'UnknownError', 'ExternalPrivateKey',
   * 'Unknown'
  */
  readonly keyVaultSecretStatus?: string;
  /**
   * Resource ID of the associated App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
  */
  serverFarmId?: string;
}

/**
 * Specification for using a Virtual Network.
*/
export interface VirtualNetworkProfile {
  /**
   * Resource id of the Virtual Network.
  */
  id?: string;
  /**
   * Name of the Virtual Network (read-only).
  */
  readonly name?: string;
  /**
   * Resource type of the Virtual Network (read-only).
  */
  readonly type?: string;
  /**
   * Subnet within the Virtual Network.
  */
  subnet?: string;
}

/**
 * Worker pool of an App Service Environment.
*/
export interface WorkerPool {
  /**
   * Worker size ID for referencing this worker pool.
  */
  workerSizeId?: number;
  /**
   * Shared or dedicated app hosting. Possible values include: 'Shared', 'Dedicated', 'Dynamic'
  */
  computeMode?: string;
  /**
   * VM size of the worker pool instances.
  */
  workerSize?: string;
  /**
   * Number of instances in the worker pool.
  */
  workerCount?: number;
  /**
   * Names of all instances in the worker pool (read only).
  */
  readonly instanceNames?: string[];
}

/**
 * Virtual IP mapping.
*/
export interface VirtualIPMapping {
  /**
   * Virtual IP address.
  */
  virtualIP?: string;
  /**
   * Internal HTTP port.
  */
  internalHttpPort?: number;
  /**
   * Internal HTTPS port.
  */
  internalHttpsPort?: number;
  /**
   * Is virtual IP mapping in use.
  */
  inUse?: boolean;
}

/**
 * Stamp capacity information.
*/
export interface StampCapacity {
  /**
   * Name of the stamp.
  */
  name?: string;
  /**
   * Available capacity (# of machines, bytes of storage etc...).
  */
  availableCapacity?: number;
  /**
   * Total capacity (# of machines, bytes of storage etc...).
  */
  totalCapacity?: number;
  /**
   * Name of the unit.
  */
  unit?: string;
  /**
   * Shared/dedicated workers. Possible values include: 'Shared', 'Dedicated', 'Dynamic'
  */
  computeMode?: string;
  /**
   * Size of the machines. Possible values include: 'Small', 'Medium', 'Large', 'D1', 'D2', 'D3',
   * 'Default'
  */
  workerSize?: string;
  /**
   * Size ID of machines:
   * 0 - Small
   * 1 - Medium
   * 2 - Large
  */
  workerSizeId?: number;
  /**
   * If <code>true</code>, it includes basic apps.
   * Basic apps are not used for capacity allocation.
  */
  excludeFromCapacityAllocation?: boolean;
  /**
   * <code>true</code> if capacity is applicable for all apps; otherwise, <code>false</code>.
  */
  isApplicableForAllComputeModes?: boolean;
  /**
   * Shared or Dedicated.
  */
  siteMode?: string;
  /**
   * Is this a linux stamp capacity
  */
  isLinux?: boolean;
}

/**
 * Network access control entry.
*/
export interface NetworkAccessControlEntry {
  /**
   * Action object. Possible values include: 'Permit', 'Deny'
  */
  action?: string;
  /**
   * Description of network access control entry.
  */
  description?: string;
  /**
   * Order of precedence.
  */
  order?: number;
  /**
   * Remote subnet.
  */
  remoteSubnet?: string;
}

/**
 * Description of an App Service Environment.
*/
export interface AppServiceEnvironment {
  /**
   * Name of the App Service Environment.
  */
  name: string;
  /**
   * Location of the App Service Environment, e.g. "West US".
  */
  location: string;
  /**
   * Provisioning state of the App Service Environment. Possible values include: 'Succeeded',
   * 'Failed', 'Canceled', 'InProgress', 'Deleting'
  */
  readonly provisioningState?: string;
  /**
   * Current status of the App Service Environment. Possible values include: 'Preparing', 'Ready',
   * 'Scaling', 'Deleting'
  */
  readonly status?: string;
  /**
   * Name of the Virtual Network for the App Service Environment.
  */
  vnetName?: string;
  /**
   * Resource group of the Virtual Network.
  */
  vnetResourceGroupName?: string;
  /**
   * Subnet of the Virtual Network.
  */
  vnetSubnetName?: string;
  /**
   * Description of the Virtual Network.
  */
  virtualNetwork: VirtualNetworkProfile;
  /**
   * Specifies which endpoints to serve internally in the Virtual Network for the App Service
   * Environment. Possible values include: 'None', 'Web', 'Publishing'
  */
  internalLoadBalancingMode?: string;
  /**
   * Front-end VM size, e.g. "Medium", "Large".
  */
  multiSize?: string;
  /**
   * Number of front-end instances.
  */
  multiRoleCount?: number;
  /**
   * Description of worker pools with worker size IDs, VM sizes, and number of workers in each
   * pool.
  */
  workerPools: WorkerPool[];
  /**
   * Number of IP SSL addresses reserved for the App Service Environment.
  */
  ipsslAddressCount?: number;
  /**
   * Edition of the metadata database for the App Service Environment, e.g. "Standard".
  */
  readonly databaseEdition?: string;
  /**
   * Service objective of the metadata database for the App Service Environment, e.g. "S0".
  */
  readonly databaseServiceObjective?: string;
  /**
   * Number of upgrade domains of the App Service Environment.
  */
  readonly upgradeDomains?: number;
  /**
   * Subscription of the App Service Environment.
  */
  readonly subscriptionId?: string;
  /**
   * DNS suffix of the App Service Environment.
  */
  dnsSuffix?: string;
  /**
   * Last deployment action on the App Service Environment.
  */
  readonly lastAction?: string;
  /**
   * Result of the last deployment action on the App Service Environment.
  */
  readonly lastActionResult?: string;
  /**
   * List of comma separated strings describing which VM sizes are allowed for front-ends.
  */
  readonly allowedMultiSizes?: string;
  /**
   * List of comma separated strings describing which VM sizes are allowed for workers.
  */
  readonly allowedWorkerSizes?: string;
  /**
   * Maximum number of VMs in the App Service Environment.
  */
  readonly maximumNumberOfMachines?: number;
  /**
   * Description of IP SSL mapping for the App Service Environment.
  */
  readonly vipMappings?: VirtualIPMapping[];
  /**
   * Current total, used, and available worker capacities.
  */
  readonly environmentCapacities?: StampCapacity[];
  /**
   * Access control list for controlling traffic to the App Service Environment.
  */
  networkAccessControlList?: NetworkAccessControlEntry[];
  /**
   * True/false indicating whether the App Service Environment is healthy.
  */
  readonly environmentIsHealthy?: boolean;
  /**
   * Detailed message about with results of the last check of the App Service Environment.
  */
  readonly environmentStatus?: string;
  /**
   * Resource group of the App Service Environment.
  */
  readonly resourceGroup?: string;
  /**
   * Scale factor for front-ends.
  */
  frontEndScaleFactor?: number;
  /**
   * Default Scale Factor for FrontEnds.
  */
  readonly defaultFrontEndScaleFactor?: number;
  /**
   * API Management Account associated with the App Service Environment.
  */
  apiManagementAccountId?: string;
  /**
   * <code>true</code> if the App Service Environment is suspended; otherwise, <code>false</code>.
   * The environment can be suspended, e.g. when the management endpoint is no longer available
   * (most likely because NSG blocked the incoming traffic).
  */
  suspended?: boolean;
  /**
   * True/false indicating whether the App Service Environment is suspended. The environment can be
   * suspended e.g. when the management endpoint is no longer available
   * (most likely because NSG blocked the incoming traffic).
  */
  dynamicCacheEnabled?: boolean;
  /**
   * Custom settings for changing the behavior of the App Service Environment.
  */
  clusterSettings?: NameValuePair[];
  /**
   * User added ip ranges to whitelist on ASE db
  */
  userWhitelistedIpRanges?: string[];
  /**
   * Flag that displays whether an ASE has linux workers or not
  */
  hasLinuxWorkers?: boolean;
  /**
   * Key Vault ID for ILB App Service Environment default SSL certificate
  */
  sslCertKeyVaultId?: string;
  /**
   * Key Vault Secret Name for ILB App Service Environment default SSL certificate
  */
  sslCertKeyVaultSecretName?: string;
}

/**
 * Localizable string object containing the name and a localized value.
*/
export interface LocalizableString {
  /**
   * Non-localized name.
  */
  value?: string;
  /**
   * Localized name.
  */
  localizedValue?: string;
}

/**
 * Usage of the quota resource.
*/
export interface CsmUsageQuota {
  /**
   * Units of measurement for the quota resourse.
  */
  unit?: string;
  /**
   * Next reset time for the resource counter.
  */
  nextResetTime?: Date;
  /**
   * The current value of the resource counter.
  */
  currentValue?: number;
  /**
   * The resource limit.
  */
  limit?: number;
  /**
   * Quota name.
  */
  name?: LocalizableString;
}

/**
 * Body of the error response returned from the API.
*/
export interface ErrorEntity {
  /**
   * Type of error.
  */
  extendedCode?: string;
  /**
   * Message template.
  */
  messageTemplate?: string;
  /**
   * Parameters for the template.
  */
  parameters?: string[];
  /**
   * Inner errors.
  */
  innerErrors?: ErrorEntity[];
  /**
   * Basic error code.
  */
  code?: string;
  /**
   * Any details of the error.
  */
  message?: string;
}

/**
 * An operation on a resource.
*/
export interface Operation {
  /**
   * Operation ID.
  */
  id?: string;
  /**
   * Operation name.
  */
  name?: string;
  /**
   * The current status of the operation. Possible values include: 'InProgress', 'Failed',
   * 'Succeeded', 'TimedOut', 'Created'
  */
  status?: string;
  /**
   * Any errors associate with the operation.
  */
  errors?: ErrorEntity[];
  /**
   * Time when operation has started.
  */
  createdTime?: Date;
  /**
   * Time when operation has been updated.
  */
  modifiedTime?: Date;
  /**
   * Time when operation will expire.
  */
  expirationTime?: Date;
  /**
   * Applicable only for stamp operation ids.
  */
  geoMasterOperationId?: string;
}

/**
 * Name of a metric for any resource .
*/
export interface ResourceMetricName {
  /**
   * metric name value.
  */
  readonly value?: string;
  /**
   * Localized metric name value.
  */
  readonly localizedValue?: string;
}

/**
 * Resource metric property.
*/
export interface ResourceMetricProperty {
  /**
   * Key for resource metric property.
  */
  key?: string;
  /**
   * Value of pair.
  */
  value?: string;
}

/**
 * Value of resource metric.
*/
export interface ResourceMetricValue {
  /**
   * Value timestamp.
  */
  readonly timestamp?: string;
  /**
   * Value average.
  */
  readonly average?: number;
  /**
   * Value minimum.
  */
  readonly minimum?: number;
  /**
   * Value maximum.
  */
  readonly maximum?: number;
  /**
   * Value total.
  */
  readonly total?: number;
  /**
   * Value count.
  */
  readonly count?: number;
  /**
   * Resource metric properties collection.
  */
  readonly properties?: ResourceMetricProperty[];
}

/**
 * Object representing a metric for any resource .
*/
export interface ResourceMetric {
  /**
   * Name of metric.
  */
  readonly name?: ResourceMetricName;
  /**
   * Metric unit.
  */
  readonly unit?: string;
  /**
   * Metric granularity. E.g PT1H, PT5M, P1D
  */
  readonly timeGrain?: string;
  /**
   * Metric start time.
  */
  readonly startTime?: Date;
  /**
   * Metric end time.
  */
  readonly endTime?: Date;
  /**
   * Metric resource Id.
  */
  readonly resourceId?: string;
  /**
   * Resource Id.
  */
  readonly id?: string;
  /**
   * Metric values.
  */
  readonly metricValues?: ResourceMetricValue[];
  /**
   * Resource metric properties collection.
  */
  readonly properties?: ResourceMetricProperty[];
}

/**
 * Class Representing Solution for problems detected.
*/
export interface Solution {
  /**
   * Solution Id.
  */
  id?: number;
  /**
   * Display Name of the solution
  */
  displayName?: string;
  /**
   * Order of the solution.
  */
  order?: number;
  /**
   * Description of the solution
  */
  description?: string;
  /**
   * Type of Solution. Possible values include: 'QuickSolution', 'DeepInvestigation',
   * 'BestPractices'
  */
  type?: string;
  /**
   * Solution Data.
  */
  data?: NameValuePair[][];
  /**
   * Solution Metadata.
  */
  metadata?: NameValuePair[][];
}

/**
 * Class representing Abnormal Time Period detected.
*/
export interface DetectorAbnormalTimePeriod {
  /**
   * Start time of the corelated event
  */
  startTime?: Date;
  /**
   * End time of the corelated event
  */
  endTime?: Date;
  /**
   * Message describing the event
  */
  message?: string;
  /**
   * Represents the name of the Detector
  */
  source?: string;
  /**
   * Represents the rank of the Detector
  */
  priority?: number;
  /**
   * Downtime metadata
  */
  metaData?: NameValuePair[][];
  /**
   * Represents the type of the Detector. Possible values include: 'ServiceIncident',
   * 'AppDeployment', 'AppCrash', 'RuntimeIssueDetected', 'AseDeployment', 'UserIssue',
   * 'PlatformIssue', 'Other'
  */
  type?: string;
  /**
   * List of proposed solutions
  */
  solutions?: Solution[];
}

/**
 * Class representing Abnormal Time Period identified in diagnosis
*/
export interface AbnormalTimePeriod {
  /**
   * Start time of the downtime
  */
  startTime?: Date;
  /**
   * End time of the downtime
  */
  endTime?: Date;
  /**
   * List of Possible Cause of downtime
  */
  events?: DetectorAbnormalTimePeriod[];
  /**
   * List of proposed solutions
  */
  solutions?: Solution[];
}

/**
 * Class representing detector definition
*/
export interface DetectorDefinition extends ProxyOnlyResource {
  /**
   * Display name of the detector
  */
  readonly displayName?: string;
  /**
   * Description of the detector
  */
  readonly description?: string;
  /**
   * Detector Rank
  */
  readonly rank?: number;
  /**
   * Flag representing whether detector is enabled or not.
  */
  readonly isEnabled?: boolean;
}

/**
 * Class representing Diagnostic Metric
*/
export interface DiagnosticMetricSample {
  /**
   * Time at which metric is measured
  */
  timestamp?: Date;
  /**
   * Role Instance. Null if this counter is not per instance
   * This is returned and should be whichever instance name we desire to be returned
   * i.e. CPU and Memory return RDWORKERNAME (LargeDed..._IN_0)
   * where RDWORKERNAME is Machine name below and RoleInstance name in parenthesis
  */
  roleInstance?: string;
  /**
   * Total value of the metric. If multiple measurements are made this will have sum of all.
  */
  total?: number;
  /**
   * Maximum of the metric sampled during the time period
  */
  maximum?: number;
  /**
   * Minimum of the metric sampled during the time period
  */
  minimum?: number;
  /**
   * Whether the values are aggregates across all workers or not
  */
  isAggregated?: boolean;
}

/**
 * Class representing Diagnostic Metric information
*/
export interface DiagnosticMetricSet {
  /**
   * Name of the metric
  */
  name?: string;
  /**
   * Metric's unit
  */
  unit?: string;
  /**
   * Start time of the period
  */
  startTime?: Date;
  /**
   * End time of the period
  */
  endTime?: Date;
  /**
   * Presented time grain. Supported grains at the moment are PT1M, PT1H, P1D
  */
  timeGrain?: string;
  /**
   * Collection of metric values for the selected period based on the
   * {Microsoft.Web.Hosting.Administration.DiagnosticMetricSet.TimeGrain}
  */
  values?: DiagnosticMetricSample[];
}

/**
 * Class representing data source used by the detectors
*/
export interface DataSource {
  /**
   * Instrunctions if any for the data source
  */
  instructions?: string[];
  /**
   * Datasource Uri Links
  */
  dataSourceUri?: NameValuePair[];
}

export interface ResponseMetaData {
  /**
   * Source of the Data
  */
  dataSource?: DataSource;
}

/**
 * Class Representing Detector Evidence used for analysis
*/
export interface AnalysisData {
  /**
   * Name of the Detector
  */
  source?: string;
  /**
   * Detector Definition
  */
  detectorDefinition?: DetectorDefinition;
  /**
   * Source Metrics
  */
  metrics?: DiagnosticMetricSet[];
  /**
   * Additional Source Data
  */
  data?: NameValuePair[][];
  /**
   * Detector Meta Data
  */
  detectorMetaData?: ResponseMetaData;
}

/**
 * Definition of Analysis
*/
export interface AnalysisDefinition extends ProxyOnlyResource {
  /**
   * Description of the Analysis
  */
  readonly description?: string;
}

/**
 * Column definition
*/
export interface DataTableResponseColumn {
  /**
   * Name of the column
  */
  columnName?: string;
  /**
   * Data type which looks like 'String' or 'Int32'.
  */
  dataType?: string;
  /**
   * Column Type
  */
  columnType?: string;
}

/**
 * Data Table which defines columns and raw row values
*/
export interface DataTableResponseObject {
  /**
   * Name of the table
  */
  tableName?: string;
  /**
   * List of columns with data types
  */
  columns?: DataTableResponseColumn[];
  /**
   * Raw row values
  */
  rows?: string[][];
}

/**
 * Definition of Detector
*/
export interface DetectorInfo {
  /**
   * Short description of the detector and its purpose
  */
  readonly description?: string;
  /**
   * Support Category
  */
  readonly category?: string;
  /**
   * Support Sub Category
  */
  readonly subCategory?: string;
  /**
   * Support Topic Id
  */
  readonly supportTopicId?: string;
}

/**
 * Instructions for rendering the data
*/
export interface Rendering {
  /**
   * Rendering Type. Possible values include: 'NoGraph', 'Table', 'TimeSeries',
   * 'TimeSeriesPerInstance'
  */
  type?: string;
  /**
   * Title of data
  */
  title?: string;
  /**
   * Description of the data that will help it be interpreted
  */
  description?: string;
}

/**
 * Set of data with rendering instructions
*/
export interface DiagnosticData {
  /**
   * Data in table form
  */
  table?: DataTableResponseObject;
  /**
   * Properties that describe how the table should be rendered
  */
  renderingProperties?: Rendering;
}

/**
 * Class representing Response from Detector
*/
export interface DetectorResponse extends ProxyOnlyResource {
  /**
   * metadata for the detector
  */
  metadata?: DetectorInfo;
  /**
   * Data Set
  */
  dataset?: DiagnosticData[];
}

/**
 * Class representing a diagnostic analysis done on an application
*/
export interface DiagnosticAnalysis extends ProxyOnlyResource {
  /**
   * Start time of the period
  */
  startTime?: Date;
  /**
   * End time of the period
  */
  endTime?: Date;
  /**
   * List of time periods.
  */
  abnormalTimePeriods?: AbnormalTimePeriod[];
  /**
   * Data by each detector
  */
  payload?: AnalysisData[];
  /**
   * Data by each detector for detectors that did not corelate
  */
  nonCorrelatedDetectors?: DetectorDefinition[];
}

/**
 * Class representing detector definition
*/
export interface DiagnosticCategory extends ProxyOnlyResource {
  /**
   * Description of the diagnostic category
  */
  readonly description?: string;
}

/**
 * Class representing Reponse from Diagnostic Detectors
*/
export interface DiagnosticDetectorResponse extends ProxyOnlyResource {
  /**
   * Start time of the period
  */
  startTime?: Date;
  /**
   * End time of the period
  */
  endTime?: Date;
  /**
   * Flag representing Issue was detected.
  */
  issueDetected?: boolean;
  /**
   * Detector's definition
  */
  detectorDefinition?: DetectorDefinition;
  /**
   * Metrics provided by the detector
  */
  metrics?: DiagnosticMetricSet[];
  /**
   * List of Correlated events found by the detector
  */
  abnormalTimePeriods?: DetectorAbnormalTimePeriod[];
  /**
   * Additional Data that detector wants to send.
  */
  data?: NameValuePair[][];
  /**
   * Meta Data
  */
  responseMetaData?: ResponseMetaData;
}

/**
 * Application stack minor version.
*/
export interface StackMinorVersion {
  /**
   * Application stack minor version (display only).
  */
  displayVersion?: string;
  /**
   * Application stack minor version (runtime only).
  */
  runtimeVersion?: string;
  /**
   * <code>true</code> if this is the default minor version; otherwise, <code>false</code>.
  */
  isDefault?: boolean;
}

/**
 * Application stack major version.
*/
export interface StackMajorVersion {
  /**
   * Application stack major version (display only).
  */
  displayVersion?: string;
  /**
   * Application stack major version (runtime only).
  */
  runtimeVersion?: string;
  /**
   * <code>true</code> if this is the default major version; otherwise, <code>false</code>.
  */
  isDefault?: boolean;
  /**
   * Minor versions associated with the major version.
  */
  minorVersions?: StackMinorVersion[];
}

/**
 * Application stack.
*/
export interface ApplicationStack {
  /**
   * Application stack name.
  */
  name?: string;
  /**
   * Application stack display name.
  */
  display?: string;
  /**
   * Application stack dependency.
  */
  dependency?: string;
  /**
   * List of major versions available.
  */
  majorVersions?: StackMajorVersion[];
  /**
   * List of frameworks associated with application stack.
  */
  frameworks?: ApplicationStack[];
}

/**
 * Represents a recommendation result generated by the recommendation engine.
*/
export interface Recommendation extends ProxyOnlyResource {
  /**
   * Timestamp when this instance was created.
  */
  creationTime?: Date;
  /**
   * A GUID value that each recommendation object is associated with.
  */
  recommendationId?: string;
  /**
   * Full ARM resource ID string that this recommendation object is associated with.
  */
  resourceId?: string;
  /**
   * Name of a resource type this recommendation applies, e.g. Subscription, ServerFarm, Site.
   * Possible values include: 'ServerFarm', 'Subscription', 'WebSite'
  */
  resourceScope?: string;
  /**
   * Unique name of the rule.
  */
  ruleName?: string;
  /**
   * UI friendly name of the rule (may not be unique).
  */
  displayName?: string;
  /**
   * Recommendation text.
  */
  message?: string;
  /**
   * Level indicating how critical this recommendation can impact. Possible values include:
   * 'Critical', 'Warning', 'Information', 'NonUrgentSuggestion'
  */
  level?: string;
  /**
   * List of channels that this recommendation can apply. Possible values include: 'Notification',
   * 'Api', 'Email', 'Webhook', 'All'
  */
  channels?: string;
  /**
   * The list of category tags that this recommendation belongs to.
  */
  readonly categoryTags?: string[];
  /**
   * Name of action recommended by this object.
  */
  actionName?: string;
  /**
   * True if this recommendation is still valid (i.e. "actionable"). False if it is invalid.
  */
  enabled?: number;
  /**
   * The list of states of this recommendation. If it's null then it shoud be considered "Active".
  */
  states?: string[];
  /**
   * The beginning time in UTC of a range that the recommendation refers to.
  */
  startTime?: Date;
  /**
   * The end time in UTC of a range that the recommendation refers to.
  */
  endTime?: Date;
  /**
   * When to notify this recommendation next in UTC. Null means that this will never be notified
   * anymore.
  */
  nextNotificationTime?: Date;
  /**
   * Date and time in UTC when this notification expires.
  */
  notificationExpirationTime?: Date;
  /**
   * Last timestamp in UTC this instance was actually notified. Null means that this recommendation
   * hasn't been notified yet.
  */
  notifiedTime?: Date;
  /**
   * A metric value measured by the rule.
  */
  score?: number;
  /**
   * True if this is associated with a dynamically added rule
  */
  isDynamic?: boolean;
  /**
   * Extension name of the portal if exists.
  */
  extensionName?: string;
  /**
   * Deep link to a blade on the portal.
  */
  bladeName?: string;
  /**
   * Forward link to an external document associated with the rule.
  */
  forwardLink?: string;
}

/**
 * Represents a recommendation rule that the recommendation engine can perform.
*/
export interface RecommendationRule extends ProxyOnlyResource {
  /**
   * Unique name of the rule.
  */
  recommendationName?: string;
  /**
   * UI friendly name of the rule.
  */
  displayName?: string;
  /**
   * Localized name of the rule (Good for UI).
  */
  message?: string;
  /**
   * Recommendation ID of an associated recommendation object tied to the rule, if exists.
   * If such an object doesn't exist, it is set to null.
  */
  recommendationId?: string;
  /**
   * Localized detailed description of the rule.
  */
  description?: string;
  /**
   * Name of action that is recommended by this rule in string.
  */
  actionName?: string;
  /**
   * Level of impact indicating how critical this rule is. Possible values include: 'Critical',
   * 'Warning', 'Information', 'NonUrgentSuggestion'
  */
  level?: string;
  /**
   * List of available channels that this rule applies. Possible values include: 'Notification',
   * 'Api', 'Email', 'Webhook', 'All'
  */
  channels?: string;
  /**
   * The list of category tags that this recommendation rule belongs to.
  */
  readonly categoryTags?: string[];
  /**
   * True if this is associated with a dynamically added rule
  */
  isDynamic?: boolean;
  /**
   * Extension name of the portal if exists. Applicable to dynamic rule only.
  */
  extensionName?: string;
  /**
   * Deep link to a blade on the portal. Applicable to dynamic rule only.
  */
  bladeName?: string;
  /**
   * Forward link to an external document associated with the rule. Applicable to dynamic rule
   * only.
  */
  forwardLink?: string;
}

/**
 * App Service billing entity that contains information about meter which the Azure billing system
 * utilizes to charge users for services.
*/
export interface BillingMeter extends ProxyOnlyResource {
  /**
   * Meter GUID onboarded in Commerce
  */
  meterId?: string;
  /**
   * Azure Location of billable resource
  */
  billingLocation?: string;
  /**
   * Short Name from App Service Azure pricing Page
  */
  shortName?: string;
  /**
   * Friendly name of the meter
  */
  friendlyName?: string;
  /**
   * App Service ResourceType meter used for
  */
  resourceType?: string;
  /**
   * App Service OS type meter used for
  */
  osType?: string;
}

/**
 * Object with a list of the resources that need to be moved and the resource group they should be
 * moved to.
*/
export interface CsmMoveResourceEnvelope {
  targetResourceGroup?: string;
  resources?: string[];
}

/**
 * Geographical region.
*/
export interface GeoRegion extends ProxyOnlyResource {
  /**
   * Region description.
  */
  readonly description?: string;
  /**
   * Display name for region.
  */
  readonly displayName?: string;
}

/**
 * Information needed to create resources on an App Service Environment.
*/
export interface HostingEnvironmentDeploymentInfo {
  /**
   * Name of the App Service Environment.
  */
  name?: string;
  /**
   * Location of the App Service Environment.
  */
  location?: string;
}

/**
 * List of available locations (regions or App Service Environments) for
 * deployment of App Service resources.
*/
export interface DeploymentLocations {
  /**
   * Available regions.
  */
  locations?: GeoRegion[];
  /**
   * Available App Service Environments with full descriptions of the environments.
  */
  hostingEnvironments?: AppServiceEnvironment[];
  /**
   * Available App Service Environments with basic information.
  */
  hostingEnvironmentDeploymentInfos?: HostingEnvironmentDeploymentInfo[];
}

/**
 * A Global SKU Description.
*/
export interface GlobalCsmSkuDescription {
  /**
   * Name of the resource SKU.
  */
  name?: string;
  /**
   * Service Tier of the resource SKU.
  */
  tier?: string;
  /**
   * Size specifier of the resource SKU.
  */
  size?: string;
  /**
   * Family code of the resource SKU.
  */
  family?: string;
  /**
   * Min, max, and default scale values of the SKU.
  */
  capacity?: SkuCapacity;
  /**
   * Locations of the SKU.
  */
  locations?: string[];
  /**
   * Capabilities of the SKU, e.g., is traffic manager enabled?
  */
  capabilities?: Capability[];
}

/**
 * Premier add-on offer.
*/
export interface PremierAddOnOffer extends ProxyOnlyResource {
  /**
   * Premier add on SKU.
  */
  sku?: string;
  /**
   * Premier add on offer Product.
  */
  product?: string;
  /**
   * Premier add on offer Vendor.
  */
  vendor?: string;
  /**
   * <code>true</code> if promotion code is required; otherwise, <code>false</code>.
  */
  promoCodeRequired?: boolean;
  /**
   * Premier add on offer Quota.
  */
  quota?: number;
  /**
   * App Service plans this offer is restricted to. Possible values include: 'None', 'Free',
   * 'Shared', 'Basic', 'Standard', 'Premium'
  */
  webHostingPlanRestrictions?: string;
  /**
   * Privacy policy URL.
  */
  privacyPolicyUrl?: string;
  /**
   * Legal terms URL.
  */
  legalTermsUrl?: string;
  /**
   * Marketplace publisher.
  */
  marketplacePublisher?: string;
  /**
   * Marketplace offer.
  */
  marketplaceOffer?: string;
}

/**
 * Information regarding availbility of a resource name.
*/
export interface ResourceNameAvailability {
  /**
   * <code>true</code> indicates name is valid and available. <code>false</code> indicates the name
   * is invalid, unavailable, or both.
  */
  nameAvailable?: boolean;
  /**
   * <code>Invalid</code> indicates the name provided does not match Azure App Service naming
   * requirements. <code>AlreadyExists</code> indicates that the name is already in use and is
   * therefore unavailable. Possible values include: 'Invalid', 'AlreadyExists'
  */
  reason?: string;
  /**
   * If reason == invalid, provide the user with the reason why the given name is invalid, and
   * provide the resource naming requirements so that the user can select a valid name. If reason
   * == AlreadyExists, explain that resource name is already in use, and direct them to select a
   * different name.
  */
  message?: string;
}

/**
 * Resource name availability request content.
*/
export interface ResourceNameAvailabilityRequest {
  /**
   * Resource name to verify.
  */
  name: string;
  /**
   * Resource type used for verification. Possible values include: 'Site', 'Slot',
   * 'HostingEnvironment', 'PublishingUser', 'Microsoft.Web/sites', 'Microsoft.Web/sites/slots',
   * 'Microsoft.Web/hostingEnvironments', 'Microsoft.Web/publishingUsers'
  */
  type: string;
  /**
   * Is fully qualified domain name.
  */
  isFqdn?: boolean;
}

/**
 * Collection of SKU information.
*/
export interface SkuInfos {
  /**
   * Resource type that this SKU applies to.
  */
  resourceType?: string;
  /**
   * List of SKUs the subscription is able to use.
  */
  skus?: GlobalCsmSkuDescription[];
}

/**
 * The source control OAuth token.
*/
export interface SourceControl extends ProxyOnlyResource {
  /**
   * OAuth access token.
  */
  token?: string;
  /**
   * OAuth access token secret.
  */
  tokenSecret?: string;
  /**
   * OAuth refresh token.
  */
  refreshToken?: string;
  /**
   * OAuth token expiration.
  */
  expirationTime?: Date;
}

/**
 * Resource validation request content.
*/
export interface ValidateRequest {
  /**
   * Resource name to verify.
  */
  name: string;
  /**
   * Resource type used for verification. Possible values include: 'ServerFarm', 'Site'
  */
  type: string;
  /**
   * Expected location of the resource.
  */
  location: string;
  /**
   * ARM resource ID of an App Service plan that would host the app.
  */
  serverFarmId?: string;
  /**
   * Name of the target SKU for the App Service plan.
  */
  skuName?: string;
  /**
   * <code>true</code> if App Service plan is for Linux workers; otherwise, <code>false</code>.
  */
  needLinuxWorkers?: boolean;
  /**
   * <code>true</code> if App Service plan is for Spot instances; otherwise, <code>false</code>.
  */
  isSpot?: boolean;
  /**
   * Target capacity of the App Service plan (number of VM's).
  */
  capacity?: number;
  /**
   * Name of App Service Environment where app or App Service plan should be created.
  */
  hostingEnvironment?: string;
  /**
   * <code>true</code> if App Service plan is running as a windows container
  */
  isXenon?: boolean;
}

/**
 * Error details for when validation fails.
*/
export interface ValidateResponseError {
  /**
   * Validation error code.
  */
  code?: string;
  /**
   * Validation error message.
  */
  message?: string;
}

/**
 * Describes the result of resource validation.
*/
export interface ValidateResponse {
  /**
   * Result of validation.
  */
  status?: string;
  /**
   * Error details for the case when validation fails.
  */
  error?: ValidateResponseError;
}

/**
 * The required set of inputs to validate a VNET
*/
export interface VnetParameters extends ProxyOnlyResource {
  /**
   * The Resource Group of the VNET to be validated
  */
  vnetResourceGroup?: string;
  /**
   * The name of the VNET to be validated
  */
  vnetName?: string;
  /**
   * The subnet name to be validated
  */
  vnetSubnetName?: string;
}

/**
 * A class that describes a test that failed during NSG and UDR validation.
*/
export interface VnetValidationTestFailure extends ProxyOnlyResource {
  /**
   * The name of the test that failed.
  */
  testName?: string;
  /**
   * The details of what caused the failure, e.g. the blocking rule name, etc.
  */
  details?: string;
}

/**
 * A class that describes the reason for a validation failure.
*/
export interface VnetValidationFailureDetails extends ProxyOnlyResource {
  /**
   * A flag describing whether or not validation failed.
  */
  failed?: boolean;
  /**
   * A list of tests that failed in the validation.
  */
  failedTests?: VnetValidationTestFailure[];
}

/**
 * Application logs to file system configuration.
*/
export interface FileSystemApplicationLogsConfig {
  /**
   * Log level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
  */
  level?: string;
}

/**
 * Application logs to Azure table storage configuration.
*/
export interface AzureTableStorageApplicationLogsConfig {
  /**
   * Log level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
  */
  level?: string;
  /**
   * SAS URL to an Azure table with add/query/delete permissions.
  */
  sasUrl: string;
}

/**
 * Application logs azure blob storage configuration.
*/
export interface AzureBlobStorageApplicationLogsConfig {
  /**
   * Log level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
  */
  level?: string;
  /**
   * SAS url to a azure blob container with read/write/list/delete permissions.
  */
  sasUrl?: string;
  /**
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
  */
  retentionInDays?: number;
}

/**
 * Application logs configuration.
*/
export interface ApplicationLogsConfig {
  /**
   * Application logs to file system configuration.
  */
  fileSystem?: FileSystemApplicationLogsConfig;
  /**
   * Application logs to azure table storage configuration.
  */
  azureTableStorage?: AzureTableStorageApplicationLogsConfig;
  /**
   * Application logs to blob storage configuration.
  */
  azureBlobStorage?: AzureBlobStorageApplicationLogsConfig;
}

/**
 * Http logs to azure blob storage configuration.
*/
export interface AzureBlobStorageHttpLogsConfig {
  /**
   * SAS url to a azure blob container with read/write/list/delete permissions.
  */
  sasUrl?: string;
  /**
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
  */
  retentionInDays?: number;
  /**
   * True if configuration is enabled, false if it is disabled and null if configuration is not
   * set.
  */
  enabled?: boolean;
}

/**
 * AzureStorageInfo dictionary resource.
*/
export interface AzureStoragePropertyDictionaryResource extends ProxyOnlyResource {
  /**
   * Azure storage accounts.
  */
  properties?: { [propertyName: string]: AzureStorageInfoValue };
}

/**
 * Database backup settings.
*/
export interface DatabaseBackupSetting {
  /**
   * Database type (e.g. SqlAzure / MySql). Possible values include: 'SqlAzure', 'MySql',
   * 'LocalMySql', 'PostgreSql'
  */
  databaseType: string;
  name?: string;
  /**
   * Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
   * This is used during restore with overwrite connection strings options.
  */
  connectionStringName?: string;
  /**
   * Contains a connection string to a database which is being backed up or restored. If the
   * restore should happen to a new database, the database name inside is the new one.
  */
  connectionString?: string;
}

/**
 * Backup description.
*/
export interface BackupItem extends ProxyOnlyResource {
  /**
   * Id of the backup.
  */
  readonly backupId?: number;
  /**
   * SAS URL for the storage account container which contains this backup.
  */
  readonly storageAccountUrl?: string;
  /**
   * Name of the blob which contains data for this backup.
  */
  readonly blobName?: string;
  /**
   * Name of this backup.
  */
  readonly backupItemName?: string;
  /**
   * Backup status. Possible values include: 'InProgress', 'Failed', 'Succeeded', 'TimedOut',
   * 'Created', 'Skipped', 'PartiallySucceeded', 'DeleteInProgress', 'DeleteFailed', 'Deleted'
  */
  readonly status?: string;
  /**
   * Size of the backup in bytes.
  */
  readonly sizeInBytes?: number;
  /**
   * Timestamp of the backup creation.
  */
  readonly created?: Date;
  /**
   * Details regarding this backup. Might contain an error message.
  */
  readonly log?: string;
  /**
   * List of databases included in the backup.
  */
  readonly databases?: DatabaseBackupSetting[];
  /**
   * True if this backup has been created due to a schedule being triggered.
  */
  readonly scheduled?: boolean;
  /**
   * Timestamp of a last restore operation which used this backup.
  */
  readonly lastRestoreTimeStamp?: Date;
  /**
   * Timestamp when this backup finished.
  */
  readonly finishedTimeStamp?: Date;
  /**
   * Unique correlation identifier. Please use this along with the timestamp while communicating
   * with Azure support.
  */
  readonly correlationId?: string;
  /**
   * Size of the original web app which has been backed up.
  */
  readonly websiteSizeInBytes?: number;
}

/**
 * Description of a backup schedule. Describes how often should be the backup performed and what
 * should be the retention policy.
*/
export interface BackupSchedule {
  /**
   * How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
  */
  frequencyInterval: number;
  /**
   * The unit of time for how often the backup should be executed (e.g. for weekly backup, this
   * should be set to Day and FrequencyInterval should be set to 7). Possible values include:
   * 'Day', 'Hour'
  */
  frequencyUnit: string;
  /**
   * True if the retention policy should always keep at least one backup in the storage account,
   * regardless how old it is; false otherwise.
  */
  keepAtLeastOneBackup: boolean;
  /**
   * After how many days backups should be deleted.
  */
  retentionPeriodInDays: number;
  /**
   * When the schedule should start working.
  */
  startTime?: Date;
  /**
   * Last time when this schedule was triggered.
  */
  readonly lastExecutionTime?: Date;
}

/**
 * Description of a backup which will be performed.
*/
export interface BackupRequest extends ProxyOnlyResource {
  /**
   * Name of the backup.
  */
  backupName?: string;
  /**
   * True if the backup schedule is enabled (must be included in that case), false if the backup
   * schedule should be disabled.
  */
  enabled?: boolean;
  /**
   * SAS URL to the container.
  */
  storageAccountUrl: string;
  /**
   * Schedule for the backup if it is executed periodically.
  */
  backupSchedule?: BackupSchedule;
  /**
   * Databases included in the backup.
  */
  databases?: DatabaseBackupSetting[];
}

/**
 * Database connection string value to type pair.
*/
export interface ConnStringValueTypePair {
  /**
   * Value of pair.
  */
  value: string;
  /**
   * Type of database. Possible values include: 'MySql', 'SQLServer', 'SQLAzure', 'Custom',
   * 'NotificationHub', 'ServiceBus', 'EventHub', 'ApiHub', 'DocDb', 'RedisCache', 'PostgreSQL'
  */
  type: string;
}

/**
 * String dictionary resource.
*/
export interface ConnectionStringDictionary extends ProxyOnlyResource {
  /**
   * Connection strings.
  */
  properties?: { [propertyName: string]: ConnStringValueTypePair };
}

/**
 * Continuous Web Job Information.
*/
export interface ContinuousWebJob extends ProxyOnlyResource {
  /**
   * Job status. Possible values include: 'Initializing', 'Starting', 'Running', 'PendingRestart',
   * 'Stopped'
  */
  status?: string;
  /**
   * Detailed status.
  */
  detailedStatus?: string;
  /**
   * Log URL.
  */
  logUrl?: string;
  /**
   * Run command.
  */
  runCommand?: string;
  /**
   * Job URL.
  */
  url?: string;
  /**
   * Extra Info URL.
  */
  extraInfoUrl?: string;
  /**
   * Job type. Possible values include: 'Continuous', 'Triggered'
  */
  webJobType?: string;
  /**
   * Error information.
  */
  error?: string;
  /**
   * Using SDK?
  */
  usingSdk?: boolean;
  /**
   * Job settings.
  */
  settings?: { [propertyName: string]: any };
}

/**
 * Publishing options for requested profile.
*/
export interface CsmPublishingProfileOptions {
  /**
   * Name of the format. Valid values are:
   * FileZilla3
   * WebDeploy -- default
   * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
  */
  format?: string;
  /**
   * Include the DisasterRecover endpoint if true
  */
  includeDisasterRecoveryEndpoints?: boolean;
}

/**
 * Deployment slot parameters.
*/
export interface CsmSlotEntity {
  /**
   * Destination deployment slot during swap operation.
  */
  targetSlot: string;
  /**
   * <code>true</code> to preserve Virtual Network to the slot during swap; otherwise,
   * <code>false</code>.
  */
  preserveVnet: boolean;
}

/**
 * Custom domain analysis.
*/
export interface CustomHostnameAnalysisResult extends ProxyOnlyResource {
  /**
   * <code>true</code> if hostname is already verified; otherwise, <code>false</code>.
  */
  readonly isHostnameAlreadyVerified?: boolean;
  /**
   * DNS verification test result. Possible values include: 'Passed', 'Failed', 'Skipped'
  */
  readonly customDomainVerificationTest?: string;
  /**
   * Raw failure information if DNS verification fails.
  */
  readonly customDomainVerificationFailureInfo?: ErrorEntity;
  /**
   * <code>true</code> if there is a conflict on a scale unit; otherwise, <code>false</code>.
  */
  readonly hasConflictOnScaleUnit?: boolean;
  /**
   * <code>true</code> if htere is a conflict across subscriptions; otherwise, <code>false</code>.
  */
  readonly hasConflictAcrossSubscription?: boolean;
  /**
   * Name of the conflicting app on scale unit if it's within the same subscription.
  */
  readonly conflictingAppResourceId?: string;
  /**
   * CName records controller can see for this hostname.
  */
  cNameRecords?: string[];
  /**
   * TXT records controller can see for this hostname.
  */
  txtRecords?: string[];
  /**
   * A records controller can see for this hostname.
  */
  aRecords?: string[];
  /**
   * Alternate CName records controller can see for this hostname.
  */
  alternateCNameRecords?: string[];
  /**
   * Alternate TXT records controller can see for this hostname.
  */
  alternateTxtRecords?: string[];
}

/**
 * Details about restoring a deleted app.
*/
export interface DeletedAppRestoreRequest extends ProxyOnlyResource {
  /**
   * ARM resource ID of the deleted app. Example:
   * /subscriptions/{subId}/providers/Microsoft.Web/deletedSites/{deletedSiteId}
  */
  deletedSiteId?: string;
  /**
   * If true, deleted site configuration, in addition to content, will be restored.
  */
  recoverConfiguration?: boolean;
  /**
   * Point in time to restore the deleted app from, formatted as a DateTime string.
   * If unspecified, default value is the time that the app was deleted.
  */
  snapshotTime?: string;
  /**
   * If true, the snapshot is retrieved from DRSecondary endpoint.
  */
  useDRSecondary?: boolean;
}

/**
 * User crendentials used for publishing activity.
*/
export interface Deployment extends ProxyOnlyResource {
  /**
   * Deployment status.
  */
  status?: number;
  /**
   * Details about deployment status.
  */
  message?: string;
  /**
   * Who authored the deployment.
  */
  author?: string;
  /**
   * Who performed the deployment.
  */
  deployer?: string;
  /**
   * Author email.
  */
  authorEmail?: string;
  /**
   * Start time.
  */
  startTime?: Date;
  /**
   * End time.
  */
  endTime?: Date;
  /**
   * True if deployment is currently active, false if completed and null if not started.
  */
  active?: boolean;
  /**
   * Details on deployment.
  */
  details?: string;
}

/**
 * Enabled configuration.
*/
export interface EnabledConfig {
  /**
   * True if configuration is enabled, false if it is disabled and null if configuration is not
   * set.
  */
  enabled?: boolean;
}

/**
 * Http logs to file system configuration.
*/
export interface FileSystemHttpLogsConfig {
  /**
   * Maximum size in megabytes that http log files can use.
   * When reached old log files will be removed to make space for new ones.
   * Value can range between 25 and 100.
  */
  retentionInMb?: number;
  /**
   * Retention in days.
   * Remove files older than X days.
   * 0 or lower means no retention.
  */
  retentionInDays?: number;
  /**
   * True if configuration is enabled, false if it is disabled and null if configuration is not
   * set.
  */
  enabled?: boolean;
}

/**
 * Web Job Information.
*/
export interface FunctionEnvelope extends ProxyOnlyResource {
  /**
   * Function App ID.
  */
  functionAppId?: string;
  /**
   * Script root path URI.
  */
  scriptRootPathHref?: string;
  /**
   * Script URI.
  */
  scriptHref?: string;
  /**
   * Config URI.
  */
  configHref?: string;
  /**
   * Secrets file URI.
  */
  secretsFileHref?: string;
  /**
   * Function URI.
  */
  href?: string;
  /**
   * Config information.
  */
  config?: any;
  /**
   * File list.
  */
  files?: { [propertyName: string]: string };
  /**
   * Test data used when testing via the Azure Portal.
  */
  testData?: string;
}

/**
 * Function secrets.
*/
export interface FunctionSecrets extends ProxyOnlyResource {
  /**
   * Secret key.
  */
  key?: string;
  /**
   * Trigger URL.
  */
  triggerUrl?: string;
}

/**
 * A hostname binding object.
*/
export interface HostNameBinding extends ProxyOnlyResource {
  /**
   * App Service app name.
  */
  siteName?: string;
  /**
   * Fully qualified ARM domain resource URI.
  */
  domainId?: string;
  /**
   * Azure resource name.
  */
  azureResourceName?: string;
  /**
   * Azure resource type. Possible values include: 'Website', 'TrafficManager'
  */
  azureResourceType?: string;
  /**
   * Custom DNS record type. Possible values include: 'CName', 'A'
  */
  customHostNameDnsRecordType?: string;
  /**
   * Hostname type. Possible values include: 'Verified', 'Managed'
  */
  hostNameType?: string;
  /**
   * SSL type. Possible values include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
  */
  sslState?: string;
  /**
   * SSL certificate thumbprint
  */
  thumbprint?: string;
  /**
   * Virtual IP address assigned to the hostname if IP based SSL is enabled.
  */
  readonly virtualIP?: string;
}

/**
 * Http logs configuration.
*/
export interface HttpLogsConfig {
  /**
   * Http logs to file system configuration.
  */
  fileSystem?: FileSystemHttpLogsConfig;
  /**
   * Http logs to azure blob storage configuration.
  */
  azureBlobStorage?: AzureBlobStorageHttpLogsConfig;
}

/**
 * MSDeploy ARM PUT information
*/
export interface MSDeploy extends ProxyOnlyResource {
  /**
   * Package URI
  */
  packageUri?: string;
  /**
   * SQL Connection String
  */
  connectionString?: string;
  /**
   * Database Type
  */
  dbType?: string;
  /**
   * URI of MSDeploy Parameters file. Must not be set if SetParameters is used.
  */
  setParametersXmlFileUri?: string;
  /**
   * MSDeploy Parameters. Must not be set if SetParametersXmlFileUri is used.
  */
  setParameters?: { [propertyName: string]: string };
  /**
   * Controls whether the MSDeploy operation skips the App_Data directory.
   * If set to <code>true</code>, the existing App_Data directory on the destination
   * will not be deleted, and any App_Data directory in the source will be ignored.
   * Setting is <code>false</code> by default.
  */
  skipAppData?: boolean;
  /**
   * Sets the AppOffline rule while the MSDeploy operation executes.
   * Setting is <code>false</code> by default.
  */
  appOffline?: boolean;
}

/**
 * MSDeploy log entry
*/
export interface MSDeployLogEntry {
  /**
   * Timestamp of log entry
  */
  readonly time?: Date;
  /**
   * Log entry type. Possible values include: 'Message', 'Warning', 'Error'
  */
  readonly type?: string;
  /**
   * Log entry message
  */
  readonly message?: string;
}

/**
 * MSDeploy log
*/
export interface MSDeployLog extends ProxyOnlyResource {
  /**
   * List of log entry messages
  */
  readonly entries?: MSDeployLogEntry[];
}

/**
 * MSDeploy ARM response
*/
export interface MSDeployStatus extends ProxyOnlyResource {
  /**
   * Username of deployer
  */
  readonly deployer?: string;
  /**
   * Provisioning state. Possible values include: 'accepted', 'running', 'succeeded', 'failed',
   * 'canceled'
  */
  readonly provisioningState?: string;
  /**
   * Start time of deploy operation
  */
  readonly startTime?: Date;
  /**
   * End time of deploy operation
  */
  readonly endTime?: Date;
  /**
   * Whether the deployment operation has completed
  */
  readonly complete?: boolean;
}

/**
 * MySQL migration request.
*/
export interface MigrateMySqlRequest extends ProxyOnlyResource {
  /**
   * Connection string to the remote MySQL database.
  */
  connectionString: string;
  /**
   * The type of migration operation to be done. Possible values include: 'LocalToRemote',
   * 'RemoteToLocal'
  */
  migrationType: string;
}

/**
 * MySQL migration status.
*/
export interface MigrateMySqlStatus extends ProxyOnlyResource {
  /**
   * Status of the migration task. Possible values include: 'InProgress', 'Failed', 'Succeeded',
   * 'TimedOut', 'Created'
  */
  readonly migrationOperationStatus?: string;
  /**
   * Operation ID for the migration task.
  */
  readonly operationId?: string;
  /**
   * True if the web app has in app MySql enabled
  */
  readonly localMySqlEnabled?: boolean;
}

/**
 * Hybrid Connection for an App Service app.
*/
export interface RelayServiceConnectionEntity extends ProxyOnlyResource {
  entityName?: string;
  entityConnectionString?: string;
  resourceType?: string;
  resourceConnectionString?: string;
  hostname?: string;
  port?: number;
  biztalkUri?: string;
}

/**
 * Full view of network features for an app (presently VNET integration and Hybrid Connections).
*/
export interface NetworkFeatures extends ProxyOnlyResource {
  /**
   * The Virtual Network name.
  */
  readonly virtualNetworkName?: string;
  /**
   * The Virtual Network summary view.
  */
  readonly virtualNetworkConnection?: VnetInfo;
  /**
   * The Hybrid Connections summary view.
  */
  readonly hybridConnections?: RelayServiceConnectionEntity[];
  /**
   * The Hybrid Connection V2 (Service Bus) view.
  */
  readonly hybridConnectionsV2?: HybridConnection[];
}

/**
 * Network trace
*/
export interface NetworkTrace {
  /**
   * Local file path for the captured network trace file.
  */
  path?: string;
  /**
   * Current status of the network trace operation, same as Operation.Status
   * (InProgress/Succeeded/Failed).
  */
  status?: string;
  /**
   * Detailed message of a network trace operation, e.g. error message in case of failure.
  */
  message?: string;
}

/**
 * Performance monitor sample in a set.
*/
export interface PerfMonSample {
  /**
   * Point in time for which counter was measured.
  */
  time?: Date;
  /**
   * Name of the server on which the measurement is made.
  */
  instanceName?: string;
  /**
   * Value of counter at a certain time.
  */
  value?: number;
}

/**
 * Metric information.
*/
export interface PerfMonSet {
  /**
   * Unique key name of the counter.
  */
  name?: string;
  /**
   * Start time of the period.
  */
  startTime?: Date;
  /**
   * End time of the period.
  */
  endTime?: Date;
  /**
   * Presented time grain.
  */
  timeGrain?: string;
  /**
   * Collection of workers that are active during this time.
  */
  values?: PerfMonSample[];
}

/**
 * Performance monitor API response.
*/
export interface PerfMonResponse {
  /**
   * The response code.
  */
  code?: string;
  /**
   * The message.
  */
  message?: string;
  /**
   * The performance monitor counters.
  */
  data?: PerfMonSet;
}

/**
 * Premier add-on.
*/
export interface PremierAddOn extends Resource {
  /**
   * Premier add on SKU.
  */
  sku?: string;
  /**
   * Premier add on Product.
  */
  product?: string;
  /**
   * Premier add on Vendor.
  */
  vendor?: string;
  /**
   * Premier add on Marketplace publisher.
  */
  marketplacePublisher?: string;
  /**
   * Premier add on Marketplace offer.
  */
  marketplaceOffer?: string;
}

/**
 * ARM resource for a PremierAddOn.
*/
export interface PremierAddOnPatchResource extends ProxyOnlyResource {
  /**
   * Premier add on SKU.
  */
  sku?: string;
  /**
   * Premier add on Product.
  */
  product?: string;
  /**
   * Premier add on Vendor.
  */
  vendor?: string;
  /**
   * Premier add on Marketplace publisher.
  */
  marketplacePublisher?: string;
  /**
   * Premier add on Marketplace offer.
  */
  marketplaceOffer?: string;
}

/**
 * Description of a Virtual Network subnet that is useable for private site access.
*/
export interface PrivateAccessSubnet {
  /**
   * The name of the subnet.
  */
  name?: string;
  /**
   * The key (ID) of the subnet.
  */
  key?: number;
}

/**
 * Description of a Virtual Network that is useable for private site access.
*/
export interface PrivateAccessVirtualNetwork {
  /**
   * The name of the Virtual Network.
  */
  name?: string;
  /**
   * The key (ID) of the Virtual Network.
  */
  key?: number;
  /**
   * The ARM uri of the Virtual Network
  */
  resourceId?: string;
  /**
   * A List of subnets that access is allowed to on this Virtual Network. An empty array (but not
   * null) is interpreted to mean that all subnets are allowed within this Virtual Network.
  */
  subnets?: PrivateAccessSubnet[];
}

/**
 * Description of the parameters of Private Access for a Web Site.
*/
export interface PrivateAccess extends ProxyOnlyResource {
  /**
   * Whether private access is enabled or not.
  */
  enabled?: boolean;
  /**
   * The Virtual Networks (and subnets) allowed to access the site privately.
  */
  virtualNetworks?: PrivateAccessVirtualNetwork[];
}

/**
 * Process Thread Information.
*/
export interface ProcessThreadInfo extends ProxyOnlyResource {
  /**
   * Site extension ID.
  */
  readonly identifier?: number;
  /**
   * HRef URI.
  */
  href?: string;
  /**
   * Process URI.
  */
  process?: string;
  /**
   * Start address.
  */
  startAddress?: string;
  /**
   * Current thread priority.
  */
  currentPriority?: number;
  /**
   * Thread priority level.
  */
  priorityLevel?: string;
  /**
   * Base priority.
  */
  basePriority?: number;
  /**
   * Start time.
  */
  startTime?: Date;
  /**
   * Total processor time.
  */
  totalProcessorTime?: string;
  /**
   * User processor time.
  */
  userProcessorTime?: string;
  /**
   * Priviledged processor time.
  */
  priviledgedProcessorTime?: string;
  /**
   * Thread state.
  */
  state?: string;
  /**
   * Wait reason.
  */
  waitReason?: string;
}

/**
 * Process Module Information.
*/
export interface ProcessModuleInfo extends ProxyOnlyResource {
  /**
   * Base address. Used as module identifier in ARM resource URI.
  */
  baseAddress?: string;
  /**
   * File name.
  */
  fileName?: string;
  /**
   * HRef URI.
  */
  href?: string;
  /**
   * File path.
  */
  filePath?: string;
  /**
   * Module memory size.
  */
  moduleMemorySize?: number;
  /**
   * File version.
  */
  fileVersion?: string;
  /**
   * File description.
  */
  fileDescription?: string;
  /**
   * Product name.
  */
  product?: string;
  /**
   * Product version.
  */
  productVersion?: string;
  /**
   * Is debug?
  */
  isDebug?: boolean;
  /**
   * Module language (locale).
  */
  language?: string;
}

/**
 * Process Information.
*/
export interface ProcessInfo extends ProxyOnlyResource {
  /**
   * ARM Identifier for deployment.
  */
  readonly identifier?: number;
  /**
   * Deployment name.
  */
  deploymentName?: string;
  /**
   * HRef URI.
  */
  href?: string;
  /**
   * Minidump URI.
  */
  minidump?: string;
  /**
   * Is profile running?
  */
  isProfileRunning?: boolean;
  /**
   * Is the IIS Profile running?
  */
  isIisProfileRunning?: boolean;
  /**
   * IIS Profile timeout (seconds).
  */
  iisProfileTimeoutInSeconds?: number;
  /**
   * Parent process.
  */
  parent?: string;
  /**
   * Child process list.
  */
  children?: string[];
  /**
   * Thread list.
  */
  threads?: ProcessThreadInfo[];
  /**
   * List of open files.
  */
  openFileHandles?: string[];
  /**
   * List of modules.
  */
  modules?: ProcessModuleInfo[];
  /**
   * File name of this process.
  */
  fileName?: string;
  /**
   * Command line.
  */
  commandLine?: string;
  /**
   * User name.
  */
  userName?: string;
  /**
   * Handle count.
  */
  handleCount?: number;
  /**
   * Module count.
  */
  moduleCount?: number;
  /**
   * Thread count.
  */
  threadCount?: number;
  /**
   * Start time.
  */
  startTime?: Date;
  /**
   * Total CPU time.
  */
  totalCpuTime?: string;
  /**
   * User CPU time.
  */
  userCpuTime?: string;
  /**
   * Privileged CPU time.
  */
  privilegedCpuTime?: string;
  /**
   * Working set.
  */
  workingSet?: number;
  /**
   * Peak working set.
  */
  peakWorkingSet?: number;
  /**
   * Private memory size.
  */
  privateMemory?: number;
  /**
   * Virtual memory size.
  */
  virtualMemory?: number;
  /**
   * Peak virtual memory usage.
  */
  peakVirtualMemory?: number;
  /**
   * Paged system memory.
  */
  pagedSystemMemory?: number;
  /**
   * Non-paged system memory.
  */
  nonPagedSystemMemory?: number;
  /**
   * Paged memory.
  */
  pagedMemory?: number;
  /**
   * Peak paged memory.
  */
  peakPagedMemory?: number;
  /**
   * Time stamp.
  */
  timeStamp?: Date;
  /**
   * List of environment variables.
  */
  environmentVariables?: { [propertyName: string]: string };
  /**
   * Is this the SCM site?
  */
  isScmSite?: boolean;
  /**
   * Is this a Web Job?
  */
  isWebjob?: boolean;
  /**
   * Description of process.
  */
  description?: string;
}

/**
 * Public certificate object
*/
export interface PublicCertificate extends ProxyOnlyResource {
  /**
   * Public Certificate byte array
  */
  blob?: Buffer;
  /**
   * Public Certificate Location. Possible values include: 'CurrentUserMy', 'LocalMachineMy',
   * 'Unknown'
  */
  publicCertificateLocation?: string;
  /**
   * Certificate Thumbprint
  */
  readonly thumbprint?: string;
}

/**
 * Description of a restore request.
*/
export interface RestoreRequest extends ProxyOnlyResource {
  /**
   * SAS URL to the container.
  */
  storageAccountUrl: string;
  /**
   * Name of a blob which contains the backup.
  */
  blobName?: string;
  /**
   * <code>true</code> if the restore operation can overwrite target app; otherwise,
   * <code>false</code>. <code>true</code> is needed if trying to restore over an existing app.
  */
  overwrite: boolean;
  /**
   * Name of an app.
  */
  siteName?: string;
  /**
   * Collection of databases which should be restored. This list has to match the list of databases
   * included in the backup.
  */
  databases?: DatabaseBackupSetting[];
  /**
   * Changes a logic when restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to conflicts during the
   * operation.
  */
  ignoreConflictingHostNames?: boolean;
  /**
   * Ignore the databases and only restore the site content
  */
  ignoreDatabases?: boolean;
  /**
   * Specify app service plan that will own restored site.
  */
  appServicePlan?: string;
  /**
   * Operation type. Possible values include: 'Default', 'Clone', 'Relocation', 'Snapshot',
   * 'CloudFS'
  */
  operationType?: string;
  /**
   * <code>true</code> if SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
  */
  adjustConnectionStrings?: boolean;
  /**
   * App Service Environment name, if needed (only when restoring an app to an App Service
   * Environment).
  */
  hostingEnvironment?: string;
}

/**
 * Configuration settings for the Azure App Service Authentication / Authorization feature.
*/
export interface SiteAuthSettings extends ProxyOnlyResource {
  /**
   * <code>true</code> if the Authentication / Authorization feature is enabled for the current
   * app; otherwise, <code>false</code>.
  */
  enabled?: boolean;
  /**
   * The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
   * The setting in this value can control the behavior of certain features in the Authentication /
   * Authorization module.
  */
  runtimeVersion?: string;
  /**
   * The action to take when an unauthenticated client attempts to access the app. Possible values
   * include: 'RedirectToLoginPage', 'AllowAnonymous'
  */
  unauthenticatedClientAction?: string;
  /**
   * <code>true</code> to durably store platform-specific security tokens that are obtained during
   * login flows; otherwise, <code>false</code>.
   * The default is <code>false</code>.
  */
  tokenStoreEnabled?: boolean;
  /**
   * External URLs that can be redirected to as part of logging in or logging out of the app. Note
   * that the query string part of the URL is ignored.
   * This is an advanced setting typically only needed by Windows Store application backends.
   * Note that URLs within the current domain are always implicitly allowed.
  */
  allowedExternalRedirectUrls?: string[];
  /**
   * The default authentication provider to use when multiple providers are configured.
   * This setting is only needed if multiple providers are configured and the unauthenticated
   * client
   * action is set to "RedirectToLoginPage". Possible values include: 'AzureActiveDirectory',
   * 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
  */
  defaultProvider?: string;
  /**
   * The number of hours after session token expiration that a session token can be used to
   * call the token refresh API. The default is 72 hours.
  */
  tokenRefreshExtensionHours?: number;
  /**
   * The Client ID of this relying party application, known as the client_id.
   * This setting is required for enabling OpenID Connection authentication with Azure Active
   * Directory or
   * other 3rd party OpenID Connect providers.
   * More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
  */
  clientId?: string;
  /**
   * The Client Secret of this relying party application (in Azure Active Directory, this is also
   * referred to as the Key).
   * This setting is optional. If no client secret is configured, the OpenID Connect implicit auth
   * flow is used to authenticate end users.
   * Otherwise, the OpenID Connect Authorization Code Flow is used to authenticate end users.
   * More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
  */
  clientSecret?: string;
  /**
   * The OpenID Connect Issuer URI that represents the entity which issues access tokens for this
   * application.
   * When using Azure Active Directory, this value is the URI of the directory tenant, e.g.
   * https://sts.windows.net/{tenant-guid}/.
   * This URI is a case-sensitive identifier for the token issuer.
   * More information on OpenID Connect Discovery:
   * http://openid.net/specs/openid-connect-discovery-1_0.html
  */
  issuer?: string;
  /**
   * Gets a value indicating whether the issuer should be a valid HTTPS url and be validated as
   * such.
  */
  validateIssuer?: boolean;
  /**
   * Allowed audience values to consider when validating JWTs issued by
   * Azure Active Directory. Note that the <code>ClientID</code> value is always considered an
   * allowed audience, regardless of this setting.
  */
  allowedAudiences?: string[];
  /**
   * Login parameters to send to the OpenID Connect authorization endpoint when
   * a user logs in. Each parameter must be in the form "key=value".
  */
  additionalLoginParams?: string[];
  /**
   * The OpenID Connect Client ID for the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation: https://developers.google.com/identity/sign-in/web/
  */
  googleClientId?: string;
  /**
   * The client secret associated with the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation: https://developers.google.com/identity/sign-in/web/
  */
  googleClientSecret?: string;
  /**
   * The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication.
   * This setting is optional. If not specified, "openid", "profile", and "email" are used as
   * default scopes.
   * Google Sign-In documentation: https://developers.google.com/identity/sign-in/web/
  */
  googleOAuthScopes?: string[];
  /**
   * The App ID of the Facebook app used for login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation: https://developers.facebook.com/docs/facebook-login
  */
  facebookAppId?: string;
  /**
   * The App Secret of the Facebook app used for Facebook Login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation: https://developers.facebook.com/docs/facebook-login
  */
  facebookAppSecret?: string;
  /**
   * The OAuth 2.0 scopes that will be requested as part of Facebook Login authentication.
   * This setting is optional.
   * Facebook Login documentation: https://developers.facebook.com/docs/facebook-login
  */
  facebookOAuthScopes?: string[];
  /**
   * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
  */
  twitterConsumerKey?: string;
  /**
   * The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
  */
  twitterConsumerSecret?: string;
  /**
   * The OAuth 2.0 client ID that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation: https://dev.onedrive.com/auth/msa_oauth.htm
  */
  microsoftAccountClientId?: string;
  /**
   * The OAuth 2.0 client secret that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation: https://dev.onedrive.com/auth/msa_oauth.htm
  */
  microsoftAccountClientSecret?: string;
  /**
   * The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
   * This setting is optional. If not specified, "wl.basic" is used as the default scope.
   * Microsoft Account Scopes and permissions documentation:
   * https://msdn.microsoft.com/en-us/library/dn631845.aspx
  */
  microsoftAccountOAuthScopes?: string[];
}

/**
 * An app cloneability criterion.
*/
export interface SiteCloneabilityCriterion {
  /**
   * Name of criterion.
  */
  name?: string;
  /**
   * Description of criterion.
  */
  description?: string;
}

/**
 * Represents whether or not an app is cloneable.
*/
export interface SiteCloneability {
  /**
   * Name of app. Possible values include: 'Cloneable', 'PartiallyCloneable', 'NotCloneable'
  */
  result?: string;
  /**
   * List of features enabled on app that prevent cloning.
  */
  blockingFeatures?: SiteCloneabilityCriterion[];
  /**
   * List of features enabled on app that are non-blocking but cannot be cloned. The app can still
   * be cloned
   * but the features in this list will not be set up on cloned app.
  */
  unsupportedFeatures?: SiteCloneabilityCriterion[];
  /**
   * List of blocking application characteristics.
  */
  blockingCharacteristics?: SiteCloneabilityCriterion[];
}

/**
 * Web app configuration ARM resource.
*/
export interface SiteConfigResource extends ProxyOnlyResource {
  /**
   * Number of workers.
  */
  numberOfWorkers?: number;
  /**
   * Default documents.
  */
  defaultDocuments?: string[];
  /**
   * .NET Framework version.
  */
  netFrameworkVersion?: string;
  /**
   * Version of PHP.
  */
  phpVersion?: string;
  /**
   * Version of Python.
  */
  pythonVersion?: string;
  /**
   * Version of Node.js.
  */
  nodeVersion?: string;
  /**
   * Linux App Framework and version
  */
  linuxFxVersion?: string;
  /**
   * Xenon App Framework and version
  */
  windowsFxVersion?: string;
  /**
   * <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
  */
  requestTracingEnabled?: boolean;
  /**
   * Request tracing expiration time.
  */
  requestTracingExpirationTime?: Date;
  /**
   * <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
  */
  remoteDebuggingEnabled?: boolean;
  /**
   * Remote debugging version.
  */
  remoteDebuggingVersion?: string;
  /**
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
  */
  httpLoggingEnabled?: boolean;
  /**
   * HTTP logs directory size limit.
  */
  logsDirectorySizeLimit?: number;
  /**
   * <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
  */
  detailedErrorLoggingEnabled?: boolean;
  /**
   * Publishing user name.
  */
  publishingUsername?: string;
  /**
   * Application settings.
  */
  appSettings?: NameValuePair[];
  /**
   * User-provided Azure storage accounts.
  */
  azureStorageAccounts?: { [propertyName: string]: AzureStorageInfoValue };
  /**
   * Connection strings.
  */
  connectionStrings?: ConnStringInfo[];
  /**
   * Site MachineKey.
  */
  readonly machineKey?: SiteMachineKey;
  /**
   * Handler mappings.
  */
  handlerMappings?: HandlerMapping[];
  /**
   * Document root.
  */
  documentRoot?: string;
  /**
   * SCM type. Possible values include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub',
   * 'CodePlexGit', 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
  */
  scmType?: string;
  /**
   * <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
  */
  use32BitWorkerProcess?: boolean;
  /**
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
  */
  webSocketsEnabled?: boolean;
  /**
   * <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
  */
  alwaysOn?: boolean;
  /**
   * Java version.
  */
  javaVersion?: string;
  /**
   * Java container.
  */
  javaContainer?: string;
  /**
   * Java container version.
  */
  javaContainerVersion?: string;
  /**
   * App command line to launch.
  */
  appCommandLine?: string;
  /**
   * Managed pipeline mode. Possible values include: 'Integrated', 'Classic'
  */
  managedPipelineMode?: string;
  /**
   * Virtual applications.
  */
  virtualApplications?: VirtualApplication[];
  /**
   * Site load balancing. Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
  */
  loadBalancing?: string;
  /**
   * This is work around for polymophic types.
  */
  experiments?: Experiments;
  /**
   * Site limits.
  */
  limits?: SiteLimits;
  /**
   * <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
  */
  autoHealEnabled?: boolean;
  /**
   * Auto Heal rules.
  */
  autoHealRules?: AutoHealRules;
  /**
   * Tracing options.
  */
  tracingOptions?: string;
  /**
   * Virtual Network name.
  */
  vnetName?: string;
  /**
   * Cross-Origin Resource Sharing (CORS) settings.
  */
  cors?: CorsSettings;
  /**
   * Push endpoint settings.
  */
  push?: PushSettings;
  /**
   * Information about the formal API definition for the app.
  */
  apiDefinition?: ApiDefinitionInfo;
  /**
   * Auto-swap slot name.
  */
  autoSwapSlotName?: string;
  /**
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
  */
  localMySqlEnabled?: boolean;
  /**
   * Managed Service Identity Id
  */
  managedServiceIdentityId?: number;
  /**
   * Explicit Managed Service Identity Id
  */
  xManagedServiceIdentityId?: number;
  /**
   * IP security restrictions.
  */
  ipSecurityRestrictions?: IpSecurityRestriction[];
  /**
   * Http20Enabled: configures a web site to allow clients to connect over http2.0
  */
  http20Enabled?: boolean;
  /**
   * MinTlsVersion: configures the minimum version of TLS required for SSL requests. Possible
   * values include: '1.0', '1.1', '1.2'
  */
  minTlsVersion?: string;
  /**
   * State of FTP / FTPS service. Possible values include: 'AllAllowed', 'FtpsOnly', 'Disabled'
  */
  ftpsState?: string;
  /**
   * Number of reserved instances.
   * This setting only applies to the Consumption Plan
  */
  reservedInstanceCount?: number;
}

/**
 * A snapshot of a web app configuration.
*/
export interface SiteConfigurationSnapshotInfo extends ProxyOnlyResource {
  /**
   * The time the snapshot was taken.
  */
  readonly time?: Date;
  /**
   * The id of the snapshot
  */
  readonly snapshotId?: number;
}

/**
 * Site Extension Information.
*/
export interface SiteExtensionInfo extends ProxyOnlyResource {
  /**
   * Site extension ID.
  */
  extensionId?: string;
  title?: string;
  /**
   * Site extension type. Possible values include: 'Gallery', 'WebRoot'
  */
  extensionType?: string;
  /**
   * Summary description.
  */
  summary?: string;
  /**
   * Detailed description.
  */
  description?: string;
  /**
   * Version information.
  */
  version?: string;
  /**
   * Extension URL.
  */
  extensionUrl?: string;
  /**
   * Project URL.
  */
  projectUrl?: string;
  /**
   * Icon URL.
  */
  iconUrl?: string;
  /**
   * License URL.
  */
  licenseUrl?: string;
  /**
   * Feed URL.
  */
  feedUrl?: string;
  /**
   * List of authors.
  */
  authors?: string[];
  /**
   * Installer command line parameters.
  */
  installerCommandLineParams?: string;
  /**
   * Published timestamp.
  */
  publishedDateTime?: Date;
  /**
   * Count of downloads.
  */
  downloadCount?: number;
  /**
   * <code>true</code> if the local version is the latest version; <code>false</code> otherwise.
  */
  localIsLatestVersion?: boolean;
  /**
   * Local path.
  */
  localPath?: string;
  /**
   * Installed timestamp.
  */
  installedDateTime?: Date;
  /**
   * Provisioning state.
  */
  provisioningState?: string;
  /**
   * Site Extension comment.
  */
  comment?: string;
}

/**
 * Instance of an app.
*/
export interface SiteInstance extends ProxyOnlyResource {
  /**
   * Name of instance.
  */
  readonly siteInstanceName?: string;
}

/**
 * Configuration of App Service site logs.
*/
export interface SiteLogsConfig extends ProxyOnlyResource {
  /**
   * Application logs configuration.
  */
  applicationLogs?: ApplicationLogsConfig;
  /**
   * HTTP logs configuration.
  */
  httpLogs?: HttpLogsConfig;
  /**
   * Failed requests tracing configuration.
  */
  failedRequestsTracing?: EnabledConfig;
  /**
   * Detailed error messages configuration.
  */
  detailedErrorMessages?: EnabledConfig;
}

/**
 * ARM resource for a site.
*/
export interface SitePatchResource extends ProxyOnlyResource {
  /**
   * Current state of the app.
  */
  readonly state?: string;
  /**
   * Hostnames associated with the app.
  */
  readonly hostNames?: string[];
  /**
   * Name of the repository site.
  */
  readonly repositorySiteName?: string;
  /**
   * State indicating whether the app has exceeded its quota usage. Read-only. Possible values
   * include: 'Normal', 'Exceeded'
  */
  readonly usageState?: string;
  /**
   * <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to
   * false disables the app (takes the app offline).
  */
  enabled?: boolean;
  /**
   * Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled.
   * Otherwise,
   * the app is not served on those hostnames.
  */
  readonly enabledHostNames?: string[];
  /**
   * Management information availability state for the app. Possible values include: 'Normal',
   * 'Limited', 'DisasterRecoveryMode'
  */
  readonly availabilityState?: string;
  /**
   * Hostname SSL states are used to manage the SSL bindings for app's hostnames.
  */
  hostNameSslStates?: HostNameSslState[];
  /**
   * Resource ID of the associated App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
  */
  serverFarmId?: string;
  /**
   * <code>true</code> if reserved; otherwise, <code>false</code>.
  */
  reserved?: boolean;
  /**
   * Obsolete: Hyper-V sandbox.
  */
  isXenon?: boolean;
  /**
   * Hyper-V sandbox.
  */
  hyperV?: boolean;
  /**
   * Last time the app was modified, in UTC. Read-only.
  */
  readonly lastModifiedTimeUtc?: Date;
  /**
   * Configuration of the app.
  */
  siteConfig?: SiteConfig;
  /**
   * Azure Traffic Manager hostnames associated with the app. Read-only.
  */
  readonly trafficManagerHostNames?: string[];
  /**
   * <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise,
   * <code>false</code>. The default is <code>false</code>.
  */
  scmSiteAlsoStopped?: boolean;
  /**
   * Specifies which deployment slot this app will swap into. Read-only.
  */
  readonly targetSwapSlot?: string;
  /**
   * App Service Environment to use for the app.
  */
  hostingEnvironmentProfile?: HostingEnvironmentProfile;
  /**
   * <code>true</code> to enable client affinity; <code>false</code> to stop sending session
   * affinity cookies, which route client requests in the same session to the same instance.
   * Default is <code>true</code>.
  */
  clientAffinityEnabled?: boolean;
  /**
   * <code>true</code> to enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
  */
  clientCertEnabled?: boolean;
  /**
   * <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
  */
  hostNamesDisabled?: boolean;
  /**
   * List of IP addresses that the app uses for outbound connections (e.g. database access).
   * Includes VIPs from tenants that site can be hosted with current settings. Read-only.
  */
  readonly outboundIpAddresses?: string;
  /**
   * List of IP addresses that the app uses for outbound connections (e.g. database access).
   * Includes VIPs from all tenants. Read-only.
  */
  readonly possibleOutboundIpAddresses?: string;
  /**
   * Size of the function container.
  */
  containerSize?: number;
  /**
   * Maximum allowed daily memory-time quota (applicable on dynamic apps only).
  */
  dailyMemoryTimeQuota?: number;
  /**
   * App suspended till in case memory-time quota is exceeded.
  */
  readonly suspendedTill?: Date;
  /**
   * Maximum number of workers.
   * This only applies to Functions container.
  */
  readonly maxNumberOfWorkers?: number;
  /**
   * If specified during app creation, the app is cloned from a source app.
  */
  cloningInfo?: CloningInfo;
  /**
   * Name of the resource group the app belongs to. Read-only.
  */
  readonly resourceGroup?: string;
  /**
   * <code>true</code> if the app is a default container; otherwise, <code>false</code>.
  */
  readonly isDefaultContainer?: boolean;
  /**
   * Default hostname of the app. Read-only.
  */
  readonly defaultHostName?: string;
  /**
   * Status of the last deployment slot swap operation.
  */
  readonly slotSwapStatus?: SlotSwapStatus;
  /**
   * HttpsOnly: configures a web site to accept only https requests. Issues redirect for
   * http requests
  */
  httpsOnly?: boolean;
}

/**
 * Used for getting PHP error logging flag.
*/
export interface SitePhpErrorLogFlag extends ProxyOnlyResource {
  /**
   * Local log_errors setting.
  */
  localLogErrors?: string;
  /**
   * Master log_errors setting.
  */
  masterLogErrors?: string;
  /**
   * Local log_errors_max_len setting.
  */
  localLogErrorsMaxLength?: string;
  /**
   * Master log_errors_max_len setting.
  */
  masterLogErrorsMaxLength?: string;
}

/**
 * Source control configuration for an app.
*/
export interface SiteSourceControl extends ProxyOnlyResource {
  /**
   * Repository or source control URL.
  */
  repoUrl?: string;
  /**
   * Name of branch to use for deployment.
  */
  branch?: string;
  /**
   * <code>true</code> to limit to manual integration; <code>false</code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
  */
  isManualIntegration?: boolean;
  /**
   * <code>true</code> to enable deployment rollback; otherwise, <code>false</code>.
  */
  deploymentRollbackEnabled?: boolean;
  /**
   * <code>true</code> for a Mercurial repository; <code>false</code> for a Git repository.
  */
  isMercurial?: boolean;
}

/**
 * Slot Config names azure resource.
*/
export interface SlotConfigNamesResource extends ProxyOnlyResource {
  /**
   * List of connection string names.
  */
  connectionStringNames?: string[];
  /**
   * List of application settings names.
  */
  appSettingNames?: string[];
  /**
   * List of external Azure storage account identifiers.
  */
  azureStorageConfigNames?: string[];
}

/**
 * A setting difference between two deployment slots of an app.
*/
export interface SlotDifference extends ProxyOnlyResource {
  /**
   * Level of the difference: Information, Warning or Error.
  */
  readonly level?: string;
  /**
   * The type of the setting: General, AppSetting or ConnectionString.
  */
  readonly settingType?: string;
  /**
   * Rule that describes how to process the setting difference during a slot swap.
  */
  readonly diffRule?: string;
  /**
   * Name of the setting.
  */
  readonly settingName?: string;
  /**
   * Value of the setting in the current slot.
  */
  readonly valueInCurrentSlot?: string;
  /**
   * Value of the setting in the target slot.
  */
  readonly valueInTargetSlot?: string;
  /**
   * Description of the setting difference.
  */
  readonly description?: string;
}

/**
 * Specifies the web app that snapshot contents will be retrieved from.
*/
export interface SnapshotRecoverySource {
  /**
   * Geographical location of the source web app, e.g. SouthEastAsia, SouthCentralUS
  */
  location?: string;
  /**
   * ARM resource ID of the source app.
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
  */
  id?: string;
}

/**
 * Details about app recovery operation.
*/
export interface SnapshotRestoreRequest extends ProxyOnlyResource {
  /**
   * Point in time in which the app restore should be done, formatted as a DateTime string.
  */
  snapshotTime?: string;
  /**
   * Optional. Specifies the web app that snapshot contents will be retrieved from.
   * If empty, the targeted web app will be used as the source.
  */
  recoverySource?: SnapshotRecoverySource;
  /**
   * If <code>true</code> the restore operation can overwrite source app; otherwise,
   * <code>false</code>.
  */
  overwrite: boolean;
  /**
   * If true, site configuration, in addition to content, will be reverted.
  */
  recoverConfiguration?: boolean;
  /**
   * If true, custom hostname conflicts will be ignored when recovering to a target web app.
   * This setting is only necessary when RecoverConfiguration is enabled.
  */
  ignoreConflictingHostNames?: boolean;
  /**
   * If true, the snapshot is retrieved from DRSecondary endpoint.
  */
  useDRSecondary?: boolean;
}

/**
 * Options for app content migration.
*/
export interface StorageMigrationOptions extends ProxyOnlyResource {
  /**
   * AzureFiles connection string.
  */
  azurefilesConnectionString: string;
  /**
   * AzureFiles share.
  */
  azurefilesShare: string;
  /**
   * <code>true</code>if the app should be switched over; otherwise, <code>false</code>.
  */
  switchSiteAfterMigration?: boolean;
  /**
   * <code>true</code> if the app should be read only during copy operation; otherwise,
   * <code>false</code>.
  */
  blockWriteAccessToSite?: boolean;
}

/**
 * Response for a migration of app content request.
*/
export interface StorageMigrationResponse extends ProxyOnlyResource {
  /**
   * When server starts the migration process, it will return an operation ID identifying that
   * particular migration operation.
  */
  readonly operationId?: string;
}

/**
 * String dictionary resource.
*/
export interface StringDictionary extends ProxyOnlyResource {
  /**
   * Settings.
  */
  properties?: { [propertyName: string]: string };
}

/**
 * Swift Virtual Network Contract. This is used to enable the new Swift way of doing virtual
 * network integration.
*/
export interface SwiftVirtualNetwork extends ProxyOnlyResource {
  /**
   * The Virtual Network subnet's resource ID. This is the subnet that this Web App will join. This
   * subnet must have a delegation to Microsoft.Web/serverFarms defined first.
  */
  subnetResourceId?: string;
  /**
   * A flag that specifies if the scale unit this Web App is on supports Swift integration.
  */
  swiftSupported?: boolean;
}

/**
 * Triggered Web Job Run Information.
*/
export interface TriggeredJobRun extends ProxyOnlyResource {
  /**
   * Job ID.
  */
  webJobId?: string;
  /**
   * Job name.
  */
  webJobName?: string;
  /**
   * Job status. Possible values include: 'Success', 'Failed', 'Error'
  */
  status?: string;
  /**
   * Start time.
  */
  startTime?: Date;
  /**
   * End time.
  */
  endTime?: Date;
  /**
   * Job duration.
  */
  duration?: string;
  /**
   * Output URL.
  */
  outputUrl?: string;
  /**
   * Error URL.
  */
  errorUrl?: string;
  /**
   * Job URL.
  */
  url?: string;
  /**
   * Job name.
  */
  jobName?: string;
  /**
   * Job trigger.
  */
  trigger?: string;
}

/**
 * Triggered Web Job History. List of Triggered Web Job Run Information elements.
*/
export interface TriggeredJobHistory extends ProxyOnlyResource {
  /**
   * List of triggered web job runs.
  */
  runs?: TriggeredJobRun[];
}

/**
 * Triggered Web Job Information.
*/
export interface TriggeredWebJob extends ProxyOnlyResource {
  /**
   * Latest job run information.
  */
  latestRun?: TriggeredJobRun;
  /**
   * History URL.
  */
  historyUrl?: string;
  /**
   * Scheduler Logs URL.
  */
  schedulerLogsUrl?: string;
  /**
   * Run command.
  */
  runCommand?: string;
  /**
   * Job URL.
  */
  url?: string;
  /**
   * Extra Info URL.
  */
  extraInfoUrl?: string;
  /**
   * Job type. Possible values include: 'Continuous', 'Triggered'
  */
  webJobType?: string;
  /**
   * Error information.
  */
  error?: string;
  /**
   * Using SDK?
  */
  usingSdk?: boolean;
  /**
   * Job settings.
  */
  settings?: { [propertyName: string]: any };
}

/**
 * Web Job Information.
*/
export interface WebJob extends ProxyOnlyResource {
  /**
   * Run command.
  */
  runCommand?: string;
  /**
   * Job URL.
  */
  url?: string;
  /**
   * Extra Info URL.
  */
  extraInfoUrl?: string;
  /**
   * Job type. Possible values include: 'Continuous', 'Triggered'
  */
  webJobType?: string;
  /**
   * Error information.
  */
  error?: string;
  /**
   * Using SDK?
  */
  usingSdk?: boolean;
  /**
   * Job settings.
  */
  settings?: { [propertyName: string]: any };
}

/**
 * Describes main public IP address and any extra virtual IPs.
*/
export interface AddressResponse {
  /**
   * Main public virtual IP.
  */
  serviceIpAddress?: string;
  /**
   * Virtual Network internal IP address of the App Service Environment if it is in internal
   * load-balancing mode.
  */
  internalIpAddress?: string;
  /**
   * IP addresses appearing on outbound connections.
  */
  outboundIpAddresses?: string[];
  /**
   * Additional virtual IPs.
  */
  vipMappings?: VirtualIPMapping[];
}

/**
 * App Service Environment ARM resource.
*/
export interface AppServiceEnvironmentResource extends Resource {
  /**
   * Name of the App Service Environment.
  */
  appServiceEnvironmentResourceName: string;
  /**
   * Location of the App Service Environment, e.g. "West US".
  */
  appServiceEnvironmentResourceLocation: string;
  /**
   * Provisioning state of the App Service Environment. Possible values include: 'Succeeded',
   * 'Failed', 'Canceled', 'InProgress', 'Deleting'
  */
  readonly provisioningState?: string;
  /**
   * Current status of the App Service Environment. Possible values include: 'Preparing', 'Ready',
   * 'Scaling', 'Deleting'
  */
  readonly status?: string;
  /**
   * Name of the Virtual Network for the App Service Environment.
  */
  vnetName?: string;
  /**
   * Resource group of the Virtual Network.
  */
  vnetResourceGroupName?: string;
  /**
   * Subnet of the Virtual Network.
  */
  vnetSubnetName?: string;
  /**
   * Description of the Virtual Network.
  */
  virtualNetwork: VirtualNetworkProfile;
  /**
   * Specifies which endpoints to serve internally in the Virtual Network for the App Service
   * Environment. Possible values include: 'None', 'Web', 'Publishing'
  */
  internalLoadBalancingMode?: string;
  /**
   * Front-end VM size, e.g. "Medium", "Large".
  */
  multiSize?: string;
  /**
   * Number of front-end instances.
  */
  multiRoleCount?: number;
  /**
   * Description of worker pools with worker size IDs, VM sizes, and number of workers in each
   * pool.
  */
  workerPools: WorkerPool[];
  /**
   * Number of IP SSL addresses reserved for the App Service Environment.
  */
  ipsslAddressCount?: number;
  /**
   * Edition of the metadata database for the App Service Environment, e.g. "Standard".
  */
  readonly databaseEdition?: string;
  /**
   * Service objective of the metadata database for the App Service Environment, e.g. "S0".
  */
  readonly databaseServiceObjective?: string;
  /**
   * Number of upgrade domains of the App Service Environment.
  */
  readonly upgradeDomains?: number;
  /**
   * Subscription of the App Service Environment.
  */
  readonly subscriptionId?: string;
  /**
   * DNS suffix of the App Service Environment.
  */
  dnsSuffix?: string;
  /**
   * Last deployment action on the App Service Environment.
  */
  readonly lastAction?: string;
  /**
   * Result of the last deployment action on the App Service Environment.
  */
  readonly lastActionResult?: string;
  /**
   * List of comma separated strings describing which VM sizes are allowed for front-ends.
  */
  readonly allowedMultiSizes?: string;
  /**
   * List of comma separated strings describing which VM sizes are allowed for workers.
  */
  readonly allowedWorkerSizes?: string;
  /**
   * Maximum number of VMs in the App Service Environment.
  */
  readonly maximumNumberOfMachines?: number;
  /**
   * Description of IP SSL mapping for the App Service Environment.
  */
  readonly vipMappings?: VirtualIPMapping[];
  /**
   * Current total, used, and available worker capacities.
  */
  readonly environmentCapacities?: StampCapacity[];
  /**
   * Access control list for controlling traffic to the App Service Environment.
  */
  networkAccessControlList?: NetworkAccessControlEntry[];
  /**
   * True/false indicating whether the App Service Environment is healthy.
  */
  readonly environmentIsHealthy?: boolean;
  /**
   * Detailed message about with results of the last check of the App Service Environment.
  */
  readonly environmentStatus?: string;
  /**
   * Resource group of the App Service Environment.
  */
  readonly resourceGroup?: string;
  /**
   * Scale factor for front-ends.
  */
  frontEndScaleFactor?: number;
  /**
   * Default Scale Factor for FrontEnds.
  */
  readonly defaultFrontEndScaleFactor?: number;
  /**
   * API Management Account associated with the App Service Environment.
  */
  apiManagementAccountId?: string;
  /**
   * <code>true</code> if the App Service Environment is suspended; otherwise, <code>false</code>.
   * The environment can be suspended, e.g. when the management endpoint is no longer available
   * (most likely because NSG blocked the incoming traffic).
  */
  suspended?: boolean;
  /**
   * True/false indicating whether the App Service Environment is suspended. The environment can be
   * suspended e.g. when the management endpoint is no longer available
   * (most likely because NSG blocked the incoming traffic).
  */
  dynamicCacheEnabled?: boolean;
  /**
   * Custom settings for changing the behavior of the App Service Environment.
  */
  clusterSettings?: NameValuePair[];
  /**
   * User added ip ranges to whitelist on ASE db
  */
  userWhitelistedIpRanges?: string[];
  /**
   * Flag that displays whether an ASE has linux workers or not
  */
  hasLinuxWorkers?: boolean;
  /**
   * Key Vault ID for ILB App Service Environment default SSL certificate
  */
  sslCertKeyVaultId?: string;
  /**
   * Key Vault Secret Name for ILB App Service Environment default SSL certificate
  */
  sslCertKeyVaultSecretName?: string;
}

/**
 * ARM resource for a app service environment.
*/
export interface AppServiceEnvironmentPatchResource extends ProxyOnlyResource {
  /**
   * Name of the App Service Environment.
  */
  appServiceEnvironmentPatchResourceName: string;
  /**
   * Location of the App Service Environment, e.g. "West US".
  */
  location: string;
  /**
   * Provisioning state of the App Service Environment. Possible values include: 'Succeeded',
   * 'Failed', 'Canceled', 'InProgress', 'Deleting'
  */
  readonly provisioningState?: string;
  /**
   * Current status of the App Service Environment. Possible values include: 'Preparing', 'Ready',
   * 'Scaling', 'Deleting'
  */
  readonly status?: string;
  /**
   * Name of the Virtual Network for the App Service Environment.
  */
  vnetName?: string;
  /**
   * Resource group of the Virtual Network.
  */
  vnetResourceGroupName?: string;
  /**
   * Subnet of the Virtual Network.
  */
  vnetSubnetName?: string;
  /**
   * Description of the Virtual Network.
  */
  virtualNetwork: VirtualNetworkProfile;
  /**
   * Specifies which endpoints to serve internally in the Virtual Network for the App Service
   * Environment. Possible values include: 'None', 'Web', 'Publishing'
  */
  internalLoadBalancingMode?: string;
  /**
   * Front-end VM size, e.g. "Medium", "Large".
  */
  multiSize?: string;
  /**
   * Number of front-end instances.
  */
  multiRoleCount?: number;
  /**
   * Description of worker pools with worker size IDs, VM sizes, and number of workers in each
   * pool.
  */
  workerPools: WorkerPool[];
  /**
   * Number of IP SSL addresses reserved for the App Service Environment.
  */
  ipsslAddressCount?: number;
  /**
   * Edition of the metadata database for the App Service Environment, e.g. "Standard".
  */
  readonly databaseEdition?: string;
  /**
   * Service objective of the metadata database for the App Service Environment, e.g. "S0".
  */
  readonly databaseServiceObjective?: string;
  /**
   * Number of upgrade domains of the App Service Environment.
  */
  readonly upgradeDomains?: number;
  /**
   * Subscription of the App Service Environment.
  */
  readonly subscriptionId?: string;
  /**
   * DNS suffix of the App Service Environment.
  */
  dnsSuffix?: string;
  /**
   * Last deployment action on the App Service Environment.
  */
  readonly lastAction?: string;
  /**
   * Result of the last deployment action on the App Service Environment.
  */
  readonly lastActionResult?: string;
  /**
   * List of comma separated strings describing which VM sizes are allowed for front-ends.
  */
  readonly allowedMultiSizes?: string;
  /**
   * List of comma separated strings describing which VM sizes are allowed for workers.
  */
  readonly allowedWorkerSizes?: string;
  /**
   * Maximum number of VMs in the App Service Environment.
  */
  readonly maximumNumberOfMachines?: number;
  /**
   * Description of IP SSL mapping for the App Service Environment.
  */
  readonly vipMappings?: VirtualIPMapping[];
  /**
   * Current total, used, and available worker capacities.
  */
  readonly environmentCapacities?: StampCapacity[];
  /**
   * Access control list for controlling traffic to the App Service Environment.
  */
  networkAccessControlList?: NetworkAccessControlEntry[];
  /**
   * True/false indicating whether the App Service Environment is healthy.
  */
  readonly environmentIsHealthy?: boolean;
  /**
   * Detailed message about with results of the last check of the App Service Environment.
  */
  readonly environmentStatus?: string;
  /**
   * Resource group of the App Service Environment.
  */
  readonly resourceGroup?: string;
  /**
   * Scale factor for front-ends.
  */
  frontEndScaleFactor?: number;
  /**
   * Default Scale Factor for FrontEnds.
  */
  readonly defaultFrontEndScaleFactor?: number;
  /**
   * API Management Account associated with the App Service Environment.
  */
  apiManagementAccountId?: string;
  /**
   * <code>true</code> if the App Service Environment is suspended; otherwise, <code>false</code>.
   * The environment can be suspended, e.g. when the management endpoint is no longer available
   * (most likely because NSG blocked the incoming traffic).
  */
  suspended?: boolean;
  /**
   * True/false indicating whether the App Service Environment is suspended. The environment can be
   * suspended e.g. when the management endpoint is no longer available
   * (most likely because NSG blocked the incoming traffic).
  */
  dynamicCacheEnabled?: boolean;
  /**
   * Custom settings for changing the behavior of the App Service Environment.
  */
  clusterSettings?: NameValuePair[];
  /**
   * User added ip ranges to whitelist on ASE db
  */
  userWhitelistedIpRanges?: string[];
  /**
   * Flag that displays whether an ASE has linux workers or not
  */
  hasLinuxWorkers?: boolean;
  /**
   * Key Vault ID for ILB App Service Environment default SSL certificate
  */
  sslCertKeyVaultId?: string;
  /**
   * Key Vault Secret Name for ILB App Service Environment default SSL certificate
  */
  sslCertKeyVaultSecretName?: string;
}

/**
 * Diagnostics for an App Service Environment.
*/
export interface HostingEnvironmentDiagnostics {
  /**
   * Name/identifier of the diagnostics.
  */
  name?: string;
  /**
   * Diagnostics output.
  */
  diagnosicsOutput?: string;
}

/**
 * Metric availability and retention.
*/
export interface MetricAvailabilily {
  /**
   * Time grain.
  */
  timeGrain?: string;
  /**
   * Retention period for the current time grain.
  */
  retention?: string;
}

/**
 * Metadata for a metric.
*/
export interface MetricDefinition extends ProxyOnlyResource {
  /**
   * Unit of the metric.
  */
  readonly unit?: string;
  /**
   * Primary aggregation type.
  */
  readonly primaryAggregationType?: string;
  /**
   * List of time grains supported for the metric together with retention period.
  */
  readonly metricAvailabilities?: MetricAvailabilily[];
  /**
   * Friendly name shown in the UI.
  */
  readonly displayName?: string;
}

/**
 * SKU discovery information.
*/
export interface SkuInfo {
  /**
   * Resource type that this SKU applies to.
  */
  resourceType?: string;
  /**
   * Name and tier of the SKU.
  */
  sku?: SkuDescription;
  /**
   * Min, max, and default scale values of the SKU.
  */
  capacity?: SkuCapacity;
}

/**
 * Usage of the quota resource.
*/
export interface Usage extends ProxyOnlyResource {
  /**
   * Friendly name shown in the UI.
  */
  readonly displayName?: string;
  /**
   * Name of the quota resource.
  */
  readonly resourceName?: string;
  /**
   * Units of measurement for the quota resource.
  */
  readonly unit?: string;
  /**
   * The current value of the resource counter.
  */
  readonly currentValue?: number;
  /**
   * The resource limit.
  */
  readonly limit?: number;
  /**
   * Next reset time for the resource counter.
  */
  readonly nextResetTime?: Date;
  /**
   * Compute mode used for this usage. Possible values include: 'Shared', 'Dedicated', 'Dynamic'
  */
  readonly computeMode?: string;
  /**
   * Site mode used for this usage.
  */
  readonly siteMode?: string;
}

/**
 * Worker pool of an App Service Environment ARM resource.
*/
export interface WorkerPoolResource extends ProxyOnlyResource {
  /**
   * Worker size ID for referencing this worker pool.
  */
  workerSizeId?: number;
  /**
   * Shared or dedicated app hosting. Possible values include: 'Shared', 'Dedicated', 'Dynamic'
  */
  computeMode?: string;
  /**
   * VM size of the worker pool instances.
  */
  workerSize?: string;
  /**
   * Number of instances in the worker pool.
  */
  workerCount?: number;
  /**
   * Names of all instances in the worker pool (read only).
  */
  readonly instanceNames?: string[];
  sku?: SkuDescription;
}

/**
 * ARM resource for a app service plan.
*/
export interface AppServicePlanPatchResource extends ProxyOnlyResource {
  /**
   * Target worker tier assigned to the App Service plan.
  */
  workerTierName?: string;
  /**
   * App Service plan status. Possible values include: 'Ready', 'Pending', 'Creating'
  */
  readonly status?: string;
  /**
   * App Service plan subscription.
  */
  readonly subscription?: string;
  /**
   * App Service plan administration site.
  */
  adminSiteName?: string;
  /**
   * Specification for the App Service Environment to use for the App Service plan.
  */
  hostingEnvironmentProfile?: HostingEnvironmentProfile;
  /**
   * Maximum number of instances that can be assigned to this App Service plan.
  */
  readonly maximumNumberOfWorkers?: number;
  /**
   * Geographical location for the App Service plan.
  */
  readonly geoRegion?: string;
  /**
   * If <code>true</code>, apps assigned to this App Service plan can be scaled independently.
   * If <code>false</code>, apps assigned to this App Service plan will scale to all instances of
   * the plan.
  */
  perSiteScaling?: boolean;
  /**
   * Maximum number of total workers allowed for this ElasticScaleEnabled App Service Plan
  */
  maximumElasticWorkerCount?: number;
  /**
   * Number of apps assigned to this App Service plan.
  */
  readonly numberOfSites?: number;
  /**
   * If <code>true</code>, this App Service Plan owns spot instances.
  */
  isSpot?: boolean;
  /**
   * The time when the server farm expires. Valid only if it is a spot server farm.
  */
  spotExpirationTime?: Date;
  /**
   * The time when the server farm free offer expires.
  */
  freeOfferExpirationTime?: Date;
  /**
   * Resource group of the App Service plan.
  */
  readonly resourceGroup?: string;
  /**
   * If Linux app service plan <code>true</code>, <code>false</code> otherwise.
  */
  reserved?: boolean;
  /**
   * Obsolete: If Hyper-V container app service plan <code>true</code>, <code>false</code>
   * otherwise.
  */
  isXenon?: boolean;
  /**
   * If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
  */
  hyperV?: boolean;
  /**
   * Scaling worker count.
  */
  targetWorkerCount?: number;
  /**
   * Scaling worker size ID.
  */
  targetWorkerSizeId?: number;
  /**
   * Provisioning state of the App Service Environment. Possible values include: 'Succeeded',
   * 'Failed', 'Canceled', 'InProgress', 'Deleting'
  */
  readonly provisioningState?: string;
}

/**
 * Hybrid Connection limits contract. This is used to return the plan limits of Hybrid Connections.
*/
export interface HybridConnectionLimits extends ProxyOnlyResource {
  /**
   * The current number of Hybrid Connections.
  */
  readonly current?: number;
  /**
   * The maximum number of Hybrid Connections allowed.
  */
  readonly maximum?: number;
}

/**
 * Used for getting ResourceHealthCheck settings.
*/
export interface ResourceHealthMetadata extends ProxyOnlyResource {
  /**
   * The category that the resource matches in the RHC Policy File
  */
  category?: string;
  /**
   * Is there a health signal for the resource
  */
  signalAvailability?: boolean;
}

/**
 * Collection of certificate orders.
*/
export interface AppServiceCertificateOrderCollection extends Array<AppServiceCertificateOrder> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of certificate order certificates.
*/
export interface AppServiceCertificateCollection extends Array<AppServiceCertificateResource> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Azure resource manager operation metadata.
*/
export interface CsmOperationCollection extends Array<CsmOperationDescription> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of domains.
*/
export interface DomainCollection extends Array<Domain> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of domain name identifiers.
*/
export interface NameIdentifierCollection extends Array<NameIdentifier> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of domain ownership identifiers.
*/
export interface DomainOwnershipIdentifierCollection extends Array<DomainOwnershipIdentifier> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Top-level domains.
*/
export interface TopLevelDomainCollection extends Array<TopLevelDomain> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of top-level domain legal agreements.
*/
export interface TldLegalAgreementCollection extends Array<TldLegalAgreement> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of certificates.
*/
export interface CertificateCollection extends Array<Certificate> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of deleted apps.
*/
export interface DeletedWebAppCollection extends Array<DeletedSite> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of detector responses
*/
export interface DetectorResponseCollection extends Array<DetectorResponse> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Diagnostic Categories
*/
export interface DiagnosticCategoryCollection extends Array<DiagnosticCategory> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Diagnostic Analyses
*/
export interface DiagnosticAnalysisCollection extends Array<AnalysisDefinition> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Diagnostic Detectors
*/
export interface DiagnosticDetectorCollection extends Array<DetectorDefinition> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Application Stacks
*/
export interface ApplicationStackCollection extends Array<ApplicationStack> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of recommendations.
*/
export interface RecommendationCollection extends Array<Recommendation> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of source controls.
*/
export interface SourceControlCollection extends Array<SourceControl> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Billing Meters
*/
export interface BillingMeterCollection extends Array<BillingMeter> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of geographical regions.
*/
export interface GeoRegionCollection extends Array<GeoRegion> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of identifiers.
*/
export interface IdentifierCollection extends Array<Identifier> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of premier add-on offers.
*/
export interface PremierAddOnOfferCollection extends Array<PremierAddOnOffer> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of App Service apps.
*/
export interface WebAppCollection extends Array<Site> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of backup items.
*/
export interface BackupItemCollection extends Array<BackupItem> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of site configurations.
*/
export interface SiteConfigResourceCollection extends Array<SiteConfigResource> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of metadata for the app configuration snapshots that can be restored.
*/
export interface SiteConfigurationSnapshotInfoCollection extends
Array<SiteConfigurationSnapshotInfo> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Kudu continuous web job information elements.
*/
export interface ContinuousWebJobCollection extends Array<ContinuousWebJob> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of app deployments.
*/
export interface DeploymentCollection extends Array<Deployment> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Kudu function information elements.
*/
export interface FunctionEnvelopeCollection extends Array<FunctionEnvelope> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of hostname bindings.
*/
export interface HostNameBindingCollection extends Array<HostNameBinding> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of app instances.
*/
export interface WebAppInstanceCollection extends Array<SiteInstance> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Kudu process information elements.
*/
export interface ProcessInfoCollection extends Array<ProcessInfo> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Kudu thread information elements.
*/
export interface ProcessModuleInfoCollection extends Array<ProcessModuleInfo> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Kudu thread information elements.
*/
export interface ProcessThreadInfoCollection extends Array<ProcessThreadInfo> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of metric definitions.
*/
export interface ResourceMetricDefinitionCollection extends Array<ResourceMetricDefinition> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of metric responses.
*/
export interface ResourceMetricCollection extends Array<ResourceMetric> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of performance monitor counters.
*/
export interface PerfMonCounterCollection extends Array<PerfMonResponse> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of public certificates
*/
export interface PublicCertificateCollection extends Array<PublicCertificate> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Kudu site extension information elements.
*/
export interface SiteExtensionInfoCollection extends Array<SiteExtensionInfo> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of slot differences.
*/
export interface SlotDifferenceCollection extends Array<SlotDifference> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of snapshots which can be used to revert an app to a previous time.
*/
export interface SnapshotCollection extends Array<Snapshot> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Kudu continuous web job information elements.
*/
export interface TriggeredWebJobCollection extends Array<TriggeredWebJob> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Kudu continuous web job information elements.
*/
export interface TriggeredJobHistoryCollection extends Array<TriggeredJobHistory> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of CSM usage quotas.
*/
export interface CsmUsageQuotaCollection extends Array<CsmUsageQuota> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of Kudu web job information elements.
*/
export interface WebJobCollection extends Array<WebJob> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of App Service Environments.
*/
export interface AppServiceEnvironmentCollection extends Array<AppServiceEnvironmentResource> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of stamp capacities.
*/
export interface StampCapacityCollection extends Array<StampCapacity> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of worker pools.
*/
export interface WorkerPoolCollection extends Array<WorkerPoolResource> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of SKU information.
*/
export interface SkuInfoCollection extends Array<SkuInfo> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of usages.
*/
export interface UsageCollection extends Array<Usage> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of App Service plans.
*/
export interface AppServicePlanCollection extends Array<AppServicePlan> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of resources.
*/
export interface ResourceCollection extends Array<string> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of hostname bindings.
*/
export interface HybridConnectionCollection extends Array<HybridConnection> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}

/**
 * Collection of resource health metadata.
*/
export interface ResourceHealthMetadataCollection extends Array<ResourceHealthMetadata> {
  /**
   * Link to next page of resources.
  */
  readonly nextLink?: string;
}
