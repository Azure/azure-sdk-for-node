/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const WebResource = msRest.WebResource;

/**
 * Returns review details for the review Id passed.
 *
 * @param {string} teamName Your Team Name.
 *
 * @param {string} reviewId Id of the review.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Review} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReview(teamName, reviewId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (reviewId === null || reviewId === undefined || typeof reviewId.valueOf() !== 'string') {
      throw new Error('reviewId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  requestUrl = requestUrl.replace('{reviewId}', encodeURIComponent(reviewId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Review']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Get the Job Details for a Job Id.
 *
 * @param {string} teamName Your Team Name.
 *
 * @param {string} jobId Id of the job.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Job} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getJobDetails(teamName, jobId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/jobs/{JobId}';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  requestUrl = requestUrl.replace('{JobId}', encodeURIComponent(jobId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Job']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * The reviews created would show up for Reviewers on your team. As Reviewers
 * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
 * on the specified CallBackEndpoint.
 *
 * <h3>CallBack Schemas </h3>
 * <h4>Review Completion CallBack Sample</h4>
 * <p>
 * {<br/>
 * "ReviewId": "<Review Id>",<br/>
 * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
 * "ModifiedBy": "<Name of the Reviewer>",<br/>
 * "CallBackType": "Review",<br/>
 * "ContentId": "<The ContentId that was specified input>",<br/>
 * "Metadata": {<br/>
 * "adultscore": "0.xxx",<br/>
 * "a": "False",<br/>
 * "racyscore": "0.xxx",<br/>
 * "r": "True"<br/>
 * },<br/>
 * "ReviewerResultTags": {<br/>
 * "a": "False",<br/>
 * "r": "True"<br/>
 * }<br/>
 * }<br/>
 *
 * </p>.
 *
 * @param {string} urlContentType The content type.
 *
 * @param {string} teamName Your team name.
 *
 * @param {array} createReviewBody Body for create reviews API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.subTeam] SubTeam of your team, you want to assign
 * the created review to.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createReviews(urlContentType, teamName, createReviewBody, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let subTeam = (options && options.subTeam !== undefined) ? options.subTeam : undefined;
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (urlContentType === null || urlContentType === undefined || typeof urlContentType.valueOf() !== 'string') {
      throw new Error('urlContentType cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (subTeam !== null && subTeam !== undefined && typeof subTeam.valueOf() !== 'string') {
      throw new Error('subTeam must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  let queryParameters = [];
  if (subTeam !== null && subTeam !== undefined) {
    queryParameters.push('subTeam=' + encodeURIComponent(subTeam));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (urlContentType !== undefined && urlContentType !== null) {
    httpRequest.headers['UrlContentType'] = urlContentType;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createReviewBody !== null && createReviewBody !== undefined) {
      let requestModelMapper = {
        required: true,
        serializedName: 'createReviewBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serializedName: 'CreateReviewBodyItemElementType',
              type: {
                name: 'Composite',
                className: 'CreateReviewBodyItem'
              }
          }
        }
      };
      requestModel = client.serialize(requestModelMapper, createReviewBody, 'createReviewBody');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createReviewBody, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'StringElementType',
                  type: {
                    name: 'String'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * A job Id will be returned for the content posted on this endpoint.
 *
 * Once the content is evaluated against the Workflow provided the review will
 * be created or ignored based on the workflow expression.
 *
 * <h3>CallBack Schemas </h3>
 *
 * <p>
 * <h4>Job Completion CallBack Sample</h4><br/>
 *
 * {<br/>
 * "JobId": "<Job Id>,<br/>
 * "ReviewId": "<Review Id, if the Job resulted in a Review to be
 * created>",<br/>
 * "WorkFlowId": "default",<br/>
 * "Status": "<This will be one of Complete, InProgress, Error>",<br/>
 * "ContentType": "Image",<br/>
 * "ContentId": "<This is the ContentId that was specified on input>",<br/>
 * "CallBackType": "Job",<br/>
 * "Metadata": {<br/>
 * "adultscore": "0.xxx",<br/>
 * "a": "False",<br/>
 * "racyscore": "0.xxx",<br/>
 * "r": "True"<br/>
 * }<br/>
 * }<br/>
 *
 * </p>
 * <p>
 * <h4>Review Completion CallBack Sample</h4><br/>
 *
 * {
 * "ReviewId": "<Review Id>",<br/>
 * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
 * "ModifiedBy": "<Name of the Reviewer>",<br/>
 * "CallBackType": "Review",<br/>
 * "ContentId": "<The ContentId that was specified input>",<br/>
 * "Metadata": {<br/>
 * "adultscore": "0.xxx",
 * "a": "False",<br/>
 * "racyscore": "0.xxx",<br/>
 * "r": "True"<br/>
 * },<br/>
 * "ReviewerResultTags": {<br/>
 * "a": "False",<br/>
 * "r": "True"<br/>
 * }<br/>
 * }<br/>
 *
 * </p>.
 *
 * @param {string} teamName Your team name.
 *
 * @param {string} contentType Image, Text or Video. Possible values include:
 * 'Image', 'Text', 'Video'
 *
 * @param {string} contentId Id/Name to identify the content submitted.
 *
 * @param {string} workflowName Workflow Name that you want to invoke.
 *
 * @param {string} jobContentType The content type. Possible values include:
 * 'application/json', 'image/jpeg'
 *
 * @param {object} content Content to evaluate.
 *
 * @param {string} content.contentValue Content to evaluate for a job.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.callBackEndpoint] Callback endpoint for posting the
 * create job result.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link JobId} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createJob(teamName, contentType, contentId, workflowName, jobContentType, content, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let callBackEndpoint = (options && options.callBackEndpoint !== undefined) ? options.callBackEndpoint : undefined;
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (contentType === null || contentType === undefined || typeof contentType.valueOf() !== 'string') {
      throw new Error('contentType cannot be null or undefined and it must be of type string.');
    }
    if (contentId === null || contentId === undefined || typeof contentId.valueOf() !== 'string') {
      throw new Error('contentId cannot be null or undefined and it must be of type string.');
    }
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
    if (callBackEndpoint !== null && callBackEndpoint !== undefined && typeof callBackEndpoint.valueOf() !== 'string') {
      throw new Error('callBackEndpoint must be of type string.');
    }
    if (jobContentType === null || jobContentType === undefined || typeof jobContentType.valueOf() !== 'string') {
      throw new Error('jobContentType cannot be null or undefined and it must be of type string.');
    }
    if (content === null || content === undefined) {
      throw new Error('content cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/jobs';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  let queryParameters = [];
  queryParameters.push('ContentType=' + encodeURIComponent(contentType));
  queryParameters.push('ContentId=' + encodeURIComponent(contentId));
  queryParameters.push('WorkflowName=' + encodeURIComponent(workflowName));
  if (callBackEndpoint !== null && callBackEndpoint !== undefined) {
    queryParameters.push('CallBackEndpoint=' + encodeURIComponent(callBackEndpoint));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (jobContentType !== undefined && jobContentType !== null) {
    httpRequest.headers['Content-Type'] = jobContentType;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (content !== null && content !== undefined) {
      let requestModelMapper = new client.models['Content']().mapper();
      requestModel = client.serialize(requestModelMapper, content, 'content');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(content, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['JobId']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * The reviews created would show up for Reviewers on your team. As Reviewers
 * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
 * on the specified CallBackEndpoint.
 *
 * <h3>CallBack Schemas </h3>
 * <h4>Review Completion CallBack Sample</h4>
 * <p>
 * {<br/>
 * "ReviewId": "<Review Id>",<br/>
 * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
 * "ModifiedBy": "<Name of the Reviewer>",<br/>
 * "CallBackType": "Review",<br/>
 * "ContentId": "<The ContentId that was specified input>",<br/>
 * "Metadata": {<br/>
 * "adultscore": "0.xxx",<br/>
 * "a": "False",<br/>
 * "racyscore": "0.xxx",<br/>
 * "r": "True"<br/>
 * },<br/>
 * "ReviewerResultTags": {<br/>
 * "a": "False",<br/>
 * "r": "True"<br/>
 * }<br/>
 * }<br/>
 *
 * </p>.
 *
 * @param {string} teamName Your team name.
 *
 * @param {string} reviewId Id of the review.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timescale] Timescale of the video you are adding
 * frames to.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addVideoFrame(teamName, reviewId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timescale = (options && options.timescale !== undefined) ? options.timescale : undefined;
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (reviewId === null || reviewId === undefined || typeof reviewId.valueOf() !== 'string') {
      throw new Error('reviewId cannot be null or undefined and it must be of type string.');
    }
    if (timescale !== null && timescale !== undefined && typeof timescale !== 'number') {
      throw new Error('timescale must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/frames';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  requestUrl = requestUrl.replace('{reviewId}', encodeURIComponent(reviewId));
  let queryParameters = [];
  if (timescale !== null && timescale !== undefined) {
    queryParameters.push('timescale=' + encodeURIComponent(timescale.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * The reviews created would show up for Reviewers on your team. As Reviewers
 * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
 * on the specified CallBackEndpoint.
 *
 * <h3>CallBack Schemas </h3>
 * <h4>Review Completion CallBack Sample</h4>
 * <p>
 * {<br/>
 * "ReviewId": "<Review Id>",<br/>
 * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
 * "ModifiedBy": "<Name of the Reviewer>",<br/>
 * "CallBackType": "Review",<br/>
 * "ContentId": "<The ContentId that was specified input>",<br/>
 * "Metadata": {<br/>
 * "adultscore": "0.xxx",<br/>
 * "a": "False",<br/>
 * "racyscore": "0.xxx",<br/>
 * "r": "True"<br/>
 * },<br/>
 * "ReviewerResultTags": {<br/>
 * "a": "False",<br/>
 * "r": "True"<br/>
 * }<br/>
 * }<br/>
 *
 * </p>.
 *
 * @param {string} teamName Your team name.
 *
 * @param {string} reviewId Id of the review.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.startSeed] Time stamp of the frame from where you
 * want to start fetching the frames.
 *
 * @param {number} [options.noOfRecords] Number of frames to fetch.
 *
 * @param {string} [options.filter] Get frames filtered by tags.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Frames} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVideoFrames(teamName, reviewId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let startSeed = (options && options.startSeed !== undefined) ? options.startSeed : undefined;
  let noOfRecords = (options && options.noOfRecords !== undefined) ? options.noOfRecords : undefined;
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (reviewId === null || reviewId === undefined || typeof reviewId.valueOf() !== 'string') {
      throw new Error('reviewId cannot be null or undefined and it must be of type string.');
    }
    if (startSeed !== null && startSeed !== undefined && typeof startSeed !== 'number') {
      throw new Error('startSeed must be of type number.');
    }
    if (noOfRecords !== null && noOfRecords !== undefined && typeof noOfRecords !== 'number') {
      throw new Error('noOfRecords must be of type number.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/frames';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  requestUrl = requestUrl.replace('{reviewId}', encodeURIComponent(reviewId));
  let queryParameters = [];
  if (startSeed !== null && startSeed !== undefined) {
    queryParameters.push('startSeed=' + encodeURIComponent(startSeed.toString()));
  }
  if (noOfRecords !== null && noOfRecords !== undefined) {
    queryParameters.push('noOfRecords=' + encodeURIComponent(noOfRecords.toString()));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Frames']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Publish video review to make it available for review.
 *
 * @param {string} teamName Your team name.
 *
 * @param {string} reviewId Id of the review.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _publishVideoReview(teamName, reviewId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (reviewId === null || reviewId === undefined || typeof reviewId.valueOf() !== 'string') {
      throw new Error('reviewId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/publish';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  requestUrl = requestUrl.replace('{reviewId}', encodeURIComponent(reviewId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * This API adds a transcript screen text result file for a video review.
 * Transcript screen text result file is a result of Screen Text API . In order
 * to generate transcript screen text result file , a transcript file has to be
 * screened for profanity using Screen Text API.
 *
 * @param {string} contentType The content type.
 *
 * @param {string} teamName Your team name.
 *
 * @param {string} reviewId Id of the review.
 *
 * @param {array} transcriptModerationBody Body for add video transcript
 * moderation result API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addVideoTranscriptModerationResult(contentType, teamName, reviewId, transcriptModerationBody, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (contentType === null || contentType === undefined || typeof contentType.valueOf() !== 'string') {
      throw new Error('contentType cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (reviewId === null || reviewId === undefined || typeof reviewId.valueOf() !== 'string') {
      throw new Error('reviewId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/transcriptmoderationresult';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  requestUrl = requestUrl.replace('{reviewId}', encodeURIComponent(reviewId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (contentType !== undefined && contentType !== null) {
    httpRequest.headers['Content-Type'] = contentType;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (transcriptModerationBody !== null && transcriptModerationBody !== undefined) {
      let requestModelMapper = {
        required: true,
        serializedName: 'transcriptModerationBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serializedName: 'TranscriptModerationBodyItemElementType',
              type: {
                name: 'Composite',
                className: 'TranscriptModerationBodyItem'
              }
          }
        }
      };
      requestModel = client.serialize(requestModelMapper, transcriptModerationBody, 'transcriptModerationBody');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(transcriptModerationBody, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * This API adds a transcript file (text version of all the words spoken in a
 * video) to a video review. The file should be a valid WebVTT format.
 *
 * @param {string} teamName Your team name.
 *
 * @param {string} reviewId Id of the review.
 *
 * @param {object} vTTfile Transcript file of the video.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addVideoTranscript(teamName, reviewId, vTTfile, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let contentType = 'text/plain';
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (reviewId === null || reviewId === undefined || typeof reviewId.valueOf() !== 'string') {
      throw new Error('reviewId cannot be null or undefined and it must be of type string.');
    }
    if (vTTfile === null || vTTfile === undefined) {
      throw new Error('vTTfile cannot be null or undefined and it must be of type object.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/transcript';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  requestUrl = requestUrl.replace('{reviewId}', encodeURIComponent(reviewId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'text/plain';
  if (contentType !== undefined && contentType !== null) {
    httpRequest.headers['Content-Type'] = contentType;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = vTTfile;
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * The reviews created would show up for Reviewers on your team. As Reviewers
 * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
 * on the specified CallBackEndpoint.
 *
 * <h3>CallBack Schemas </h3>
 * <h4>Review Completion CallBack Sample</h4>
 * <p>
 * {<br/>
 * "ReviewId": "<Review Id>",<br/>
 * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
 * "ModifiedBy": "<Name of the Reviewer>",<br/>
 * "CallBackType": "Review",<br/>
 * "ContentId": "<The ContentId that was specified input>",<br/>
 * "Metadata": {<br/>
 * "adultscore": "0.xxx",<br/>
 * "a": "False",<br/>
 * "racyscore": "0.xxx",<br/>
 * "r": "True"<br/>
 * },<br/>
 * "ReviewerResultTags": {<br/>
 * "a": "False",<br/>
 * "r": "True"<br/>
 * }<br/>
 * }<br/>
 *
 * </p>.
 *
 * @param {string} contentType The content type.
 *
 * @param {string} teamName Your team name.
 *
 * @param {array} createVideoReviewsBody Body for create reviews API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.subTeam] SubTeam of your team, you want to assign
 * the created review to.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createVideoReviews(contentType, teamName, createVideoReviewsBody, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let subTeam = (options && options.subTeam !== undefined) ? options.subTeam : undefined;
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (contentType === null || contentType === undefined || typeof contentType.valueOf() !== 'string') {
      throw new Error('contentType cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (subTeam !== null && subTeam !== undefined && typeof subTeam.valueOf() !== 'string') {
      throw new Error('subTeam must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  let queryParameters = [];
  if (subTeam !== null && subTeam !== undefined) {
    queryParameters.push('subTeam=' + encodeURIComponent(subTeam));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (contentType !== undefined && contentType !== null) {
    httpRequest.headers['Content-Type'] = contentType;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createVideoReviewsBody !== null && createVideoReviewsBody !== undefined) {
      let requestModelMapper = {
        required: true,
        serializedName: 'CreateVideoReviewsBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serializedName: 'CreateVideoReviewsBodyItemElementType',
              type: {
                name: 'Composite',
                className: 'CreateVideoReviewsBodyItem'
              }
          }
        }
      };
      requestModel = client.serialize(requestModelMapper, createVideoReviewsBody, 'createVideoReviewsBody');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createVideoReviewsBody, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'StringElementType',
                  type: {
                    name: 'String'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Use this method to add frames for a video review.Timescale: This parameter
 * is a factor which is used to convert the timestamp on a frame into
 * milliseconds. Timescale is provided in the output of the Content Moderator
 * video media processor on the Azure Media Services platform.Timescale in the
 * Video Moderation output is Ticks/Second.
 *
 * @param {string} contentType The content type.
 *
 * @param {string} teamName Your team name.
 *
 * @param {string} reviewId Id of the review.
 *
 * @param {array} videoFrameBody Body for add video frames API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timescale] Timescale of the video.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addVideoFrameUrl(contentType, teamName, reviewId, videoFrameBody, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timescale = (options && options.timescale !== undefined) ? options.timescale : undefined;
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (contentType === null || contentType === undefined || typeof contentType.valueOf() !== 'string') {
      throw new Error('contentType cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (reviewId === null || reviewId === undefined || typeof reviewId.valueOf() !== 'string') {
      throw new Error('reviewId cannot be null or undefined and it must be of type string.');
    }
    if (timescale !== null && timescale !== undefined && typeof timescale !== 'number') {
      throw new Error('timescale must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/frames';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  requestUrl = requestUrl.replace('{reviewId}', encodeURIComponent(reviewId));
  let queryParameters = [];
  if (timescale !== null && timescale !== undefined) {
    queryParameters.push('timescale=' + encodeURIComponent(timescale.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (contentType !== undefined && contentType !== null) {
    httpRequest.headers['Content-Type'] = contentType;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (videoFrameBody !== null && videoFrameBody !== undefined) {
      let requestModelMapper = {
        required: true,
        serializedName: 'videoFrameBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serializedName: 'VideoFrameBodyItemElementType',
              type: {
                name: 'Composite',
                className: 'VideoFrameBodyItem'
              }
          }
        }
      };
      requestModel = client.serialize(requestModelMapper, videoFrameBody, 'videoFrameBody');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(videoFrameBody, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Use this method to add frames for a video review.Timescale: This parameter
 * is a factor which is used to convert the timestamp on a frame into
 * milliseconds. Timescale is provided in the output of the Content Moderator
 * video media processor on the Azure Media Services platform.Timescale in the
 * Video Moderation output is Ticks/Second.
 *
 * @param {string} contentType The content type.
 *
 * @param {string} teamName Your team name.
 *
 * @param {string} reviewId Id of the review.
 *
 * @param {object} frameImageZip Zip file containing frame images.
 *
 * @param {string} frameMetadata Metadata of the frame.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timescale] Timescale of the video .
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addVideoFrameStream(contentType, teamName, reviewId, frameImageZip, frameMetadata, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timescale = (options && options.timescale !== undefined) ? options.timescale : undefined;
  // Validate
  try {
    if (this.client.baseUrl === null || this.client.baseUrl === undefined || typeof this.client.baseUrl.valueOf() !== 'string') {
      throw new Error('this.client.baseUrl cannot be null or undefined and it must be of type string.');
    }
    if (contentType === null || contentType === undefined || typeof contentType.valueOf() !== 'string') {
      throw new Error('contentType cannot be null or undefined and it must be of type string.');
    }
    if (teamName === null || teamName === undefined || typeof teamName.valueOf() !== 'string') {
      throw new Error('teamName cannot be null or undefined and it must be of type string.');
    }
    if (reviewId === null || reviewId === undefined || typeof reviewId.valueOf() !== 'string') {
      throw new Error('reviewId cannot be null or undefined and it must be of type string.');
    }
    if (timescale !== null && timescale !== undefined && typeof timescale !== 'number') {
      throw new Error('timescale must be of type number.');
    }
    if (frameImageZip === null || frameImageZip === undefined) {
      throw new Error('frameImageZip cannot be null or undefined and it must be of type object.');
    }
    if (frameMetadata === null || frameMetadata === undefined || typeof frameMetadata.valueOf() !== 'string') {
      throw new Error('frameMetadata cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/frames';
  requestUrl = requestUrl.replace('{baseUrl}', this.client.baseUrl);
  requestUrl = requestUrl.replace('{teamName}', encodeURIComponent(teamName));
  requestUrl = requestUrl.replace('{reviewId}', encodeURIComponent(reviewId));
  let queryParameters = [];
  if (timescale !== null && timescale !== undefined) {
    queryParameters.push('timescale=' + encodeURIComponent(timescale.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'multipart/form-data';
  if (contentType !== undefined && contentType !== null) {
    httpRequest.headers['Content-Type'] = contentType;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let formData = {};
  if (frameImageZip !== undefined && frameImageZip !== null) {
    formData['frameImageZip'] = frameImageZip;
  }
  if (frameMetadata !== undefined && frameMetadata !== null) {
    formData['frameMetadata'] = frameMetadata;
  }
  httpRequest.formData = formData;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['APIError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a Reviews. */
class Reviews {
  /**
   * Create a Reviews.
   * @param {ContentModeratorAPIClient} client Reference to the service client.
   */
  constructor(client) {
    this.client = client;
    this._getReview = _getReview;
    this._getJobDetails = _getJobDetails;
    this._createReviews = _createReviews;
    this._createJob = _createJob;
    this._addVideoFrame = _addVideoFrame;
    this._getVideoFrames = _getVideoFrames;
    this._publishVideoReview = _publishVideoReview;
    this._addVideoTranscriptModerationResult = _addVideoTranscriptModerationResult;
    this._addVideoTranscript = _addVideoTranscript;
    this._createVideoReviews = _createVideoReviews;
    this._addVideoFrameUrl = _addVideoFrameUrl;
    this._addVideoFrameStream = _addVideoFrameStream;
  }

  /**
   * Returns review details for the review Id passed.
   *
   * @param {string} teamName Your Team Name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Review>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReviewWithHttpOperationResponse(teamName, reviewId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReview(teamName, reviewId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Returns review details for the review Id passed.
   *
   * @param {string} teamName Your Team Name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Review} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Review} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReview(teamName, reviewId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReview(teamName, reviewId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReview(teamName, reviewId, options, optionalCallback);
    }
  }

  /**
   * Get the Job Details for a Job Id.
   *
   * @param {string} teamName Your Team Name.
   *
   * @param {string} jobId Id of the job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Job>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getJobDetailsWithHttpOperationResponse(teamName, jobId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getJobDetails(teamName, jobId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Get the Job Details for a Job Id.
   *
   * @param {string} teamName Your Team Name.
   *
   * @param {string} jobId Id of the job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Job} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Job} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getJobDetails(teamName, jobId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getJobDetails(teamName, jobId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getJobDetails(teamName, jobId, options, optionalCallback);
    }
  }

  /**
   * The reviews created would show up for Reviewers on your team. As Reviewers
   * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
   * on the specified CallBackEndpoint.
   *
   * <h3>CallBack Schemas </h3>
   * <h4>Review Completion CallBack Sample</h4>
   * <p>
   * {<br/>
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} urlContentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {array} createReviewBody Body for create reviews API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.subTeam] SubTeam of your team, you want to assign
   * the created review to.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createReviewsWithHttpOperationResponse(urlContentType, teamName, createReviewBody, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createReviews(urlContentType, teamName, createReviewBody, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * The reviews created would show up for Reviewers on your team. As Reviewers
   * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
   * on the specified CallBackEndpoint.
   *
   * <h3>CallBack Schemas </h3>
   * <h4>Review Completion CallBack Sample</h4>
   * <p>
   * {<br/>
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} urlContentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {array} createReviewBody Body for create reviews API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.subTeam] SubTeam of your team, you want to assign
   * the created review to.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createReviews(urlContentType, teamName, createReviewBody, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createReviews(urlContentType, teamName, createReviewBody, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createReviews(urlContentType, teamName, createReviewBody, options, optionalCallback);
    }
  }

  /**
   * A job Id will be returned for the content posted on this endpoint.
   *
   * Once the content is evaluated against the Workflow provided the review will
   * be created or ignored based on the workflow expression.
   *
   * <h3>CallBack Schemas </h3>
   *
   * <p>
   * <h4>Job Completion CallBack Sample</h4><br/>
   *
   * {<br/>
   * "JobId": "<Job Id>,<br/>
   * "ReviewId": "<Review Id, if the Job resulted in a Review to be
   * created>",<br/>
   * "WorkFlowId": "default",<br/>
   * "Status": "<This will be one of Complete, InProgress, Error>",<br/>
   * "ContentType": "Image",<br/>
   * "ContentId": "<This is the ContentId that was specified on input>",<br/>
   * "CallBackType": "Job",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>
   * <p>
   * <h4>Review Completion CallBack Sample</h4><br/>
   *
   * {
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} contentType Image, Text or Video. Possible values include:
   * 'Image', 'Text', 'Video'
   *
   * @param {string} contentId Id/Name to identify the content submitted.
   *
   * @param {string} workflowName Workflow Name that you want to invoke.
   *
   * @param {string} jobContentType The content type. Possible values include:
   * 'application/json', 'image/jpeg'
   *
   * @param {object} content Content to evaluate.
   *
   * @param {string} content.contentValue Content to evaluate for a job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.callBackEndpoint] Callback endpoint for posting the
   * create job result.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<JobId>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createJobWithHttpOperationResponse(teamName, contentType, contentId, workflowName, jobContentType, content, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createJob(teamName, contentType, contentId, workflowName, jobContentType, content, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * A job Id will be returned for the content posted on this endpoint.
   *
   * Once the content is evaluated against the Workflow provided the review will
   * be created or ignored based on the workflow expression.
   *
   * <h3>CallBack Schemas </h3>
   *
   * <p>
   * <h4>Job Completion CallBack Sample</h4><br/>
   *
   * {<br/>
   * "JobId": "<Job Id>,<br/>
   * "ReviewId": "<Review Id, if the Job resulted in a Review to be
   * created>",<br/>
   * "WorkFlowId": "default",<br/>
   * "Status": "<This will be one of Complete, InProgress, Error>",<br/>
   * "ContentType": "Image",<br/>
   * "ContentId": "<This is the ContentId that was specified on input>",<br/>
   * "CallBackType": "Job",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>
   * <p>
   * <h4>Review Completion CallBack Sample</h4><br/>
   *
   * {
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} contentType Image, Text or Video. Possible values include:
   * 'Image', 'Text', 'Video'
   *
   * @param {string} contentId Id/Name to identify the content submitted.
   *
   * @param {string} workflowName Workflow Name that you want to invoke.
   *
   * @param {string} jobContentType The content type. Possible values include:
   * 'application/json', 'image/jpeg'
   *
   * @param {object} content Content to evaluate.
   *
   * @param {string} content.contentValue Content to evaluate for a job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.callBackEndpoint] Callback endpoint for posting the
   * create job result.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {JobId} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link JobId} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createJob(teamName, contentType, contentId, workflowName, jobContentType, content, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createJob(teamName, contentType, contentId, workflowName, jobContentType, content, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createJob(teamName, contentType, contentId, workflowName, jobContentType, content, options, optionalCallback);
    }
  }

  /**
   * The reviews created would show up for Reviewers on your team. As Reviewers
   * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
   * on the specified CallBackEndpoint.
   *
   * <h3>CallBack Schemas </h3>
   * <h4>Review Completion CallBack Sample</h4>
   * <p>
   * {<br/>
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timescale] Timescale of the video you are adding
   * frames to.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addVideoFrameWithHttpOperationResponse(teamName, reviewId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addVideoFrame(teamName, reviewId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * The reviews created would show up for Reviewers on your team. As Reviewers
   * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
   * on the specified CallBackEndpoint.
   *
   * <h3>CallBack Schemas </h3>
   * <h4>Review Completion CallBack Sample</h4>
   * <p>
   * {<br/>
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timescale] Timescale of the video you are adding
   * frames to.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addVideoFrame(teamName, reviewId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addVideoFrame(teamName, reviewId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addVideoFrame(teamName, reviewId, options, optionalCallback);
    }
  }

  /**
   * The reviews created would show up for Reviewers on your team. As Reviewers
   * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
   * on the specified CallBackEndpoint.
   *
   * <h3>CallBack Schemas </h3>
   * <h4>Review Completion CallBack Sample</h4>
   * <p>
   * {<br/>
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.startSeed] Time stamp of the frame from where you
   * want to start fetching the frames.
   *
   * @param {number} [options.noOfRecords] Number of frames to fetch.
   *
   * @param {string} [options.filter] Get frames filtered by tags.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Frames>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVideoFramesWithHttpOperationResponse(teamName, reviewId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVideoFrames(teamName, reviewId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * The reviews created would show up for Reviewers on your team. As Reviewers
   * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
   * on the specified CallBackEndpoint.
   *
   * <h3>CallBack Schemas </h3>
   * <h4>Review Completion CallBack Sample</h4>
   * <p>
   * {<br/>
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.startSeed] Time stamp of the frame from where you
   * want to start fetching the frames.
   *
   * @param {number} [options.noOfRecords] Number of frames to fetch.
   *
   * @param {string} [options.filter] Get frames filtered by tags.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Frames} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Frames} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVideoFrames(teamName, reviewId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVideoFrames(teamName, reviewId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVideoFrames(teamName, reviewId, options, optionalCallback);
    }
  }

  /**
   * Publish video review to make it available for review.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  publishVideoReviewWithHttpOperationResponse(teamName, reviewId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._publishVideoReview(teamName, reviewId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Publish video review to make it available for review.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  publishVideoReview(teamName, reviewId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._publishVideoReview(teamName, reviewId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._publishVideoReview(teamName, reviewId, options, optionalCallback);
    }
  }

  /**
   * This API adds a transcript screen text result file for a video review.
   * Transcript screen text result file is a result of Screen Text API . In order
   * to generate transcript screen text result file , a transcript file has to be
   * screened for profanity using Screen Text API.
   *
   * @param {string} contentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {array} transcriptModerationBody Body for add video transcript
   * moderation result API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addVideoTranscriptModerationResultWithHttpOperationResponse(contentType, teamName, reviewId, transcriptModerationBody, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addVideoTranscriptModerationResult(contentType, teamName, reviewId, transcriptModerationBody, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * This API adds a transcript screen text result file for a video review.
   * Transcript screen text result file is a result of Screen Text API . In order
   * to generate transcript screen text result file , a transcript file has to be
   * screened for profanity using Screen Text API.
   *
   * @param {string} contentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {array} transcriptModerationBody Body for add video transcript
   * moderation result API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addVideoTranscriptModerationResult(contentType, teamName, reviewId, transcriptModerationBody, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addVideoTranscriptModerationResult(contentType, teamName, reviewId, transcriptModerationBody, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addVideoTranscriptModerationResult(contentType, teamName, reviewId, transcriptModerationBody, options, optionalCallback);
    }
  }

  /**
   * This API adds a transcript file (text version of all the words spoken in a
   * video) to a video review. The file should be a valid WebVTT format.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} vTTfile Transcript file of the video.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addVideoTranscriptWithHttpOperationResponse(teamName, reviewId, vTTfile, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addVideoTranscript(teamName, reviewId, vTTfile, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * This API adds a transcript file (text version of all the words spoken in a
   * video) to a video review. The file should be a valid WebVTT format.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} vTTfile Transcript file of the video.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addVideoTranscript(teamName, reviewId, vTTfile, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addVideoTranscript(teamName, reviewId, vTTfile, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addVideoTranscript(teamName, reviewId, vTTfile, options, optionalCallback);
    }
  }

  /**
   * The reviews created would show up for Reviewers on your team. As Reviewers
   * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
   * on the specified CallBackEndpoint.
   *
   * <h3>CallBack Schemas </h3>
   * <h4>Review Completion CallBack Sample</h4>
   * <p>
   * {<br/>
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} contentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {array} createVideoReviewsBody Body for create reviews API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.subTeam] SubTeam of your team, you want to assign
   * the created review to.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createVideoReviewsWithHttpOperationResponse(contentType, teamName, createVideoReviewsBody, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createVideoReviews(contentType, teamName, createVideoReviewsBody, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * The reviews created would show up for Reviewers on your team. As Reviewers
   * complete reviewing, results of the Review would be POSTED (i.e. HTTP POST)
   * on the specified CallBackEndpoint.
   *
   * <h3>CallBack Schemas </h3>
   * <h4>Review Completion CallBack Sample</h4>
   * <p>
   * {<br/>
   * "ReviewId": "<Review Id>",<br/>
   * "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
   * "ModifiedBy": "<Name of the Reviewer>",<br/>
   * "CallBackType": "Review",<br/>
   * "ContentId": "<The ContentId that was specified input>",<br/>
   * "Metadata": {<br/>
   * "adultscore": "0.xxx",<br/>
   * "a": "False",<br/>
   * "racyscore": "0.xxx",<br/>
   * "r": "True"<br/>
   * },<br/>
   * "ReviewerResultTags": {<br/>
   * "a": "False",<br/>
   * "r": "True"<br/>
   * }<br/>
   * }<br/>
   *
   * </p>.
   *
   * @param {string} contentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {array} createVideoReviewsBody Body for create reviews API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.subTeam] SubTeam of your team, you want to assign
   * the created review to.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createVideoReviews(contentType, teamName, createVideoReviewsBody, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createVideoReviews(contentType, teamName, createVideoReviewsBody, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createVideoReviews(contentType, teamName, createVideoReviewsBody, options, optionalCallback);
    }
  }

  /**
   * Use this method to add frames for a video review.Timescale: This parameter
   * is a factor which is used to convert the timestamp on a frame into
   * milliseconds. Timescale is provided in the output of the Content Moderator
   * video media processor on the Azure Media Services platform.Timescale in the
   * Video Moderation output is Ticks/Second.
   *
   * @param {string} contentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {array} videoFrameBody Body for add video frames API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timescale] Timescale of the video.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addVideoFrameUrlWithHttpOperationResponse(contentType, teamName, reviewId, videoFrameBody, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addVideoFrameUrl(contentType, teamName, reviewId, videoFrameBody, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Use this method to add frames for a video review.Timescale: This parameter
   * is a factor which is used to convert the timestamp on a frame into
   * milliseconds. Timescale is provided in the output of the Content Moderator
   * video media processor on the Azure Media Services platform.Timescale in the
   * Video Moderation output is Ticks/Second.
   *
   * @param {string} contentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {array} videoFrameBody Body for add video frames API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timescale] Timescale of the video.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addVideoFrameUrl(contentType, teamName, reviewId, videoFrameBody, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addVideoFrameUrl(contentType, teamName, reviewId, videoFrameBody, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addVideoFrameUrl(contentType, teamName, reviewId, videoFrameBody, options, optionalCallback);
    }
  }

  /**
   * Use this method to add frames for a video review.Timescale: This parameter
   * is a factor which is used to convert the timestamp on a frame into
   * milliseconds. Timescale is provided in the output of the Content Moderator
   * video media processor on the Azure Media Services platform.Timescale in the
   * Video Moderation output is Ticks/Second.
   *
   * @param {string} contentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} frameImageZip Zip file containing frame images.
   *
   * @param {string} frameMetadata Metadata of the frame.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timescale] Timescale of the video .
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addVideoFrameStreamWithHttpOperationResponse(contentType, teamName, reviewId, frameImageZip, frameMetadata, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addVideoFrameStream(contentType, teamName, reviewId, frameImageZip, frameMetadata, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Use this method to add frames for a video review.Timescale: This parameter
   * is a factor which is used to convert the timestamp on a frame into
   * milliseconds. Timescale is provided in the output of the Content Moderator
   * video media processor on the Azure Media Services platform.Timescale in the
   * Video Moderation output is Ticks/Second.
   *
   * @param {string} contentType The content type.
   *
   * @param {string} teamName Your team name.
   *
   * @param {string} reviewId Id of the review.
   *
   * @param {object} frameImageZip Zip file containing frame images.
   *
   * @param {string} frameMetadata Metadata of the frame.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timescale] Timescale of the video .
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addVideoFrameStream(contentType, teamName, reviewId, frameImageZip, frameMetadata, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addVideoFrameStream(contentType, teamName, reviewId, frameImageZip, frameMetadata, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addVideoFrameStream(contentType, teamName, reviewId, frameImageZip, frameMetadata, options, optionalCallback);
    }
  }

}

module.exports = Reviews;
