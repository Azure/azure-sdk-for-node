/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;

/**
 * Get the list of campaigns.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.skip] Control paging of campaigns, start results at
 * the given offset, defaults to 0 (1st page of data).
 *
 * @param {number} [options.top] Control paging of campaigns, number of
 * campaigns to return with each call. It returns all campaigns by default.
 * When specifying $top parameter, the response contains a `nextLink` property
 * describing the path to get the next page if there are more results.
 *
 * @param {string} [options.filter] Filter can be used to restrict the results
 * to campaigns matching a specific state. The syntax is `$filter=state eq
 * 'draft'`. Valid state values are: draft, scheduled, in-progress, and
 * finished. Only the eq operator and the state property are supported.
 *
 * @param {string} [options.orderby] Sort results by an expression which looks
 * like `$orderby=id asc` (this example is actually the default behavior). The
 * syntax is orderby={property} {direction} or just orderby={property}. The
 * available sorting properties are id, name, state, activatedDate, and
 * finishedDate. The available directions are asc (for ascending order) and
 * desc (for descending order). When not specified the asc direction is used.
 * Only one property at a time can be used for sorting.
 *
 * @param {string} [options.search] Restrict results to campaigns matching the
 * optional `search` expression. This currently performs the search based on
 * the name on the campaign only, case insensitive. If the campaign contains
 * the value of the `search` parameter anywhere in the name, it matches.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignsListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _list(resourceGroupName, appCollection, appName, kind, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let skip = (options && options.skip !== undefined) ? options.skip : undefined;
  let top = (options && options.top !== undefined) ? options.top : undefined;
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  let orderby = (options && options.orderby !== undefined) ? options.orderby : undefined;
  let search = (options && options.search !== undefined) ? options.search : undefined;
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (skip !== null && skip !== undefined && typeof skip !== 'number') {
      throw new Error('skip must be of type number.');
    }
    if (top !== null && top !== undefined && typeof top !== 'number') {
      throw new Error('top must be of type number.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (orderby !== null && orderby !== undefined && typeof orderby.valueOf() !== 'string') {
      throw new Error('orderby must be of type string.');
    }
    if (search !== null && search !== undefined && typeof search.valueOf() !== 'string') {
      throw new Error('search must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (skip !== null && skip !== undefined) {
    queryParameters.push('$skip=' + encodeURIComponent(skip.toString()));
  }
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (orderby !== null && orderby !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderby));
  }
  if (search !== null && search !== undefined) {
    queryParameters.push('$search=' + encodeURIComponent(search));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignsListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create a push campaign (announcement, poll, data push or native push).
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {object} parameters Parameters supplied to the Update Campaign
 * operation.
 *
 * @param {string} [parameters.name] Unique name of the campaign.
 *
 * @param {object} [parameters.audience] Specify which users will be targeted
 * by this campaign. By default, all users will be targeted. If you set
 * `pushMode` property to `manual`, the only thing you can specify in the
 * audience is the push quota filter. An audience is a boolean expression made
 * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
 * Additionally, a set of filters can be added to an audience. 65535 bytes max
 * as per JSON encoding.
 *
 *
 * @param {string} [parameters.audience.expression] Boolean expression made of
 * criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
 * Criterion names in the audience expression must start with a capital letter
 * and can only contain alphanumeric (A-Z,a-z,0-9) and underscore (_)
 * characters.
 *
 *
 * @param {object} [parameters.audience.criteria] Criteria by name.
 *
 * @param {array} [parameters.audience.filters] Global filters applied to all
 * devices.
 *
 * @param {string} [parameters.category] Category of the campaign. Categories
 * can be used on the application side to customize campaigns.
 *
 * @param {string} [parameters.pushMode] Announcements/polls only. Defines how
 * the campaign is pushed. Valid values are: * `real-time`: Never ending
 * campaign, the campaign will be delivered  to your existing users and also to
 * your new users. * `one-shot`: In this mode, the campaign will be delivered
 * only to your existing users (campaign will stop after that). * `manual`: In
 * this mode, the campaign will not be pushed automatically to devices. You
 * will have to use the Push campaign command to push the campaign to your
 * end-users. Campaigns can be pushed multiple times to the same device.
 * . Possible values include: 'real-time', 'one-shot', 'manual'
 *
 * @param {string} [parameters.type] Applicable only to announcements and data
 * pushes. Type of announcement. Valid values are: * `text/plain`: Text-only
 * announcement: `body` property should only contain plain text. * `text/html`:
 * HTML announcement: `body` attribute can contain HTML code. * `only_notif`:
 * Notification-only announcement. With this kind of announcements, the `body`,
 * `title`, `actionButtonText` and `exitButtonText` are ignored. Type of data
 * push. Valid values are: * `text/plain`: Text only data push: `body` property
 * must be plain text. * `text/base64`: Base 64 data push: `body` property must
 * be encoded in base 64.
 * . Possible values include: 'text/plain', 'text/html', 'only_notif',
 * 'text/base64'
 *
 * @param {string} [parameters.deliveryTime] Announcements/polls only. Defines
 * when the campaign should be delivered. Valid values are: * `any`: Campaign
 * will be delivered as soon as possible. * `background`: iOS only. Campaign
 * will be only delivered when the application is in background (out of app). *
 * `session`: Campaign will be delivered when the application is running.
 * . Possible values include: 'any', 'background', 'session'
 *
 * @param {array} [parameters.deliveryActivities] Announcements/polls only.
 * Array containing the list of activities in which the campaign can be
 * delivered. deliveryTime must be set to session. If the platform is iOS, this
 * option can also be set if deliveryTime is set to any. In that case, if the
 * campaign is received when the application is launched, it will be delivered
 * only in the specified list of activities.
 *
 *
 * @param {string} [parameters.startTime] The date at which the campaign should
 * be started. The date shall conform to the following format:
 * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
 * attribute will be ignored. * If you set pushMode property to one-shot, then
 * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
 *
 *
 * @param {string} [parameters.endTime] The date at which the campaign should
 * be finished. The date shall conform to the following format:
 * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
 *
 *
 * @param {string} [parameters.timezone] The id of the time zone to use for the
 * startTime and endTime dates. If not provided, the two date attributes will
 * be expressed using the device timezone. Example: America/Los_Angeles
 *
 *
 * @param {string} [parameters.notificationType] Android only. Defines how the
 * notification should be displayed. Valid values are: * `system`: Display the
 * notification using a standard system notification. * `popup`: Display the
 * notification using a in-app banner notification.
 * . Possible values include: 'system', 'popup'
 *
 * @param {boolean} [parameters.notificationIcon] A flag indicating whether or
 * not you want to display the resource icon in notification content.
 *
 * @param {boolean} [parameters.notificationCloseable] A flag indicating
 * whether or not you want the notification to be closeable.
 *
 * @param {boolean} [parameters.notificationVibrate] Android only. A flag
 * indicating whether or not you want the system notification to make a
 * vibration. The notificationType property must be set to system.
 *
 * @param {boolean} [parameters.notificationSound] * `Android`: A flag
 * indicating whether or not you want the system notification to make a sound.
 * The `notificationType` property must be set to `system`. * `iOS`: A flag
 * indicating whether or not you want the native Apple Push notification to
 * make a sound. The `deliveryTime` property must be set to `any` or
 * `background`. This will play the 'default' sound. If you want to play a
 * custom sound, see the `notificationOptions` property. * `Windows`: A flag
 * indicating whether or not you want the native Windows Notification Service
 * to make a sound. The `deliveryTime` property must be set to `any`.
 *
 *
 * @param {boolean} [parameters.notificationBadge] A flag indicating whether or
 * not you want the native Apple Push notification to update the badge icon to
 * the number of unread messages. The `deliveryTime` property must be set to
 * `any` or `background`.
 *
 *
 * @param {object} [parameters.localization] Push campaigns can be localized
 * using an optional JSON object. The JSON key is a two-character language code
 * as specified by the ISO 639-1 standard. The corresponding value is an object
 * containing the localizable properties.
 *
 *
 * @param {array} [parameters.questions] Poll questions.
 *
 * @param {string} [parameters.notificationTitle] Title of the notification.
 * This field supports appInfo markers.
 *
 * @param {string} [parameters.notificationMessage] Message of the
 * notification. This field supports appInfo markers.
 *
 * @param {buffer} [parameters.notificationImage] Optional image encoded in
 * base 64. Usually included in the right part of in app notifications (or as a
 * banner if there is neither text nor content icon). For Android system
 * notifications, the image is used as the large icon (displayed only on
 * Android 3+).
 *
 *
 * @param {object} [parameters.notificationOptions] Additional platform
 * specific options.
 *
 * @param {string} [parameters.notificationOptions.bigText] Android 4.1+ only.
 * Multi line message shown in expanded notifications on Android 4.1+ devices.
 * The `notificationType` property must be set to `system`.
 *
 *
 * @param {string} [parameters.notificationOptions.bigPicture] URL of a remote
 * image displayed in expanded notifications on
 * Android 4.1+ devices with the following constraints:
 * * The URL length is limited to 2000 characters.
 * * The image size must be less than 4 MiB.
 * * The following MIME types are supported:
 * ** image/png
 * ** image/jpeg
 * ** image/gif
 * ** image/webp
 * ** image/bmp
 * ** image/x-bmp
 * ** image/x-ms-bmp
 * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
 * * Incompatible with `bigText`, only one of the fields can be set.
 * * The `notificationType` property must be set to `system`.
 *
 *
 * @param {string} [parameters.notificationOptions.sound] iOS only. The name of
 * a sound file in the application bundle. The sound in this file is played as
 * an alert. If the sound file doesn’t exist or default is specified as the
 * value, the default alert sound is played. The audio must be in one of the
 * audio data formats that are compatible with system sounds. The
 * `deliveryTime` property must be set to `any` or `background`.
 *
 *
 * @param {string} [parameters.notificationOptions.actionText] The action text
 * is the title of the right button of the alert or the value of the unlock
 * slider, where the value replaces 'unlock' in 'slide to unlock'. 'View'
 * (localized to the preferred language) is used as the default value. The
 * `deliveryTime` property must be set to `any` or `background`.
 *
 *
 * @param {string} [parameters.title] Title of the announcement or poll. This
 * field supports appInfo markers.
 *
 * @param {string} [parameters.body] Body of the text/web announcement, poll or
 * data push. This field supports appInfo markers.
 *
 * @param {string} [parameters.actionButtonText] Text of the action button for
 * text/web announcements and polls (answer button).
 *
 * @param {string} [parameters.exitButtonText] Text of the exit button for
 * text/web announcements and polls.
 *
 * @param {string} [parameters.actionUrl] URL to launch when the announcement
 * is actioned.
 *
 * @param {object} [parameters.payload] Native push payload.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignStateResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _create(resourceGroupName, appCollection, appName, kind, parameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (parameters === null || parameters === undefined) {
      throw new Error('parameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['Campaign']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignStateResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * The Get campaign operation retrieves information about a previously created
 * campaign.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {number} id Campaign identifier.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _get(kind, id, resourceGroupName, appCollection, appName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/{id}';
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Update an existing push campaign (announcement, poll, data push or native
 * push).
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {number} id Campaign identifier.
 *
 * @param {object} parameters Parameters supplied to the Update Campaign
 * operation.
 *
 * @param {string} [parameters.name] Unique name of the campaign.
 *
 * @param {object} [parameters.audience] Specify which users will be targeted
 * by this campaign. By default, all users will be targeted. If you set
 * `pushMode` property to `manual`, the only thing you can specify in the
 * audience is the push quota filter. An audience is a boolean expression made
 * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
 * Additionally, a set of filters can be added to an audience. 65535 bytes max
 * as per JSON encoding.
 *
 *
 * @param {string} [parameters.audience.expression] Boolean expression made of
 * criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
 * Criterion names in the audience expression must start with a capital letter
 * and can only contain alphanumeric (A-Z,a-z,0-9) and underscore (_)
 * characters.
 *
 *
 * @param {object} [parameters.audience.criteria] Criteria by name.
 *
 * @param {array} [parameters.audience.filters] Global filters applied to all
 * devices.
 *
 * @param {string} [parameters.category] Category of the campaign. Categories
 * can be used on the application side to customize campaigns.
 *
 * @param {string} [parameters.pushMode] Announcements/polls only. Defines how
 * the campaign is pushed. Valid values are: * `real-time`: Never ending
 * campaign, the campaign will be delivered  to your existing users and also to
 * your new users. * `one-shot`: In this mode, the campaign will be delivered
 * only to your existing users (campaign will stop after that). * `manual`: In
 * this mode, the campaign will not be pushed automatically to devices. You
 * will have to use the Push campaign command to push the campaign to your
 * end-users. Campaigns can be pushed multiple times to the same device.
 * . Possible values include: 'real-time', 'one-shot', 'manual'
 *
 * @param {string} [parameters.type] Applicable only to announcements and data
 * pushes. Type of announcement. Valid values are: * `text/plain`: Text-only
 * announcement: `body` property should only contain plain text. * `text/html`:
 * HTML announcement: `body` attribute can contain HTML code. * `only_notif`:
 * Notification-only announcement. With this kind of announcements, the `body`,
 * `title`, `actionButtonText` and `exitButtonText` are ignored. Type of data
 * push. Valid values are: * `text/plain`: Text only data push: `body` property
 * must be plain text. * `text/base64`: Base 64 data push: `body` property must
 * be encoded in base 64.
 * . Possible values include: 'text/plain', 'text/html', 'only_notif',
 * 'text/base64'
 *
 * @param {string} [parameters.deliveryTime] Announcements/polls only. Defines
 * when the campaign should be delivered. Valid values are: * `any`: Campaign
 * will be delivered as soon as possible. * `background`: iOS only. Campaign
 * will be only delivered when the application is in background (out of app). *
 * `session`: Campaign will be delivered when the application is running.
 * . Possible values include: 'any', 'background', 'session'
 *
 * @param {array} [parameters.deliveryActivities] Announcements/polls only.
 * Array containing the list of activities in which the campaign can be
 * delivered. deliveryTime must be set to session. If the platform is iOS, this
 * option can also be set if deliveryTime is set to any. In that case, if the
 * campaign is received when the application is launched, it will be delivered
 * only in the specified list of activities.
 *
 *
 * @param {string} [parameters.startTime] The date at which the campaign should
 * be started. The date shall conform to the following format:
 * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
 * attribute will be ignored. * If you set pushMode property to one-shot, then
 * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
 *
 *
 * @param {string} [parameters.endTime] The date at which the campaign should
 * be finished. The date shall conform to the following format:
 * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
 *
 *
 * @param {string} [parameters.timezone] The id of the time zone to use for the
 * startTime and endTime dates. If not provided, the two date attributes will
 * be expressed using the device timezone. Example: America/Los_Angeles
 *
 *
 * @param {string} [parameters.notificationType] Android only. Defines how the
 * notification should be displayed. Valid values are: * `system`: Display the
 * notification using a standard system notification. * `popup`: Display the
 * notification using a in-app banner notification.
 * . Possible values include: 'system', 'popup'
 *
 * @param {boolean} [parameters.notificationIcon] A flag indicating whether or
 * not you want to display the resource icon in notification content.
 *
 * @param {boolean} [parameters.notificationCloseable] A flag indicating
 * whether or not you want the notification to be closeable.
 *
 * @param {boolean} [parameters.notificationVibrate] Android only. A flag
 * indicating whether or not you want the system notification to make a
 * vibration. The notificationType property must be set to system.
 *
 * @param {boolean} [parameters.notificationSound] * `Android`: A flag
 * indicating whether or not you want the system notification to make a sound.
 * The `notificationType` property must be set to `system`. * `iOS`: A flag
 * indicating whether or not you want the native Apple Push notification to
 * make a sound. The `deliveryTime` property must be set to `any` or
 * `background`. This will play the 'default' sound. If you want to play a
 * custom sound, see the `notificationOptions` property. * `Windows`: A flag
 * indicating whether or not you want the native Windows Notification Service
 * to make a sound. The `deliveryTime` property must be set to `any`.
 *
 *
 * @param {boolean} [parameters.notificationBadge] A flag indicating whether or
 * not you want the native Apple Push notification to update the badge icon to
 * the number of unread messages. The `deliveryTime` property must be set to
 * `any` or `background`.
 *
 *
 * @param {object} [parameters.localization] Push campaigns can be localized
 * using an optional JSON object. The JSON key is a two-character language code
 * as specified by the ISO 639-1 standard. The corresponding value is an object
 * containing the localizable properties.
 *
 *
 * @param {array} [parameters.questions] Poll questions.
 *
 * @param {string} [parameters.notificationTitle] Title of the notification.
 * This field supports appInfo markers.
 *
 * @param {string} [parameters.notificationMessage] Message of the
 * notification. This field supports appInfo markers.
 *
 * @param {buffer} [parameters.notificationImage] Optional image encoded in
 * base 64. Usually included in the right part of in app notifications (or as a
 * banner if there is neither text nor content icon). For Android system
 * notifications, the image is used as the large icon (displayed only on
 * Android 3+).
 *
 *
 * @param {object} [parameters.notificationOptions] Additional platform
 * specific options.
 *
 * @param {string} [parameters.notificationOptions.bigText] Android 4.1+ only.
 * Multi line message shown in expanded notifications on Android 4.1+ devices.
 * The `notificationType` property must be set to `system`.
 *
 *
 * @param {string} [parameters.notificationOptions.bigPicture] URL of a remote
 * image displayed in expanded notifications on
 * Android 4.1+ devices with the following constraints:
 * * The URL length is limited to 2000 characters.
 * * The image size must be less than 4 MiB.
 * * The following MIME types are supported:
 * ** image/png
 * ** image/jpeg
 * ** image/gif
 * ** image/webp
 * ** image/bmp
 * ** image/x-bmp
 * ** image/x-ms-bmp
 * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
 * * Incompatible with `bigText`, only one of the fields can be set.
 * * The `notificationType` property must be set to `system`.
 *
 *
 * @param {string} [parameters.notificationOptions.sound] iOS only. The name of
 * a sound file in the application bundle. The sound in this file is played as
 * an alert. If the sound file doesn’t exist or default is specified as the
 * value, the default alert sound is played. The audio must be in one of the
 * audio data formats that are compatible with system sounds. The
 * `deliveryTime` property must be set to `any` or `background`.
 *
 *
 * @param {string} [parameters.notificationOptions.actionText] The action text
 * is the title of the right button of the alert or the value of the unlock
 * slider, where the value replaces 'unlock' in 'slide to unlock'. 'View'
 * (localized to the preferred language) is used as the default value. The
 * `deliveryTime` property must be set to `any` or `background`.
 *
 *
 * @param {string} [parameters.title] Title of the announcement or poll. This
 * field supports appInfo markers.
 *
 * @param {string} [parameters.body] Body of the text/web announcement, poll or
 * data push. This field supports appInfo markers.
 *
 * @param {string} [parameters.actionButtonText] Text of the action button for
 * text/web announcements and polls (answer button).
 *
 * @param {string} [parameters.exitButtonText] Text of the exit button for
 * text/web announcements and polls.
 *
 * @param {string} [parameters.actionUrl] URL to launch when the announcement
 * is actioned.
 *
 * @param {object} [parameters.payload] Native push payload.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignStateResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _update(kind, id, parameters, resourceGroupName, appCollection, appName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (parameters === null || parameters === undefined) {
      throw new Error('parameters cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/{id}';
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['Campaign']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignStateResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Delete a campaign previously created by a call to Create campaign.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {number} id Campaign identifier.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMethod(kind, id, resourceGroupName, appCollection, appName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/{id}';
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * The Get campaign operation retrieves information about a previously created
 * campaign.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {string} name Campaign name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getByName(resourceGroupName, appCollection, appName, kind, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaignsByName/{kind}/{name}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Test an existing campaign (created with Create campaign) on a set of
 * devices.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {number} id Campaign identifier.
 *
 * @param {object} parameters Parameters supplied to the Test Campaign
 * operation.
 *
 * @param {string} parameters.deviceId Device identifier (as returned by the
 * SDK).
 *
 * @param {string} [parameters.lang] The language to test expressed using ISO
 * 639-1 code. The default language of the campaign will be used if the
 * parameter is not provided.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignStateResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _testSaved(resourceGroupName, appCollection, appName, kind, id, parameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (parameters === null || parameters === undefined) {
      throw new Error('parameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/{id}/test';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['CampaignTestSavedParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignStateResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Test a new campaign on a set of devices.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {object} parameters Parameters supplied to the Test Campaign
 * operation.
 *
 * @param {object} parameters.data
 *
 * @param {string} [parameters.data.name] Unique name of the campaign.
 *
 * @param {object} [parameters.data.audience] Specify which users will be
 * targeted by this campaign. By default, all users will be targeted. If you
 * set `pushMode` property to `manual`, the only thing you can specify in the
 * audience is the push quota filter. An audience is a boolean expression made
 * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
 * Additionally, a set of filters can be added to an audience. 65535 bytes max
 * as per JSON encoding.
 *
 *
 * @param {string} [parameters.data.audience.expression] Boolean expression
 * made of criteria (variables) operators (`not`, `and` or `or`) and
 * parenthesis. Criterion names in the audience expression must start with a
 * capital letter and can only contain alphanumeric (A-Z,a-z,0-9) and
 * underscore (_) characters.
 *
 *
 * @param {object} [parameters.data.audience.criteria] Criteria by name.
 *
 * @param {array} [parameters.data.audience.filters] Global filters applied to
 * all devices.
 *
 * @param {string} [parameters.data.category] Category of the campaign.
 * Categories can be used on the application side to customize campaigns.
 *
 * @param {string} [parameters.data.pushMode] Announcements/polls only. Defines
 * how the campaign is pushed. Valid values are: * `real-time`: Never ending
 * campaign, the campaign will be delivered  to your existing users and also to
 * your new users. * `one-shot`: In this mode, the campaign will be delivered
 * only to your existing users (campaign will stop after that). * `manual`: In
 * this mode, the campaign will not be pushed automatically to devices. You
 * will have to use the Push campaign command to push the campaign to your
 * end-users. Campaigns can be pushed multiple times to the same device.
 * . Possible values include: 'real-time', 'one-shot', 'manual'
 *
 * @param {string} [parameters.data.type] Applicable only to announcements and
 * data pushes. Type of announcement. Valid values are: * `text/plain`:
 * Text-only announcement: `body` property should only contain plain text. *
 * `text/html`: HTML announcement: `body` attribute can contain HTML code. *
 * `only_notif`: Notification-only announcement. With this kind of
 * announcements, the `body`, `title`, `actionButtonText` and `exitButtonText`
 * are ignored. Type of data push. Valid values are: * `text/plain`: Text only
 * data push: `body` property must be plain text. * `text/base64`: Base 64 data
 * push: `body` property must be encoded in base 64.
 * . Possible values include: 'text/plain', 'text/html', 'only_notif',
 * 'text/base64'
 *
 * @param {string} [parameters.data.deliveryTime] Announcements/polls only.
 * Defines when the campaign should be delivered. Valid values are: * `any`:
 * Campaign will be delivered as soon as possible. * `background`: iOS only.
 * Campaign will be only delivered when the application is in background (out
 * of app). * `session`: Campaign will be delivered when the application is
 * running.
 * . Possible values include: 'any', 'background', 'session'
 *
 * @param {array} [parameters.data.deliveryActivities] Announcements/polls
 * only. Array containing the list of activities in which the campaign can be
 * delivered. deliveryTime must be set to session. If the platform is iOS, this
 * option can also be set if deliveryTime is set to any. In that case, if the
 * campaign is received when the application is launched, it will be delivered
 * only in the specified list of activities.
 *
 *
 * @param {string} [parameters.data.startTime] The date at which the campaign
 * should be started. The date shall conform to the following format:
 * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
 * attribute will be ignored. * If you set pushMode property to one-shot, then
 * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
 *
 *
 * @param {string} [parameters.data.endTime] The date at which the campaign
 * should be finished. The date shall conform to the following format:
 * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
 *
 *
 * @param {string} [parameters.data.timezone] The id of the time zone to use
 * for the startTime and endTime dates. If not provided, the two date
 * attributes will be expressed using the device timezone. Example:
 * America/Los_Angeles
 *
 *
 * @param {string} [parameters.data.notificationType] Android only. Defines how
 * the notification should be displayed. Valid values are: * `system`: Display
 * the notification using a standard system notification. * `popup`: Display
 * the notification using a in-app banner notification.
 * . Possible values include: 'system', 'popup'
 *
 * @param {boolean} [parameters.data.notificationIcon] A flag indicating
 * whether or not you want to display the resource icon in notification
 * content.
 *
 * @param {boolean} [parameters.data.notificationCloseable] A flag indicating
 * whether or not you want the notification to be closeable.
 *
 * @param {boolean} [parameters.data.notificationVibrate] Android only. A flag
 * indicating whether or not you want the system notification to make a
 * vibration. The notificationType property must be set to system.
 *
 * @param {boolean} [parameters.data.notificationSound] * `Android`: A flag
 * indicating whether or not you want the system notification to make a sound.
 * The `notificationType` property must be set to `system`. * `iOS`: A flag
 * indicating whether or not you want the native Apple Push notification to
 * make a sound. The `deliveryTime` property must be set to `any` or
 * `background`. This will play the 'default' sound. If you want to play a
 * custom sound, see the `notificationOptions` property. * `Windows`: A flag
 * indicating whether or not you want the native Windows Notification Service
 * to make a sound. The `deliveryTime` property must be set to `any`.
 *
 *
 * @param {boolean} [parameters.data.notificationBadge] A flag indicating
 * whether or not you want the native Apple Push notification to update the
 * badge icon to the number of unread messages. The `deliveryTime` property
 * must be set to `any` or `background`.
 *
 *
 * @param {object} [parameters.data.localization] Push campaigns can be
 * localized using an optional JSON object. The JSON key is a two-character
 * language code as specified by the ISO 639-1 standard. The corresponding
 * value is an object containing the localizable properties.
 *
 *
 * @param {array} [parameters.data.questions] Poll questions.
 *
 * @param {string} [parameters.data.notificationTitle] Title of the
 * notification. This field supports appInfo markers.
 *
 * @param {string} [parameters.data.notificationMessage] Message of the
 * notification. This field supports appInfo markers.
 *
 * @param {buffer} [parameters.data.notificationImage] Optional image encoded
 * in base 64. Usually included in the right part of in app notifications (or
 * as a banner if there is neither text nor content icon). For Android system
 * notifications, the image is used as the large icon (displayed only on
 * Android 3+).
 *
 *
 * @param {object} [parameters.data.notificationOptions] Additional platform
 * specific options.
 *
 * @param {string} [parameters.data.notificationOptions.bigText] Android 4.1+
 * only. Multi line message shown in expanded notifications on Android 4.1+
 * devices. The `notificationType` property must be set to `system`.
 *
 *
 * @param {string} [parameters.data.notificationOptions.bigPicture] URL of a
 * remote image displayed in expanded notifications on
 * Android 4.1+ devices with the following constraints:
 * * The URL length is limited to 2000 characters.
 * * The image size must be less than 4 MiB.
 * * The following MIME types are supported:
 * ** image/png
 * ** image/jpeg
 * ** image/gif
 * ** image/webp
 * ** image/bmp
 * ** image/x-bmp
 * ** image/x-ms-bmp
 * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
 * * Incompatible with `bigText`, only one of the fields can be set.
 * * The `notificationType` property must be set to `system`.
 *
 *
 * @param {string} [parameters.data.notificationOptions.sound] iOS only. The
 * name of a sound file in the application bundle. The sound in this file is
 * played as an alert. If the sound file doesn’t exist or default is specified
 * as the value, the default alert sound is played. The audio must be in one of
 * the audio data formats that are compatible with system sounds. The
 * `deliveryTime` property must be set to `any` or `background`.
 *
 *
 * @param {string} [parameters.data.notificationOptions.actionText] The action
 * text is the title of the right button of the alert or the value of the
 * unlock slider, where the value replaces 'unlock' in 'slide to unlock'.
 * 'View' (localized to the preferred language) is used as the default value.
 * The `deliveryTime` property must be set to `any` or `background`.
 *
 *
 * @param {string} [parameters.data.title] Title of the announcement or poll.
 * This field supports appInfo markers.
 *
 * @param {string} [parameters.data.body] Body of the text/web announcement,
 * poll or data push. This field supports appInfo markers.
 *
 * @param {string} [parameters.data.actionButtonText] Text of the action button
 * for text/web announcements and polls (answer button).
 *
 * @param {string} [parameters.data.exitButtonText] Text of the exit button for
 * text/web announcements and polls.
 *
 * @param {string} [parameters.data.actionUrl] URL to launch when the
 * announcement is actioned.
 *
 * @param {object} [parameters.data.payload] Native push payload.
 *
 * @param {string} parameters.deviceId Device identifier (as returned by the
 * SDK).
 *
 * @param {string} [parameters.lang] The language to test expressed using ISO
 * 639-1 code. The default language of the campaign will be used if the
 * parameter is not provided.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignState} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _testNew(resourceGroupName, appCollection, appName, kind, parameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (parameters === null || parameters === undefined) {
      throw new Error('parameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/test';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['CampaignTestNewParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignState']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Activate a campaign previously created by a call to Create campaign.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {number} id Campaign identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignStateResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _activate(resourceGroupName, appCollection, appName, kind, id, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/{id}/activate';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignStateResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Suspend a push campaign previously activated by a call to Activate campaign.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {number} id Campaign identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignStateResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _suspend(resourceGroupName, appCollection, appName, kind, id, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/{id}/suspend';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignStateResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Push a previously saved campaign (created with Create campaign) to a set of
 * devices.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {number} id Campaign identifier.
 *
 * @param {object} parameters Parameters supplied to the Push Campaign
 * operation.
 *
 * @param {array} parameters.deviceIds Device identifiers to push as a JSON
 * array of strings. Note that if you want to push the same campaign several
 * times to the same device, you need to make several API calls.
 *
 *
 * @param {object} [parameters.data] Alternative campaign's content to use
 * instead of the referenced campaign. All campaign's properties can be
 * overridden except for the following: `name`, `manualPush`, `audience`,
 * `startTime` and `timezone`. `endTime` can be overridden while keeping
 * original `timezone` parameter. The effect is to change the client side
 * expiration of the received campaign for the specific devices. If your
 * campaign is a *poll*, the provided data should contain the same number of
 * questions and choices that the one you created with the create command.
 * Please note that all the push messages created using this parameter will
 * expire after 4 weeks at maximum (`endTime` property of the campaign will be
 * used if lower than 4 weeks in the future).
 *
 * @param {string} [parameters.data.name] Unique name of the campaign.
 *
 * @param {object} [parameters.data.audience] Specify which users will be
 * targeted by this campaign. By default, all users will be targeted. If you
 * set `pushMode` property to `manual`, the only thing you can specify in the
 * audience is the push quota filter. An audience is a boolean expression made
 * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
 * Additionally, a set of filters can be added to an audience. 65535 bytes max
 * as per JSON encoding.
 *
 *
 * @param {string} [parameters.data.audience.expression] Boolean expression
 * made of criteria (variables) operators (`not`, `and` or `or`) and
 * parenthesis. Criterion names in the audience expression must start with a
 * capital letter and can only contain alphanumeric (A-Z,a-z,0-9) and
 * underscore (_) characters.
 *
 *
 * @param {object} [parameters.data.audience.criteria] Criteria by name.
 *
 * @param {array} [parameters.data.audience.filters] Global filters applied to
 * all devices.
 *
 * @param {string} [parameters.data.category] Category of the campaign.
 * Categories can be used on the application side to customize campaigns.
 *
 * @param {string} [parameters.data.pushMode] Announcements/polls only. Defines
 * how the campaign is pushed. Valid values are: * `real-time`: Never ending
 * campaign, the campaign will be delivered  to your existing users and also to
 * your new users. * `one-shot`: In this mode, the campaign will be delivered
 * only to your existing users (campaign will stop after that). * `manual`: In
 * this mode, the campaign will not be pushed automatically to devices. You
 * will have to use the Push campaign command to push the campaign to your
 * end-users. Campaigns can be pushed multiple times to the same device.
 * . Possible values include: 'real-time', 'one-shot', 'manual'
 *
 * @param {string} [parameters.data.type] Applicable only to announcements and
 * data pushes. Type of announcement. Valid values are: * `text/plain`:
 * Text-only announcement: `body` property should only contain plain text. *
 * `text/html`: HTML announcement: `body` attribute can contain HTML code. *
 * `only_notif`: Notification-only announcement. With this kind of
 * announcements, the `body`, `title`, `actionButtonText` and `exitButtonText`
 * are ignored. Type of data push. Valid values are: * `text/plain`: Text only
 * data push: `body` property must be plain text. * `text/base64`: Base 64 data
 * push: `body` property must be encoded in base 64.
 * . Possible values include: 'text/plain', 'text/html', 'only_notif',
 * 'text/base64'
 *
 * @param {string} [parameters.data.deliveryTime] Announcements/polls only.
 * Defines when the campaign should be delivered. Valid values are: * `any`:
 * Campaign will be delivered as soon as possible. * `background`: iOS only.
 * Campaign will be only delivered when the application is in background (out
 * of app). * `session`: Campaign will be delivered when the application is
 * running.
 * . Possible values include: 'any', 'background', 'session'
 *
 * @param {array} [parameters.data.deliveryActivities] Announcements/polls
 * only. Array containing the list of activities in which the campaign can be
 * delivered. deliveryTime must be set to session. If the platform is iOS, this
 * option can also be set if deliveryTime is set to any. In that case, if the
 * campaign is received when the application is launched, it will be delivered
 * only in the specified list of activities.
 *
 *
 * @param {string} [parameters.data.startTime] The date at which the campaign
 * should be started. The date shall conform to the following format:
 * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
 * attribute will be ignored. * If you set pushMode property to one-shot, then
 * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
 *
 *
 * @param {string} [parameters.data.endTime] The date at which the campaign
 * should be finished. The date shall conform to the following format:
 * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
 *
 *
 * @param {string} [parameters.data.timezone] The id of the time zone to use
 * for the startTime and endTime dates. If not provided, the two date
 * attributes will be expressed using the device timezone. Example:
 * America/Los_Angeles
 *
 *
 * @param {string} [parameters.data.notificationType] Android only. Defines how
 * the notification should be displayed. Valid values are: * `system`: Display
 * the notification using a standard system notification. * `popup`: Display
 * the notification using a in-app banner notification.
 * . Possible values include: 'system', 'popup'
 *
 * @param {boolean} [parameters.data.notificationIcon] A flag indicating
 * whether or not you want to display the resource icon in notification
 * content.
 *
 * @param {boolean} [parameters.data.notificationCloseable] A flag indicating
 * whether or not you want the notification to be closeable.
 *
 * @param {boolean} [parameters.data.notificationVibrate] Android only. A flag
 * indicating whether or not you want the system notification to make a
 * vibration. The notificationType property must be set to system.
 *
 * @param {boolean} [parameters.data.notificationSound] * `Android`: A flag
 * indicating whether or not you want the system notification to make a sound.
 * The `notificationType` property must be set to `system`. * `iOS`: A flag
 * indicating whether or not you want the native Apple Push notification to
 * make a sound. The `deliveryTime` property must be set to `any` or
 * `background`. This will play the 'default' sound. If you want to play a
 * custom sound, see the `notificationOptions` property. * `Windows`: A flag
 * indicating whether or not you want the native Windows Notification Service
 * to make a sound. The `deliveryTime` property must be set to `any`.
 *
 *
 * @param {boolean} [parameters.data.notificationBadge] A flag indicating
 * whether or not you want the native Apple Push notification to update the
 * badge icon to the number of unread messages. The `deliveryTime` property
 * must be set to `any` or `background`.
 *
 *
 * @param {object} [parameters.data.localization] Push campaigns can be
 * localized using an optional JSON object. The JSON key is a two-character
 * language code as specified by the ISO 639-1 standard. The corresponding
 * value is an object containing the localizable properties.
 *
 *
 * @param {array} [parameters.data.questions] Poll questions.
 *
 * @param {string} [parameters.data.notificationTitle] Title of the
 * notification. This field supports appInfo markers.
 *
 * @param {string} [parameters.data.notificationMessage] Message of the
 * notification. This field supports appInfo markers.
 *
 * @param {buffer} [parameters.data.notificationImage] Optional image encoded
 * in base 64. Usually included in the right part of in app notifications (or
 * as a banner if there is neither text nor content icon). For Android system
 * notifications, the image is used as the large icon (displayed only on
 * Android 3+).
 *
 *
 * @param {object} [parameters.data.notificationOptions] Additional platform
 * specific options.
 *
 * @param {string} [parameters.data.notificationOptions.bigText] Android 4.1+
 * only. Multi line message shown in expanded notifications on Android 4.1+
 * devices. The `notificationType` property must be set to `system`.
 *
 *
 * @param {string} [parameters.data.notificationOptions.bigPicture] URL of a
 * remote image displayed in expanded notifications on
 * Android 4.1+ devices with the following constraints:
 * * The URL length is limited to 2000 characters.
 * * The image size must be less than 4 MiB.
 * * The following MIME types are supported:
 * ** image/png
 * ** image/jpeg
 * ** image/gif
 * ** image/webp
 * ** image/bmp
 * ** image/x-bmp
 * ** image/x-ms-bmp
 * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
 * * Incompatible with `bigText`, only one of the fields can be set.
 * * The `notificationType` property must be set to `system`.
 *
 *
 * @param {string} [parameters.data.notificationOptions.sound] iOS only. The
 * name of a sound file in the application bundle. The sound in this file is
 * played as an alert. If the sound file doesn’t exist or default is specified
 * as the value, the default alert sound is played. The audio must be in one of
 * the audio data formats that are compatible with system sounds. The
 * `deliveryTime` property must be set to `any` or `background`.
 *
 *
 * @param {string} [parameters.data.notificationOptions.actionText] The action
 * text is the title of the right button of the alert or the value of the
 * unlock slider, where the value replaces 'unlock' in 'slide to unlock'.
 * 'View' (localized to the preferred language) is used as the default value.
 * The `deliveryTime` property must be set to `any` or `background`.
 *
 *
 * @param {string} [parameters.data.title] Title of the announcement or poll.
 * This field supports appInfo markers.
 *
 * @param {string} [parameters.data.body] Body of the text/web announcement,
 * poll or data push. This field supports appInfo markers.
 *
 * @param {string} [parameters.data.actionButtonText] Text of the action button
 * for text/web announcements and polls (answer button).
 *
 * @param {string} [parameters.data.exitButtonText] Text of the exit button for
 * text/web announcements and polls.
 *
 * @param {string} [parameters.data.actionUrl] URL to launch when the
 * announcement is actioned.
 *
 * @param {object} [parameters.data.payload] Native push payload.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignPushResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _push(resourceGroupName, appCollection, appName, kind, id, parameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (parameters === null || parameters === undefined) {
      throw new Error('parameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/{id}/push';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (parameters !== null && parameters !== undefined) {
      let requestModelMapper = new client.models['CampaignPushParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, parameters, 'parameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(parameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignPushResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Get all the campaign statistics.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {number} id Campaign identifier.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignStatisticsResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getStatistics(kind, id, resourceGroupName, appCollection, appName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/{id}/statistics';
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignStatisticsResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Finish a push campaign previously activated by a call to Activate campaign.
 *
 * @param {string} resourceGroupName The name of the resource group.
 *
 * @param {string} appCollection Application collection.
 *
 * @param {string} appName Application resource name.
 *
 * @param {string} kind Campaign kind. Possible values include:
 * 'announcements', 'polls', 'dataPushes', 'nativePushes'
 *
 * @param {number} id Campaign identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignStateResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _finish(resourceGroupName, appCollection, appName, kind, id, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (appCollection === null || appCollection === undefined || typeof appCollection.valueOf() !== 'string') {
      throw new Error('appCollection cannot be null or undefined and it must be of type string.');
    }
    if (appName === null || appName === undefined || typeof appName.valueOf() !== 'string') {
      throw new Error('appName cannot be null or undefined and it must be of type string.');
    }
    if (kind === null || kind === undefined || typeof kind.valueOf() !== 'string') {
      throw new Error('kind cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileEngagement/appcollections/{appCollection}/apps/{appName}/campaigns/{kind}/{id}/finish';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{appCollection}', encodeURIComponent(appCollection));
  requestUrl = requestUrl.replace('{appName}', encodeURIComponent(appName));
  requestUrl = requestUrl.replace('{kind}', encodeURIComponent(kind));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignStateResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Get the list of campaigns.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CampaignsListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CampaignsListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a Campaigns. */
class Campaigns {
  /**
   * Create a Campaigns.
   * @param {MobileEngagementClient} client Reference to the service client.
   */
  constructor(client) {
    this.client = client;
    this._list = _list;
    this._create = _create;
    this._get = _get;
    this._update = _update;
    this._deleteMethod = _deleteMethod;
    this._getByName = _getByName;
    this._testSaved = _testSaved;
    this._testNew = _testNew;
    this._activate = _activate;
    this._suspend = _suspend;
    this._push = _push;
    this._getStatistics = _getStatistics;
    this._finish = _finish;
    this._listNext = _listNext;
  }

  /**
   * Get the list of campaigns.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.skip] Control paging of campaigns, start results at
   * the given offset, defaults to 0 (1st page of data).
   *
   * @param {number} [options.top] Control paging of campaigns, number of
   * campaigns to return with each call. It returns all campaigns by default.
   * When specifying $top parameter, the response contains a `nextLink` property
   * describing the path to get the next page if there are more results.
   *
   * @param {string} [options.filter] Filter can be used to restrict the results
   * to campaigns matching a specific state. The syntax is `$filter=state eq
   * 'draft'`. Valid state values are: draft, scheduled, in-progress, and
   * finished. Only the eq operator and the state property are supported.
   *
   * @param {string} [options.orderby] Sort results by an expression which looks
   * like `$orderby=id asc` (this example is actually the default behavior). The
   * syntax is orderby={property} {direction} or just orderby={property}. The
   * available sorting properties are id, name, state, activatedDate, and
   * finishedDate. The available directions are asc (for ascending order) and
   * desc (for descending order). When not specified the asc direction is used.
   * Only one property at a time can be used for sorting.
   *
   * @param {string} [options.search] Restrict results to campaigns matching the
   * optional `search` expression. This currently performs the search based on
   * the name on the campaign only, case insensitive. If the campaign contains
   * the value of the `search` parameter anywhere in the name, it matches.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignsListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listWithHttpOperationResponse(resourceGroupName, appCollection, appName, kind, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._list(resourceGroupName, appCollection, appName, kind, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Get the list of campaigns.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.skip] Control paging of campaigns, start results at
   * the given offset, defaults to 0 (1st page of data).
   *
   * @param {number} [options.top] Control paging of campaigns, number of
   * campaigns to return with each call. It returns all campaigns by default.
   * When specifying $top parameter, the response contains a `nextLink` property
   * describing the path to get the next page if there are more results.
   *
   * @param {string} [options.filter] Filter can be used to restrict the results
   * to campaigns matching a specific state. The syntax is `$filter=state eq
   * 'draft'`. Valid state values are: draft, scheduled, in-progress, and
   * finished. Only the eq operator and the state property are supported.
   *
   * @param {string} [options.orderby] Sort results by an expression which looks
   * like `$orderby=id asc` (this example is actually the default behavior). The
   * syntax is orderby={property} {direction} or just orderby={property}. The
   * available sorting properties are id, name, state, activatedDate, and
   * finishedDate. The available directions are asc (for ascending order) and
   * desc (for descending order). When not specified the asc direction is used.
   * Only one property at a time can be used for sorting.
   *
   * @param {string} [options.search] Restrict results to campaigns matching the
   * optional `search` expression. This currently performs the search based on
   * the name on the campaign only, case insensitive. If the campaign contains
   * the value of the `search` parameter anywhere in the name, it matches.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignsListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignsListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  list(resourceGroupName, appCollection, appName, kind, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._list(resourceGroupName, appCollection, appName, kind, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._list(resourceGroupName, appCollection, appName, kind, options, optionalCallback);
    }
  }

  /**
   * Create a push campaign (announcement, poll, data push or native push).
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {object} parameters Parameters supplied to the Update Campaign
   * operation.
   *
   * @param {string} [parameters.name] Unique name of the campaign.
   *
   * @param {object} [parameters.audience] Specify which users will be targeted
   * by this campaign. By default, all users will be targeted. If you set
   * `pushMode` property to `manual`, the only thing you can specify in the
   * audience is the push quota filter. An audience is a boolean expression made
   * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Additionally, a set of filters can be added to an audience. 65535 bytes max
   * as per JSON encoding.
   *
   *
   * @param {string} [parameters.audience.expression] Boolean expression made of
   * criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Criterion names in the audience expression must start with a capital letter
   * and can only contain alphanumeric (A-Z,a-z,0-9) and underscore (_)
   * characters.
   *
   *
   * @param {object} [parameters.audience.criteria] Criteria by name.
   *
   * @param {array} [parameters.audience.filters] Global filters applied to all
   * devices.
   *
   * @param {string} [parameters.category] Category of the campaign. Categories
   * can be used on the application side to customize campaigns.
   *
   * @param {string} [parameters.pushMode] Announcements/polls only. Defines how
   * the campaign is pushed. Valid values are: * `real-time`: Never ending
   * campaign, the campaign will be delivered  to your existing users and also to
   * your new users. * `one-shot`: In this mode, the campaign will be delivered
   * only to your existing users (campaign will stop after that). * `manual`: In
   * this mode, the campaign will not be pushed automatically to devices. You
   * will have to use the Push campaign command to push the campaign to your
   * end-users. Campaigns can be pushed multiple times to the same device.
   * . Possible values include: 'real-time', 'one-shot', 'manual'
   *
   * @param {string} [parameters.type] Applicable only to announcements and data
   * pushes. Type of announcement. Valid values are: * `text/plain`: Text-only
   * announcement: `body` property should only contain plain text. * `text/html`:
   * HTML announcement: `body` attribute can contain HTML code. * `only_notif`:
   * Notification-only announcement. With this kind of announcements, the `body`,
   * `title`, `actionButtonText` and `exitButtonText` are ignored. Type of data
   * push. Valid values are: * `text/plain`: Text only data push: `body` property
   * must be plain text. * `text/base64`: Base 64 data push: `body` property must
   * be encoded in base 64.
   * . Possible values include: 'text/plain', 'text/html', 'only_notif',
   * 'text/base64'
   *
   * @param {string} [parameters.deliveryTime] Announcements/polls only. Defines
   * when the campaign should be delivered. Valid values are: * `any`: Campaign
   * will be delivered as soon as possible. * `background`: iOS only. Campaign
   * will be only delivered when the application is in background (out of app). *
   * `session`: Campaign will be delivered when the application is running.
   * . Possible values include: 'any', 'background', 'session'
   *
   * @param {array} [parameters.deliveryActivities] Announcements/polls only.
   * Array containing the list of activities in which the campaign can be
   * delivered. deliveryTime must be set to session. If the platform is iOS, this
   * option can also be set if deliveryTime is set to any. In that case, if the
   * campaign is received when the application is launched, it will be delivered
   * only in the specified list of activities.
   *
   *
   * @param {string} [parameters.startTime] The date at which the campaign should
   * be started. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
   * attribute will be ignored. * If you set pushMode property to one-shot, then
   * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.endTime] The date at which the campaign should
   * be finished. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.timezone] The id of the time zone to use for the
   * startTime and endTime dates. If not provided, the two date attributes will
   * be expressed using the device timezone. Example: America/Los_Angeles
   *
   *
   * @param {string} [parameters.notificationType] Android only. Defines how the
   * notification should be displayed. Valid values are: * `system`: Display the
   * notification using a standard system notification. * `popup`: Display the
   * notification using a in-app banner notification.
   * . Possible values include: 'system', 'popup'
   *
   * @param {boolean} [parameters.notificationIcon] A flag indicating whether or
   * not you want to display the resource icon in notification content.
   *
   * @param {boolean} [parameters.notificationCloseable] A flag indicating
   * whether or not you want the notification to be closeable.
   *
   * @param {boolean} [parameters.notificationVibrate] Android only. A flag
   * indicating whether or not you want the system notification to make a
   * vibration. The notificationType property must be set to system.
   *
   * @param {boolean} [parameters.notificationSound] * `Android`: A flag
   * indicating whether or not you want the system notification to make a sound.
   * The `notificationType` property must be set to `system`. * `iOS`: A flag
   * indicating whether or not you want the native Apple Push notification to
   * make a sound. The `deliveryTime` property must be set to `any` or
   * `background`. This will play the 'default' sound. If you want to play a
   * custom sound, see the `notificationOptions` property. * `Windows`: A flag
   * indicating whether or not you want the native Windows Notification Service
   * to make a sound. The `deliveryTime` property must be set to `any`.
   *
   *
   * @param {boolean} [parameters.notificationBadge] A flag indicating whether or
   * not you want the native Apple Push notification to update the badge icon to
   * the number of unread messages. The `deliveryTime` property must be set to
   * `any` or `background`.
   *
   *
   * @param {object} [parameters.localization] Push campaigns can be localized
   * using an optional JSON object. The JSON key is a two-character language code
   * as specified by the ISO 639-1 standard. The corresponding value is an object
   * containing the localizable properties.
   *
   *
   * @param {array} [parameters.questions] Poll questions.
   *
   * @param {string} [parameters.notificationTitle] Title of the notification.
   * This field supports appInfo markers.
   *
   * @param {string} [parameters.notificationMessage] Message of the
   * notification. This field supports appInfo markers.
   *
   * @param {buffer} [parameters.notificationImage] Optional image encoded in
   * base 64. Usually included in the right part of in app notifications (or as a
   * banner if there is neither text nor content icon). For Android system
   * notifications, the image is used as the large icon (displayed only on
   * Android 3+).
   *
   *
   * @param {object} [parameters.notificationOptions] Additional platform
   * specific options.
   *
   * @param {string} [parameters.notificationOptions.bigText] Android 4.1+ only.
   * Multi line message shown in expanded notifications on Android 4.1+ devices.
   * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.notificationOptions.bigPicture] URL of a remote
   * image displayed in expanded notifications on
   * Android 4.1+ devices with the following constraints:
   * * The URL length is limited to 2000 characters.
   * * The image size must be less than 4 MiB.
   * * The following MIME types are supported:
   * ** image/png
   * ** image/jpeg
   * ** image/gif
   * ** image/webp
   * ** image/bmp
   * ** image/x-bmp
   * ** image/x-ms-bmp
   * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
   * * Incompatible with `bigText`, only one of the fields can be set.
   * * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.notificationOptions.sound] iOS only. The name of
   * a sound file in the application bundle. The sound in this file is played as
   * an alert. If the sound file doesn’t exist or default is specified as the
   * value, the default alert sound is played. The audio must be in one of the
   * audio data formats that are compatible with system sounds. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.notificationOptions.actionText] The action text
   * is the title of the right button of the alert or the value of the unlock
   * slider, where the value replaces 'unlock' in 'slide to unlock'. 'View'
   * (localized to the preferred language) is used as the default value. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.title] Title of the announcement or poll. This
   * field supports appInfo markers.
   *
   * @param {string} [parameters.body] Body of the text/web announcement, poll or
   * data push. This field supports appInfo markers.
   *
   * @param {string} [parameters.actionButtonText] Text of the action button for
   * text/web announcements and polls (answer button).
   *
   * @param {string} [parameters.exitButtonText] Text of the exit button for
   * text/web announcements and polls.
   *
   * @param {string} [parameters.actionUrl] URL to launch when the announcement
   * is actioned.
   *
   * @param {object} [parameters.payload] Native push payload.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignStateResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createWithHttpOperationResponse(resourceGroupName, appCollection, appName, kind, parameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._create(resourceGroupName, appCollection, appName, kind, parameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create a push campaign (announcement, poll, data push or native push).
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {object} parameters Parameters supplied to the Update Campaign
   * operation.
   *
   * @param {string} [parameters.name] Unique name of the campaign.
   *
   * @param {object} [parameters.audience] Specify which users will be targeted
   * by this campaign. By default, all users will be targeted. If you set
   * `pushMode` property to `manual`, the only thing you can specify in the
   * audience is the push quota filter. An audience is a boolean expression made
   * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Additionally, a set of filters can be added to an audience. 65535 bytes max
   * as per JSON encoding.
   *
   *
   * @param {string} [parameters.audience.expression] Boolean expression made of
   * criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Criterion names in the audience expression must start with a capital letter
   * and can only contain alphanumeric (A-Z,a-z,0-9) and underscore (_)
   * characters.
   *
   *
   * @param {object} [parameters.audience.criteria] Criteria by name.
   *
   * @param {array} [parameters.audience.filters] Global filters applied to all
   * devices.
   *
   * @param {string} [parameters.category] Category of the campaign. Categories
   * can be used on the application side to customize campaigns.
   *
   * @param {string} [parameters.pushMode] Announcements/polls only. Defines how
   * the campaign is pushed. Valid values are: * `real-time`: Never ending
   * campaign, the campaign will be delivered  to your existing users and also to
   * your new users. * `one-shot`: In this mode, the campaign will be delivered
   * only to your existing users (campaign will stop after that). * `manual`: In
   * this mode, the campaign will not be pushed automatically to devices. You
   * will have to use the Push campaign command to push the campaign to your
   * end-users. Campaigns can be pushed multiple times to the same device.
   * . Possible values include: 'real-time', 'one-shot', 'manual'
   *
   * @param {string} [parameters.type] Applicable only to announcements and data
   * pushes. Type of announcement. Valid values are: * `text/plain`: Text-only
   * announcement: `body` property should only contain plain text. * `text/html`:
   * HTML announcement: `body` attribute can contain HTML code. * `only_notif`:
   * Notification-only announcement. With this kind of announcements, the `body`,
   * `title`, `actionButtonText` and `exitButtonText` are ignored. Type of data
   * push. Valid values are: * `text/plain`: Text only data push: `body` property
   * must be plain text. * `text/base64`: Base 64 data push: `body` property must
   * be encoded in base 64.
   * . Possible values include: 'text/plain', 'text/html', 'only_notif',
   * 'text/base64'
   *
   * @param {string} [parameters.deliveryTime] Announcements/polls only. Defines
   * when the campaign should be delivered. Valid values are: * `any`: Campaign
   * will be delivered as soon as possible. * `background`: iOS only. Campaign
   * will be only delivered when the application is in background (out of app). *
   * `session`: Campaign will be delivered when the application is running.
   * . Possible values include: 'any', 'background', 'session'
   *
   * @param {array} [parameters.deliveryActivities] Announcements/polls only.
   * Array containing the list of activities in which the campaign can be
   * delivered. deliveryTime must be set to session. If the platform is iOS, this
   * option can also be set if deliveryTime is set to any. In that case, if the
   * campaign is received when the application is launched, it will be delivered
   * only in the specified list of activities.
   *
   *
   * @param {string} [parameters.startTime] The date at which the campaign should
   * be started. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
   * attribute will be ignored. * If you set pushMode property to one-shot, then
   * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.endTime] The date at which the campaign should
   * be finished. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.timezone] The id of the time zone to use for the
   * startTime and endTime dates. If not provided, the two date attributes will
   * be expressed using the device timezone. Example: America/Los_Angeles
   *
   *
   * @param {string} [parameters.notificationType] Android only. Defines how the
   * notification should be displayed. Valid values are: * `system`: Display the
   * notification using a standard system notification. * `popup`: Display the
   * notification using a in-app banner notification.
   * . Possible values include: 'system', 'popup'
   *
   * @param {boolean} [parameters.notificationIcon] A flag indicating whether or
   * not you want to display the resource icon in notification content.
   *
   * @param {boolean} [parameters.notificationCloseable] A flag indicating
   * whether or not you want the notification to be closeable.
   *
   * @param {boolean} [parameters.notificationVibrate] Android only. A flag
   * indicating whether or not you want the system notification to make a
   * vibration. The notificationType property must be set to system.
   *
   * @param {boolean} [parameters.notificationSound] * `Android`: A flag
   * indicating whether or not you want the system notification to make a sound.
   * The `notificationType` property must be set to `system`. * `iOS`: A flag
   * indicating whether or not you want the native Apple Push notification to
   * make a sound. The `deliveryTime` property must be set to `any` or
   * `background`. This will play the 'default' sound. If you want to play a
   * custom sound, see the `notificationOptions` property. * `Windows`: A flag
   * indicating whether or not you want the native Windows Notification Service
   * to make a sound. The `deliveryTime` property must be set to `any`.
   *
   *
   * @param {boolean} [parameters.notificationBadge] A flag indicating whether or
   * not you want the native Apple Push notification to update the badge icon to
   * the number of unread messages. The `deliveryTime` property must be set to
   * `any` or `background`.
   *
   *
   * @param {object} [parameters.localization] Push campaigns can be localized
   * using an optional JSON object. The JSON key is a two-character language code
   * as specified by the ISO 639-1 standard. The corresponding value is an object
   * containing the localizable properties.
   *
   *
   * @param {array} [parameters.questions] Poll questions.
   *
   * @param {string} [parameters.notificationTitle] Title of the notification.
   * This field supports appInfo markers.
   *
   * @param {string} [parameters.notificationMessage] Message of the
   * notification. This field supports appInfo markers.
   *
   * @param {buffer} [parameters.notificationImage] Optional image encoded in
   * base 64. Usually included in the right part of in app notifications (or as a
   * banner if there is neither text nor content icon). For Android system
   * notifications, the image is used as the large icon (displayed only on
   * Android 3+).
   *
   *
   * @param {object} [parameters.notificationOptions] Additional platform
   * specific options.
   *
   * @param {string} [parameters.notificationOptions.bigText] Android 4.1+ only.
   * Multi line message shown in expanded notifications on Android 4.1+ devices.
   * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.notificationOptions.bigPicture] URL of a remote
   * image displayed in expanded notifications on
   * Android 4.1+ devices with the following constraints:
   * * The URL length is limited to 2000 characters.
   * * The image size must be less than 4 MiB.
   * * The following MIME types are supported:
   * ** image/png
   * ** image/jpeg
   * ** image/gif
   * ** image/webp
   * ** image/bmp
   * ** image/x-bmp
   * ** image/x-ms-bmp
   * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
   * * Incompatible with `bigText`, only one of the fields can be set.
   * * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.notificationOptions.sound] iOS only. The name of
   * a sound file in the application bundle. The sound in this file is played as
   * an alert. If the sound file doesn’t exist or default is specified as the
   * value, the default alert sound is played. The audio must be in one of the
   * audio data formats that are compatible with system sounds. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.notificationOptions.actionText] The action text
   * is the title of the right button of the alert or the value of the unlock
   * slider, where the value replaces 'unlock' in 'slide to unlock'. 'View'
   * (localized to the preferred language) is used as the default value. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.title] Title of the announcement or poll. This
   * field supports appInfo markers.
   *
   * @param {string} [parameters.body] Body of the text/web announcement, poll or
   * data push. This field supports appInfo markers.
   *
   * @param {string} [parameters.actionButtonText] Text of the action button for
   * text/web announcements and polls (answer button).
   *
   * @param {string} [parameters.exitButtonText] Text of the exit button for
   * text/web announcements and polls.
   *
   * @param {string} [parameters.actionUrl] URL to launch when the announcement
   * is actioned.
   *
   * @param {object} [parameters.payload] Native push payload.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignStateResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignStateResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  create(resourceGroupName, appCollection, appName, kind, parameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._create(resourceGroupName, appCollection, appName, kind, parameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._create(resourceGroupName, appCollection, appName, kind, parameters, options, optionalCallback);
    }
  }

  /**
   * The Get campaign operation retrieves information about a previously created
   * campaign.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWithHttpOperationResponse(kind, id, resourceGroupName, appCollection, appName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._get(kind, id, resourceGroupName, appCollection, appName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * The Get campaign operation retrieves information about a previously created
   * campaign.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  get(kind, id, resourceGroupName, appCollection, appName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._get(kind, id, resourceGroupName, appCollection, appName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._get(kind, id, resourceGroupName, appCollection, appName, options, optionalCallback);
    }
  }

  /**
   * Update an existing push campaign (announcement, poll, data push or native
   * push).
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} parameters Parameters supplied to the Update Campaign
   * operation.
   *
   * @param {string} [parameters.name] Unique name of the campaign.
   *
   * @param {object} [parameters.audience] Specify which users will be targeted
   * by this campaign. By default, all users will be targeted. If you set
   * `pushMode` property to `manual`, the only thing you can specify in the
   * audience is the push quota filter. An audience is a boolean expression made
   * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Additionally, a set of filters can be added to an audience. 65535 bytes max
   * as per JSON encoding.
   *
   *
   * @param {string} [parameters.audience.expression] Boolean expression made of
   * criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Criterion names in the audience expression must start with a capital letter
   * and can only contain alphanumeric (A-Z,a-z,0-9) and underscore (_)
   * characters.
   *
   *
   * @param {object} [parameters.audience.criteria] Criteria by name.
   *
   * @param {array} [parameters.audience.filters] Global filters applied to all
   * devices.
   *
   * @param {string} [parameters.category] Category of the campaign. Categories
   * can be used on the application side to customize campaigns.
   *
   * @param {string} [parameters.pushMode] Announcements/polls only. Defines how
   * the campaign is pushed. Valid values are: * `real-time`: Never ending
   * campaign, the campaign will be delivered  to your existing users and also to
   * your new users. * `one-shot`: In this mode, the campaign will be delivered
   * only to your existing users (campaign will stop after that). * `manual`: In
   * this mode, the campaign will not be pushed automatically to devices. You
   * will have to use the Push campaign command to push the campaign to your
   * end-users. Campaigns can be pushed multiple times to the same device.
   * . Possible values include: 'real-time', 'one-shot', 'manual'
   *
   * @param {string} [parameters.type] Applicable only to announcements and data
   * pushes. Type of announcement. Valid values are: * `text/plain`: Text-only
   * announcement: `body` property should only contain plain text. * `text/html`:
   * HTML announcement: `body` attribute can contain HTML code. * `only_notif`:
   * Notification-only announcement. With this kind of announcements, the `body`,
   * `title`, `actionButtonText` and `exitButtonText` are ignored. Type of data
   * push. Valid values are: * `text/plain`: Text only data push: `body` property
   * must be plain text. * `text/base64`: Base 64 data push: `body` property must
   * be encoded in base 64.
   * . Possible values include: 'text/plain', 'text/html', 'only_notif',
   * 'text/base64'
   *
   * @param {string} [parameters.deliveryTime] Announcements/polls only. Defines
   * when the campaign should be delivered. Valid values are: * `any`: Campaign
   * will be delivered as soon as possible. * `background`: iOS only. Campaign
   * will be only delivered when the application is in background (out of app). *
   * `session`: Campaign will be delivered when the application is running.
   * . Possible values include: 'any', 'background', 'session'
   *
   * @param {array} [parameters.deliveryActivities] Announcements/polls only.
   * Array containing the list of activities in which the campaign can be
   * delivered. deliveryTime must be set to session. If the platform is iOS, this
   * option can also be set if deliveryTime is set to any. In that case, if the
   * campaign is received when the application is launched, it will be delivered
   * only in the specified list of activities.
   *
   *
   * @param {string} [parameters.startTime] The date at which the campaign should
   * be started. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
   * attribute will be ignored. * If you set pushMode property to one-shot, then
   * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.endTime] The date at which the campaign should
   * be finished. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.timezone] The id of the time zone to use for the
   * startTime and endTime dates. If not provided, the two date attributes will
   * be expressed using the device timezone. Example: America/Los_Angeles
   *
   *
   * @param {string} [parameters.notificationType] Android only. Defines how the
   * notification should be displayed. Valid values are: * `system`: Display the
   * notification using a standard system notification. * `popup`: Display the
   * notification using a in-app banner notification.
   * . Possible values include: 'system', 'popup'
   *
   * @param {boolean} [parameters.notificationIcon] A flag indicating whether or
   * not you want to display the resource icon in notification content.
   *
   * @param {boolean} [parameters.notificationCloseable] A flag indicating
   * whether or not you want the notification to be closeable.
   *
   * @param {boolean} [parameters.notificationVibrate] Android only. A flag
   * indicating whether or not you want the system notification to make a
   * vibration. The notificationType property must be set to system.
   *
   * @param {boolean} [parameters.notificationSound] * `Android`: A flag
   * indicating whether or not you want the system notification to make a sound.
   * The `notificationType` property must be set to `system`. * `iOS`: A flag
   * indicating whether or not you want the native Apple Push notification to
   * make a sound. The `deliveryTime` property must be set to `any` or
   * `background`. This will play the 'default' sound. If you want to play a
   * custom sound, see the `notificationOptions` property. * `Windows`: A flag
   * indicating whether or not you want the native Windows Notification Service
   * to make a sound. The `deliveryTime` property must be set to `any`.
   *
   *
   * @param {boolean} [parameters.notificationBadge] A flag indicating whether or
   * not you want the native Apple Push notification to update the badge icon to
   * the number of unread messages. The `deliveryTime` property must be set to
   * `any` or `background`.
   *
   *
   * @param {object} [parameters.localization] Push campaigns can be localized
   * using an optional JSON object. The JSON key is a two-character language code
   * as specified by the ISO 639-1 standard. The corresponding value is an object
   * containing the localizable properties.
   *
   *
   * @param {array} [parameters.questions] Poll questions.
   *
   * @param {string} [parameters.notificationTitle] Title of the notification.
   * This field supports appInfo markers.
   *
   * @param {string} [parameters.notificationMessage] Message of the
   * notification. This field supports appInfo markers.
   *
   * @param {buffer} [parameters.notificationImage] Optional image encoded in
   * base 64. Usually included in the right part of in app notifications (or as a
   * banner if there is neither text nor content icon). For Android system
   * notifications, the image is used as the large icon (displayed only on
   * Android 3+).
   *
   *
   * @param {object} [parameters.notificationOptions] Additional platform
   * specific options.
   *
   * @param {string} [parameters.notificationOptions.bigText] Android 4.1+ only.
   * Multi line message shown in expanded notifications on Android 4.1+ devices.
   * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.notificationOptions.bigPicture] URL of a remote
   * image displayed in expanded notifications on
   * Android 4.1+ devices with the following constraints:
   * * The URL length is limited to 2000 characters.
   * * The image size must be less than 4 MiB.
   * * The following MIME types are supported:
   * ** image/png
   * ** image/jpeg
   * ** image/gif
   * ** image/webp
   * ** image/bmp
   * ** image/x-bmp
   * ** image/x-ms-bmp
   * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
   * * Incompatible with `bigText`, only one of the fields can be set.
   * * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.notificationOptions.sound] iOS only. The name of
   * a sound file in the application bundle. The sound in this file is played as
   * an alert. If the sound file doesn’t exist or default is specified as the
   * value, the default alert sound is played. The audio must be in one of the
   * audio data formats that are compatible with system sounds. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.notificationOptions.actionText] The action text
   * is the title of the right button of the alert or the value of the unlock
   * slider, where the value replaces 'unlock' in 'slide to unlock'. 'View'
   * (localized to the preferred language) is used as the default value. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.title] Title of the announcement or poll. This
   * field supports appInfo markers.
   *
   * @param {string} [parameters.body] Body of the text/web announcement, poll or
   * data push. This field supports appInfo markers.
   *
   * @param {string} [parameters.actionButtonText] Text of the action button for
   * text/web announcements and polls (answer button).
   *
   * @param {string} [parameters.exitButtonText] Text of the exit button for
   * text/web announcements and polls.
   *
   * @param {string} [parameters.actionUrl] URL to launch when the announcement
   * is actioned.
   *
   * @param {object} [parameters.payload] Native push payload.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignStateResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateWithHttpOperationResponse(kind, id, parameters, resourceGroupName, appCollection, appName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._update(kind, id, parameters, resourceGroupName, appCollection, appName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Update an existing push campaign (announcement, poll, data push or native
   * push).
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} parameters Parameters supplied to the Update Campaign
   * operation.
   *
   * @param {string} [parameters.name] Unique name of the campaign.
   *
   * @param {object} [parameters.audience] Specify which users will be targeted
   * by this campaign. By default, all users will be targeted. If you set
   * `pushMode` property to `manual`, the only thing you can specify in the
   * audience is the push quota filter. An audience is a boolean expression made
   * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Additionally, a set of filters can be added to an audience. 65535 bytes max
   * as per JSON encoding.
   *
   *
   * @param {string} [parameters.audience.expression] Boolean expression made of
   * criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Criterion names in the audience expression must start with a capital letter
   * and can only contain alphanumeric (A-Z,a-z,0-9) and underscore (_)
   * characters.
   *
   *
   * @param {object} [parameters.audience.criteria] Criteria by name.
   *
   * @param {array} [parameters.audience.filters] Global filters applied to all
   * devices.
   *
   * @param {string} [parameters.category] Category of the campaign. Categories
   * can be used on the application side to customize campaigns.
   *
   * @param {string} [parameters.pushMode] Announcements/polls only. Defines how
   * the campaign is pushed. Valid values are: * `real-time`: Never ending
   * campaign, the campaign will be delivered  to your existing users and also to
   * your new users. * `one-shot`: In this mode, the campaign will be delivered
   * only to your existing users (campaign will stop after that). * `manual`: In
   * this mode, the campaign will not be pushed automatically to devices. You
   * will have to use the Push campaign command to push the campaign to your
   * end-users. Campaigns can be pushed multiple times to the same device.
   * . Possible values include: 'real-time', 'one-shot', 'manual'
   *
   * @param {string} [parameters.type] Applicable only to announcements and data
   * pushes. Type of announcement. Valid values are: * `text/plain`: Text-only
   * announcement: `body` property should only contain plain text. * `text/html`:
   * HTML announcement: `body` attribute can contain HTML code. * `only_notif`:
   * Notification-only announcement. With this kind of announcements, the `body`,
   * `title`, `actionButtonText` and `exitButtonText` are ignored. Type of data
   * push. Valid values are: * `text/plain`: Text only data push: `body` property
   * must be plain text. * `text/base64`: Base 64 data push: `body` property must
   * be encoded in base 64.
   * . Possible values include: 'text/plain', 'text/html', 'only_notif',
   * 'text/base64'
   *
   * @param {string} [parameters.deliveryTime] Announcements/polls only. Defines
   * when the campaign should be delivered. Valid values are: * `any`: Campaign
   * will be delivered as soon as possible. * `background`: iOS only. Campaign
   * will be only delivered when the application is in background (out of app). *
   * `session`: Campaign will be delivered when the application is running.
   * . Possible values include: 'any', 'background', 'session'
   *
   * @param {array} [parameters.deliveryActivities] Announcements/polls only.
   * Array containing the list of activities in which the campaign can be
   * delivered. deliveryTime must be set to session. If the platform is iOS, this
   * option can also be set if deliveryTime is set to any. In that case, if the
   * campaign is received when the application is launched, it will be delivered
   * only in the specified list of activities.
   *
   *
   * @param {string} [parameters.startTime] The date at which the campaign should
   * be started. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
   * attribute will be ignored. * If you set pushMode property to one-shot, then
   * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.endTime] The date at which the campaign should
   * be finished. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.timezone] The id of the time zone to use for the
   * startTime and endTime dates. If not provided, the two date attributes will
   * be expressed using the device timezone. Example: America/Los_Angeles
   *
   *
   * @param {string} [parameters.notificationType] Android only. Defines how the
   * notification should be displayed. Valid values are: * `system`: Display the
   * notification using a standard system notification. * `popup`: Display the
   * notification using a in-app banner notification.
   * . Possible values include: 'system', 'popup'
   *
   * @param {boolean} [parameters.notificationIcon] A flag indicating whether or
   * not you want to display the resource icon in notification content.
   *
   * @param {boolean} [parameters.notificationCloseable] A flag indicating
   * whether or not you want the notification to be closeable.
   *
   * @param {boolean} [parameters.notificationVibrate] Android only. A flag
   * indicating whether or not you want the system notification to make a
   * vibration. The notificationType property must be set to system.
   *
   * @param {boolean} [parameters.notificationSound] * `Android`: A flag
   * indicating whether or not you want the system notification to make a sound.
   * The `notificationType` property must be set to `system`. * `iOS`: A flag
   * indicating whether or not you want the native Apple Push notification to
   * make a sound. The `deliveryTime` property must be set to `any` or
   * `background`. This will play the 'default' sound. If you want to play a
   * custom sound, see the `notificationOptions` property. * `Windows`: A flag
   * indicating whether or not you want the native Windows Notification Service
   * to make a sound. The `deliveryTime` property must be set to `any`.
   *
   *
   * @param {boolean} [parameters.notificationBadge] A flag indicating whether or
   * not you want the native Apple Push notification to update the badge icon to
   * the number of unread messages. The `deliveryTime` property must be set to
   * `any` or `background`.
   *
   *
   * @param {object} [parameters.localization] Push campaigns can be localized
   * using an optional JSON object. The JSON key is a two-character language code
   * as specified by the ISO 639-1 standard. The corresponding value is an object
   * containing the localizable properties.
   *
   *
   * @param {array} [parameters.questions] Poll questions.
   *
   * @param {string} [parameters.notificationTitle] Title of the notification.
   * This field supports appInfo markers.
   *
   * @param {string} [parameters.notificationMessage] Message of the
   * notification. This field supports appInfo markers.
   *
   * @param {buffer} [parameters.notificationImage] Optional image encoded in
   * base 64. Usually included in the right part of in app notifications (or as a
   * banner if there is neither text nor content icon). For Android system
   * notifications, the image is used as the large icon (displayed only on
   * Android 3+).
   *
   *
   * @param {object} [parameters.notificationOptions] Additional platform
   * specific options.
   *
   * @param {string} [parameters.notificationOptions.bigText] Android 4.1+ only.
   * Multi line message shown in expanded notifications on Android 4.1+ devices.
   * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.notificationOptions.bigPicture] URL of a remote
   * image displayed in expanded notifications on
   * Android 4.1+ devices with the following constraints:
   * * The URL length is limited to 2000 characters.
   * * The image size must be less than 4 MiB.
   * * The following MIME types are supported:
   * ** image/png
   * ** image/jpeg
   * ** image/gif
   * ** image/webp
   * ** image/bmp
   * ** image/x-bmp
   * ** image/x-ms-bmp
   * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
   * * Incompatible with `bigText`, only one of the fields can be set.
   * * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.notificationOptions.sound] iOS only. The name of
   * a sound file in the application bundle. The sound in this file is played as
   * an alert. If the sound file doesn’t exist or default is specified as the
   * value, the default alert sound is played. The audio must be in one of the
   * audio data formats that are compatible with system sounds. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.notificationOptions.actionText] The action text
   * is the title of the right button of the alert or the value of the unlock
   * slider, where the value replaces 'unlock' in 'slide to unlock'. 'View'
   * (localized to the preferred language) is used as the default value. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.title] Title of the announcement or poll. This
   * field supports appInfo markers.
   *
   * @param {string} [parameters.body] Body of the text/web announcement, poll or
   * data push. This field supports appInfo markers.
   *
   * @param {string} [parameters.actionButtonText] Text of the action button for
   * text/web announcements and polls (answer button).
   *
   * @param {string} [parameters.exitButtonText] Text of the exit button for
   * text/web announcements and polls.
   *
   * @param {string} [parameters.actionUrl] URL to launch when the announcement
   * is actioned.
   *
   * @param {object} [parameters.payload] Native push payload.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignStateResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignStateResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  update(kind, id, parameters, resourceGroupName, appCollection, appName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._update(kind, id, parameters, resourceGroupName, appCollection, appName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._update(kind, id, parameters, resourceGroupName, appCollection, appName, options, optionalCallback);
    }
  }

  /**
   * Delete a campaign previously created by a call to Create campaign.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMethodWithHttpOperationResponse(kind, id, resourceGroupName, appCollection, appName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMethod(kind, id, resourceGroupName, appCollection, appName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Delete a campaign previously created by a call to Create campaign.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(kind, id, resourceGroupName, appCollection, appName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMethod(kind, id, resourceGroupName, appCollection, appName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMethod(kind, id, resourceGroupName, appCollection, appName, options, optionalCallback);
    }
  }

  /**
   * The Get campaign operation retrieves information about a previously created
   * campaign.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {string} name Campaign name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getByNameWithHttpOperationResponse(resourceGroupName, appCollection, appName, kind, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getByName(resourceGroupName, appCollection, appName, kind, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * The Get campaign operation retrieves information about a previously created
   * campaign.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {string} name Campaign name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getByName(resourceGroupName, appCollection, appName, kind, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getByName(resourceGroupName, appCollection, appName, kind, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getByName(resourceGroupName, appCollection, appName, kind, name, options, optionalCallback);
    }
  }

  /**
   * Test an existing campaign (created with Create campaign) on a set of
   * devices.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} parameters Parameters supplied to the Test Campaign
   * operation.
   *
   * @param {string} parameters.deviceId Device identifier (as returned by the
   * SDK).
   *
   * @param {string} [parameters.lang] The language to test expressed using ISO
   * 639-1 code. The default language of the campaign will be used if the
   * parameter is not provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignStateResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  testSavedWithHttpOperationResponse(resourceGroupName, appCollection, appName, kind, id, parameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._testSaved(resourceGroupName, appCollection, appName, kind, id, parameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Test an existing campaign (created with Create campaign) on a set of
   * devices.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} parameters Parameters supplied to the Test Campaign
   * operation.
   *
   * @param {string} parameters.deviceId Device identifier (as returned by the
   * SDK).
   *
   * @param {string} [parameters.lang] The language to test expressed using ISO
   * 639-1 code. The default language of the campaign will be used if the
   * parameter is not provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignStateResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignStateResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  testSaved(resourceGroupName, appCollection, appName, kind, id, parameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._testSaved(resourceGroupName, appCollection, appName, kind, id, parameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._testSaved(resourceGroupName, appCollection, appName, kind, id, parameters, options, optionalCallback);
    }
  }

  /**
   * Test a new campaign on a set of devices.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {object} parameters Parameters supplied to the Test Campaign
   * operation.
   *
   * @param {object} parameters.data
   *
   * @param {string} [parameters.data.name] Unique name of the campaign.
   *
   * @param {object} [parameters.data.audience] Specify which users will be
   * targeted by this campaign. By default, all users will be targeted. If you
   * set `pushMode` property to `manual`, the only thing you can specify in the
   * audience is the push quota filter. An audience is a boolean expression made
   * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Additionally, a set of filters can be added to an audience. 65535 bytes max
   * as per JSON encoding.
   *
   *
   * @param {string} [parameters.data.audience.expression] Boolean expression
   * made of criteria (variables) operators (`not`, `and` or `or`) and
   * parenthesis. Criterion names in the audience expression must start with a
   * capital letter and can only contain alphanumeric (A-Z,a-z,0-9) and
   * underscore (_) characters.
   *
   *
   * @param {object} [parameters.data.audience.criteria] Criteria by name.
   *
   * @param {array} [parameters.data.audience.filters] Global filters applied to
   * all devices.
   *
   * @param {string} [parameters.data.category] Category of the campaign.
   * Categories can be used on the application side to customize campaigns.
   *
   * @param {string} [parameters.data.pushMode] Announcements/polls only. Defines
   * how the campaign is pushed. Valid values are: * `real-time`: Never ending
   * campaign, the campaign will be delivered  to your existing users and also to
   * your new users. * `one-shot`: In this mode, the campaign will be delivered
   * only to your existing users (campaign will stop after that). * `manual`: In
   * this mode, the campaign will not be pushed automatically to devices. You
   * will have to use the Push campaign command to push the campaign to your
   * end-users. Campaigns can be pushed multiple times to the same device.
   * . Possible values include: 'real-time', 'one-shot', 'manual'
   *
   * @param {string} [parameters.data.type] Applicable only to announcements and
   * data pushes. Type of announcement. Valid values are: * `text/plain`:
   * Text-only announcement: `body` property should only contain plain text. *
   * `text/html`: HTML announcement: `body` attribute can contain HTML code. *
   * `only_notif`: Notification-only announcement. With this kind of
   * announcements, the `body`, `title`, `actionButtonText` and `exitButtonText`
   * are ignored. Type of data push. Valid values are: * `text/plain`: Text only
   * data push: `body` property must be plain text. * `text/base64`: Base 64 data
   * push: `body` property must be encoded in base 64.
   * . Possible values include: 'text/plain', 'text/html', 'only_notif',
   * 'text/base64'
   *
   * @param {string} [parameters.data.deliveryTime] Announcements/polls only.
   * Defines when the campaign should be delivered. Valid values are: * `any`:
   * Campaign will be delivered as soon as possible. * `background`: iOS only.
   * Campaign will be only delivered when the application is in background (out
   * of app). * `session`: Campaign will be delivered when the application is
   * running.
   * . Possible values include: 'any', 'background', 'session'
   *
   * @param {array} [parameters.data.deliveryActivities] Announcements/polls
   * only. Array containing the list of activities in which the campaign can be
   * delivered. deliveryTime must be set to session. If the platform is iOS, this
   * option can also be set if deliveryTime is set to any. In that case, if the
   * campaign is received when the application is launched, it will be delivered
   * only in the specified list of activities.
   *
   *
   * @param {string} [parameters.data.startTime] The date at which the campaign
   * should be started. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
   * attribute will be ignored. * If you set pushMode property to one-shot, then
   * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.data.endTime] The date at which the campaign
   * should be finished. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.data.timezone] The id of the time zone to use
   * for the startTime and endTime dates. If not provided, the two date
   * attributes will be expressed using the device timezone. Example:
   * America/Los_Angeles
   *
   *
   * @param {string} [parameters.data.notificationType] Android only. Defines how
   * the notification should be displayed. Valid values are: * `system`: Display
   * the notification using a standard system notification. * `popup`: Display
   * the notification using a in-app banner notification.
   * . Possible values include: 'system', 'popup'
   *
   * @param {boolean} [parameters.data.notificationIcon] A flag indicating
   * whether or not you want to display the resource icon in notification
   * content.
   *
   * @param {boolean} [parameters.data.notificationCloseable] A flag indicating
   * whether or not you want the notification to be closeable.
   *
   * @param {boolean} [parameters.data.notificationVibrate] Android only. A flag
   * indicating whether or not you want the system notification to make a
   * vibration. The notificationType property must be set to system.
   *
   * @param {boolean} [parameters.data.notificationSound] * `Android`: A flag
   * indicating whether or not you want the system notification to make a sound.
   * The `notificationType` property must be set to `system`. * `iOS`: A flag
   * indicating whether or not you want the native Apple Push notification to
   * make a sound. The `deliveryTime` property must be set to `any` or
   * `background`. This will play the 'default' sound. If you want to play a
   * custom sound, see the `notificationOptions` property. * `Windows`: A flag
   * indicating whether or not you want the native Windows Notification Service
   * to make a sound. The `deliveryTime` property must be set to `any`.
   *
   *
   * @param {boolean} [parameters.data.notificationBadge] A flag indicating
   * whether or not you want the native Apple Push notification to update the
   * badge icon to the number of unread messages. The `deliveryTime` property
   * must be set to `any` or `background`.
   *
   *
   * @param {object} [parameters.data.localization] Push campaigns can be
   * localized using an optional JSON object. The JSON key is a two-character
   * language code as specified by the ISO 639-1 standard. The corresponding
   * value is an object containing the localizable properties.
   *
   *
   * @param {array} [parameters.data.questions] Poll questions.
   *
   * @param {string} [parameters.data.notificationTitle] Title of the
   * notification. This field supports appInfo markers.
   *
   * @param {string} [parameters.data.notificationMessage] Message of the
   * notification. This field supports appInfo markers.
   *
   * @param {buffer} [parameters.data.notificationImage] Optional image encoded
   * in base 64. Usually included in the right part of in app notifications (or
   * as a banner if there is neither text nor content icon). For Android system
   * notifications, the image is used as the large icon (displayed only on
   * Android 3+).
   *
   *
   * @param {object} [parameters.data.notificationOptions] Additional platform
   * specific options.
   *
   * @param {string} [parameters.data.notificationOptions.bigText] Android 4.1+
   * only. Multi line message shown in expanded notifications on Android 4.1+
   * devices. The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.bigPicture] URL of a
   * remote image displayed in expanded notifications on
   * Android 4.1+ devices with the following constraints:
   * * The URL length is limited to 2000 characters.
   * * The image size must be less than 4 MiB.
   * * The following MIME types are supported:
   * ** image/png
   * ** image/jpeg
   * ** image/gif
   * ** image/webp
   * ** image/bmp
   * ** image/x-bmp
   * ** image/x-ms-bmp
   * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
   * * Incompatible with `bigText`, only one of the fields can be set.
   * * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.sound] iOS only. The
   * name of a sound file in the application bundle. The sound in this file is
   * played as an alert. If the sound file doesn’t exist or default is specified
   * as the value, the default alert sound is played. The audio must be in one of
   * the audio data formats that are compatible with system sounds. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.actionText] The action
   * text is the title of the right button of the alert or the value of the
   * unlock slider, where the value replaces 'unlock' in 'slide to unlock'.
   * 'View' (localized to the preferred language) is used as the default value.
   * The `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.data.title] Title of the announcement or poll.
   * This field supports appInfo markers.
   *
   * @param {string} [parameters.data.body] Body of the text/web announcement,
   * poll or data push. This field supports appInfo markers.
   *
   * @param {string} [parameters.data.actionButtonText] Text of the action button
   * for text/web announcements and polls (answer button).
   *
   * @param {string} [parameters.data.exitButtonText] Text of the exit button for
   * text/web announcements and polls.
   *
   * @param {string} [parameters.data.actionUrl] URL to launch when the
   * announcement is actioned.
   *
   * @param {object} [parameters.data.payload] Native push payload.
   *
   * @param {string} parameters.deviceId Device identifier (as returned by the
   * SDK).
   *
   * @param {string} [parameters.lang] The language to test expressed using ISO
   * 639-1 code. The default language of the campaign will be used if the
   * parameter is not provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignState>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  testNewWithHttpOperationResponse(resourceGroupName, appCollection, appName, kind, parameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._testNew(resourceGroupName, appCollection, appName, kind, parameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Test a new campaign on a set of devices.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {object} parameters Parameters supplied to the Test Campaign
   * operation.
   *
   * @param {object} parameters.data
   *
   * @param {string} [parameters.data.name] Unique name of the campaign.
   *
   * @param {object} [parameters.data.audience] Specify which users will be
   * targeted by this campaign. By default, all users will be targeted. If you
   * set `pushMode` property to `manual`, the only thing you can specify in the
   * audience is the push quota filter. An audience is a boolean expression made
   * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Additionally, a set of filters can be added to an audience. 65535 bytes max
   * as per JSON encoding.
   *
   *
   * @param {string} [parameters.data.audience.expression] Boolean expression
   * made of criteria (variables) operators (`not`, `and` or `or`) and
   * parenthesis. Criterion names in the audience expression must start with a
   * capital letter and can only contain alphanumeric (A-Z,a-z,0-9) and
   * underscore (_) characters.
   *
   *
   * @param {object} [parameters.data.audience.criteria] Criteria by name.
   *
   * @param {array} [parameters.data.audience.filters] Global filters applied to
   * all devices.
   *
   * @param {string} [parameters.data.category] Category of the campaign.
   * Categories can be used on the application side to customize campaigns.
   *
   * @param {string} [parameters.data.pushMode] Announcements/polls only. Defines
   * how the campaign is pushed. Valid values are: * `real-time`: Never ending
   * campaign, the campaign will be delivered  to your existing users and also to
   * your new users. * `one-shot`: In this mode, the campaign will be delivered
   * only to your existing users (campaign will stop after that). * `manual`: In
   * this mode, the campaign will not be pushed automatically to devices. You
   * will have to use the Push campaign command to push the campaign to your
   * end-users. Campaigns can be pushed multiple times to the same device.
   * . Possible values include: 'real-time', 'one-shot', 'manual'
   *
   * @param {string} [parameters.data.type] Applicable only to announcements and
   * data pushes. Type of announcement. Valid values are: * `text/plain`:
   * Text-only announcement: `body` property should only contain plain text. *
   * `text/html`: HTML announcement: `body` attribute can contain HTML code. *
   * `only_notif`: Notification-only announcement. With this kind of
   * announcements, the `body`, `title`, `actionButtonText` and `exitButtonText`
   * are ignored. Type of data push. Valid values are: * `text/plain`: Text only
   * data push: `body` property must be plain text. * `text/base64`: Base 64 data
   * push: `body` property must be encoded in base 64.
   * . Possible values include: 'text/plain', 'text/html', 'only_notif',
   * 'text/base64'
   *
   * @param {string} [parameters.data.deliveryTime] Announcements/polls only.
   * Defines when the campaign should be delivered. Valid values are: * `any`:
   * Campaign will be delivered as soon as possible. * `background`: iOS only.
   * Campaign will be only delivered when the application is in background (out
   * of app). * `session`: Campaign will be delivered when the application is
   * running.
   * . Possible values include: 'any', 'background', 'session'
   *
   * @param {array} [parameters.data.deliveryActivities] Announcements/polls
   * only. Array containing the list of activities in which the campaign can be
   * delivered. deliveryTime must be set to session. If the platform is iOS, this
   * option can also be set if deliveryTime is set to any. In that case, if the
   * campaign is received when the application is launched, it will be delivered
   * only in the specified list of activities.
   *
   *
   * @param {string} [parameters.data.startTime] The date at which the campaign
   * should be started. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
   * attribute will be ignored. * If you set pushMode property to one-shot, then
   * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.data.endTime] The date at which the campaign
   * should be finished. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.data.timezone] The id of the time zone to use
   * for the startTime and endTime dates. If not provided, the two date
   * attributes will be expressed using the device timezone. Example:
   * America/Los_Angeles
   *
   *
   * @param {string} [parameters.data.notificationType] Android only. Defines how
   * the notification should be displayed. Valid values are: * `system`: Display
   * the notification using a standard system notification. * `popup`: Display
   * the notification using a in-app banner notification.
   * . Possible values include: 'system', 'popup'
   *
   * @param {boolean} [parameters.data.notificationIcon] A flag indicating
   * whether or not you want to display the resource icon in notification
   * content.
   *
   * @param {boolean} [parameters.data.notificationCloseable] A flag indicating
   * whether or not you want the notification to be closeable.
   *
   * @param {boolean} [parameters.data.notificationVibrate] Android only. A flag
   * indicating whether or not you want the system notification to make a
   * vibration. The notificationType property must be set to system.
   *
   * @param {boolean} [parameters.data.notificationSound] * `Android`: A flag
   * indicating whether or not you want the system notification to make a sound.
   * The `notificationType` property must be set to `system`. * `iOS`: A flag
   * indicating whether or not you want the native Apple Push notification to
   * make a sound. The `deliveryTime` property must be set to `any` or
   * `background`. This will play the 'default' sound. If you want to play a
   * custom sound, see the `notificationOptions` property. * `Windows`: A flag
   * indicating whether or not you want the native Windows Notification Service
   * to make a sound. The `deliveryTime` property must be set to `any`.
   *
   *
   * @param {boolean} [parameters.data.notificationBadge] A flag indicating
   * whether or not you want the native Apple Push notification to update the
   * badge icon to the number of unread messages. The `deliveryTime` property
   * must be set to `any` or `background`.
   *
   *
   * @param {object} [parameters.data.localization] Push campaigns can be
   * localized using an optional JSON object. The JSON key is a two-character
   * language code as specified by the ISO 639-1 standard. The corresponding
   * value is an object containing the localizable properties.
   *
   *
   * @param {array} [parameters.data.questions] Poll questions.
   *
   * @param {string} [parameters.data.notificationTitle] Title of the
   * notification. This field supports appInfo markers.
   *
   * @param {string} [parameters.data.notificationMessage] Message of the
   * notification. This field supports appInfo markers.
   *
   * @param {buffer} [parameters.data.notificationImage] Optional image encoded
   * in base 64. Usually included in the right part of in app notifications (or
   * as a banner if there is neither text nor content icon). For Android system
   * notifications, the image is used as the large icon (displayed only on
   * Android 3+).
   *
   *
   * @param {object} [parameters.data.notificationOptions] Additional platform
   * specific options.
   *
   * @param {string} [parameters.data.notificationOptions.bigText] Android 4.1+
   * only. Multi line message shown in expanded notifications on Android 4.1+
   * devices. The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.bigPicture] URL of a
   * remote image displayed in expanded notifications on
   * Android 4.1+ devices with the following constraints:
   * * The URL length is limited to 2000 characters.
   * * The image size must be less than 4 MiB.
   * * The following MIME types are supported:
   * ** image/png
   * ** image/jpeg
   * ** image/gif
   * ** image/webp
   * ** image/bmp
   * ** image/x-bmp
   * ** image/x-ms-bmp
   * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
   * * Incompatible with `bigText`, only one of the fields can be set.
   * * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.sound] iOS only. The
   * name of a sound file in the application bundle. The sound in this file is
   * played as an alert. If the sound file doesn’t exist or default is specified
   * as the value, the default alert sound is played. The audio must be in one of
   * the audio data formats that are compatible with system sounds. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.actionText] The action
   * text is the title of the right button of the alert or the value of the
   * unlock slider, where the value replaces 'unlock' in 'slide to unlock'.
   * 'View' (localized to the preferred language) is used as the default value.
   * The `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.data.title] Title of the announcement or poll.
   * This field supports appInfo markers.
   *
   * @param {string} [parameters.data.body] Body of the text/web announcement,
   * poll or data push. This field supports appInfo markers.
   *
   * @param {string} [parameters.data.actionButtonText] Text of the action button
   * for text/web announcements and polls (answer button).
   *
   * @param {string} [parameters.data.exitButtonText] Text of the exit button for
   * text/web announcements and polls.
   *
   * @param {string} [parameters.data.actionUrl] URL to launch when the
   * announcement is actioned.
   *
   * @param {object} [parameters.data.payload] Native push payload.
   *
   * @param {string} parameters.deviceId Device identifier (as returned by the
   * SDK).
   *
   * @param {string} [parameters.lang] The language to test expressed using ISO
   * 639-1 code. The default language of the campaign will be used if the
   * parameter is not provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignState} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignState} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  testNew(resourceGroupName, appCollection, appName, kind, parameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._testNew(resourceGroupName, appCollection, appName, kind, parameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._testNew(resourceGroupName, appCollection, appName, kind, parameters, options, optionalCallback);
    }
  }

  /**
   * Activate a campaign previously created by a call to Create campaign.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignStateResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  activateWithHttpOperationResponse(resourceGroupName, appCollection, appName, kind, id, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._activate(resourceGroupName, appCollection, appName, kind, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Activate a campaign previously created by a call to Create campaign.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignStateResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignStateResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  activate(resourceGroupName, appCollection, appName, kind, id, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._activate(resourceGroupName, appCollection, appName, kind, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._activate(resourceGroupName, appCollection, appName, kind, id, options, optionalCallback);
    }
  }

  /**
   * Suspend a push campaign previously activated by a call to Activate campaign.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignStateResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  suspendWithHttpOperationResponse(resourceGroupName, appCollection, appName, kind, id, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._suspend(resourceGroupName, appCollection, appName, kind, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Suspend a push campaign previously activated by a call to Activate campaign.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignStateResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignStateResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  suspend(resourceGroupName, appCollection, appName, kind, id, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._suspend(resourceGroupName, appCollection, appName, kind, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._suspend(resourceGroupName, appCollection, appName, kind, id, options, optionalCallback);
    }
  }

  /**
   * Push a previously saved campaign (created with Create campaign) to a set of
   * devices.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} parameters Parameters supplied to the Push Campaign
   * operation.
   *
   * @param {array} parameters.deviceIds Device identifiers to push as a JSON
   * array of strings. Note that if you want to push the same campaign several
   * times to the same device, you need to make several API calls.
   *
   *
   * @param {object} [parameters.data] Alternative campaign's content to use
   * instead of the referenced campaign. All campaign's properties can be
   * overridden except for the following: `name`, `manualPush`, `audience`,
   * `startTime` and `timezone`. `endTime` can be overridden while keeping
   * original `timezone` parameter. The effect is to change the client side
   * expiration of the received campaign for the specific devices. If your
   * campaign is a *poll*, the provided data should contain the same number of
   * questions and choices that the one you created with the create command.
   * Please note that all the push messages created using this parameter will
   * expire after 4 weeks at maximum (`endTime` property of the campaign will be
   * used if lower than 4 weeks in the future).
   *
   * @param {string} [parameters.data.name] Unique name of the campaign.
   *
   * @param {object} [parameters.data.audience] Specify which users will be
   * targeted by this campaign. By default, all users will be targeted. If you
   * set `pushMode` property to `manual`, the only thing you can specify in the
   * audience is the push quota filter. An audience is a boolean expression made
   * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Additionally, a set of filters can be added to an audience. 65535 bytes max
   * as per JSON encoding.
   *
   *
   * @param {string} [parameters.data.audience.expression] Boolean expression
   * made of criteria (variables) operators (`not`, `and` or `or`) and
   * parenthesis. Criterion names in the audience expression must start with a
   * capital letter and can only contain alphanumeric (A-Z,a-z,0-9) and
   * underscore (_) characters.
   *
   *
   * @param {object} [parameters.data.audience.criteria] Criteria by name.
   *
   * @param {array} [parameters.data.audience.filters] Global filters applied to
   * all devices.
   *
   * @param {string} [parameters.data.category] Category of the campaign.
   * Categories can be used on the application side to customize campaigns.
   *
   * @param {string} [parameters.data.pushMode] Announcements/polls only. Defines
   * how the campaign is pushed. Valid values are: * `real-time`: Never ending
   * campaign, the campaign will be delivered  to your existing users and also to
   * your new users. * `one-shot`: In this mode, the campaign will be delivered
   * only to your existing users (campaign will stop after that). * `manual`: In
   * this mode, the campaign will not be pushed automatically to devices. You
   * will have to use the Push campaign command to push the campaign to your
   * end-users. Campaigns can be pushed multiple times to the same device.
   * . Possible values include: 'real-time', 'one-shot', 'manual'
   *
   * @param {string} [parameters.data.type] Applicable only to announcements and
   * data pushes. Type of announcement. Valid values are: * `text/plain`:
   * Text-only announcement: `body` property should only contain plain text. *
   * `text/html`: HTML announcement: `body` attribute can contain HTML code. *
   * `only_notif`: Notification-only announcement. With this kind of
   * announcements, the `body`, `title`, `actionButtonText` and `exitButtonText`
   * are ignored. Type of data push. Valid values are: * `text/plain`: Text only
   * data push: `body` property must be plain text. * `text/base64`: Base 64 data
   * push: `body` property must be encoded in base 64.
   * . Possible values include: 'text/plain', 'text/html', 'only_notif',
   * 'text/base64'
   *
   * @param {string} [parameters.data.deliveryTime] Announcements/polls only.
   * Defines when the campaign should be delivered. Valid values are: * `any`:
   * Campaign will be delivered as soon as possible. * `background`: iOS only.
   * Campaign will be only delivered when the application is in background (out
   * of app). * `session`: Campaign will be delivered when the application is
   * running.
   * . Possible values include: 'any', 'background', 'session'
   *
   * @param {array} [parameters.data.deliveryActivities] Announcements/polls
   * only. Array containing the list of activities in which the campaign can be
   * delivered. deliveryTime must be set to session. If the platform is iOS, this
   * option can also be set if deliveryTime is set to any. In that case, if the
   * campaign is received when the application is launched, it will be delivered
   * only in the specified list of activities.
   *
   *
   * @param {string} [parameters.data.startTime] The date at which the campaign
   * should be started. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
   * attribute will be ignored. * If you set pushMode property to one-shot, then
   * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.data.endTime] The date at which the campaign
   * should be finished. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.data.timezone] The id of the time zone to use
   * for the startTime and endTime dates. If not provided, the two date
   * attributes will be expressed using the device timezone. Example:
   * America/Los_Angeles
   *
   *
   * @param {string} [parameters.data.notificationType] Android only. Defines how
   * the notification should be displayed. Valid values are: * `system`: Display
   * the notification using a standard system notification. * `popup`: Display
   * the notification using a in-app banner notification.
   * . Possible values include: 'system', 'popup'
   *
   * @param {boolean} [parameters.data.notificationIcon] A flag indicating
   * whether or not you want to display the resource icon in notification
   * content.
   *
   * @param {boolean} [parameters.data.notificationCloseable] A flag indicating
   * whether or not you want the notification to be closeable.
   *
   * @param {boolean} [parameters.data.notificationVibrate] Android only. A flag
   * indicating whether or not you want the system notification to make a
   * vibration. The notificationType property must be set to system.
   *
   * @param {boolean} [parameters.data.notificationSound] * `Android`: A flag
   * indicating whether or not you want the system notification to make a sound.
   * The `notificationType` property must be set to `system`. * `iOS`: A flag
   * indicating whether or not you want the native Apple Push notification to
   * make a sound. The `deliveryTime` property must be set to `any` or
   * `background`. This will play the 'default' sound. If you want to play a
   * custom sound, see the `notificationOptions` property. * `Windows`: A flag
   * indicating whether or not you want the native Windows Notification Service
   * to make a sound. The `deliveryTime` property must be set to `any`.
   *
   *
   * @param {boolean} [parameters.data.notificationBadge] A flag indicating
   * whether or not you want the native Apple Push notification to update the
   * badge icon to the number of unread messages. The `deliveryTime` property
   * must be set to `any` or `background`.
   *
   *
   * @param {object} [parameters.data.localization] Push campaigns can be
   * localized using an optional JSON object. The JSON key is a two-character
   * language code as specified by the ISO 639-1 standard. The corresponding
   * value is an object containing the localizable properties.
   *
   *
   * @param {array} [parameters.data.questions] Poll questions.
   *
   * @param {string} [parameters.data.notificationTitle] Title of the
   * notification. This field supports appInfo markers.
   *
   * @param {string} [parameters.data.notificationMessage] Message of the
   * notification. This field supports appInfo markers.
   *
   * @param {buffer} [parameters.data.notificationImage] Optional image encoded
   * in base 64. Usually included in the right part of in app notifications (or
   * as a banner if there is neither text nor content icon). For Android system
   * notifications, the image is used as the large icon (displayed only on
   * Android 3+).
   *
   *
   * @param {object} [parameters.data.notificationOptions] Additional platform
   * specific options.
   *
   * @param {string} [parameters.data.notificationOptions.bigText] Android 4.1+
   * only. Multi line message shown in expanded notifications on Android 4.1+
   * devices. The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.bigPicture] URL of a
   * remote image displayed in expanded notifications on
   * Android 4.1+ devices with the following constraints:
   * * The URL length is limited to 2000 characters.
   * * The image size must be less than 4 MiB.
   * * The following MIME types are supported:
   * ** image/png
   * ** image/jpeg
   * ** image/gif
   * ** image/webp
   * ** image/bmp
   * ** image/x-bmp
   * ** image/x-ms-bmp
   * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
   * * Incompatible with `bigText`, only one of the fields can be set.
   * * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.sound] iOS only. The
   * name of a sound file in the application bundle. The sound in this file is
   * played as an alert. If the sound file doesn’t exist or default is specified
   * as the value, the default alert sound is played. The audio must be in one of
   * the audio data formats that are compatible with system sounds. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.actionText] The action
   * text is the title of the right button of the alert or the value of the
   * unlock slider, where the value replaces 'unlock' in 'slide to unlock'.
   * 'View' (localized to the preferred language) is used as the default value.
   * The `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.data.title] Title of the announcement or poll.
   * This field supports appInfo markers.
   *
   * @param {string} [parameters.data.body] Body of the text/web announcement,
   * poll or data push. This field supports appInfo markers.
   *
   * @param {string} [parameters.data.actionButtonText] Text of the action button
   * for text/web announcements and polls (answer button).
   *
   * @param {string} [parameters.data.exitButtonText] Text of the exit button for
   * text/web announcements and polls.
   *
   * @param {string} [parameters.data.actionUrl] URL to launch when the
   * announcement is actioned.
   *
   * @param {object} [parameters.data.payload] Native push payload.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignPushResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  pushWithHttpOperationResponse(resourceGroupName, appCollection, appName, kind, id, parameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._push(resourceGroupName, appCollection, appName, kind, id, parameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Push a previously saved campaign (created with Create campaign) to a set of
   * devices.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} parameters Parameters supplied to the Push Campaign
   * operation.
   *
   * @param {array} parameters.deviceIds Device identifiers to push as a JSON
   * array of strings. Note that if you want to push the same campaign several
   * times to the same device, you need to make several API calls.
   *
   *
   * @param {object} [parameters.data] Alternative campaign's content to use
   * instead of the referenced campaign. All campaign's properties can be
   * overridden except for the following: `name`, `manualPush`, `audience`,
   * `startTime` and `timezone`. `endTime` can be overridden while keeping
   * original `timezone` parameter. The effect is to change the client side
   * expiration of the received campaign for the specific devices. If your
   * campaign is a *poll*, the provided data should contain the same number of
   * questions and choices that the one you created with the create command.
   * Please note that all the push messages created using this parameter will
   * expire after 4 weeks at maximum (`endTime` property of the campaign will be
   * used if lower than 4 weeks in the future).
   *
   * @param {string} [parameters.data.name] Unique name of the campaign.
   *
   * @param {object} [parameters.data.audience] Specify which users will be
   * targeted by this campaign. By default, all users will be targeted. If you
   * set `pushMode` property to `manual`, the only thing you can specify in the
   * audience is the push quota filter. An audience is a boolean expression made
   * of criteria (variables) operators (`not`, `and` or `or`) and parenthesis.
   * Additionally, a set of filters can be added to an audience. 65535 bytes max
   * as per JSON encoding.
   *
   *
   * @param {string} [parameters.data.audience.expression] Boolean expression
   * made of criteria (variables) operators (`not`, `and` or `or`) and
   * parenthesis. Criterion names in the audience expression must start with a
   * capital letter and can only contain alphanumeric (A-Z,a-z,0-9) and
   * underscore (_) characters.
   *
   *
   * @param {object} [parameters.data.audience.criteria] Criteria by name.
   *
   * @param {array} [parameters.data.audience.filters] Global filters applied to
   * all devices.
   *
   * @param {string} [parameters.data.category] Category of the campaign.
   * Categories can be used on the application side to customize campaigns.
   *
   * @param {string} [parameters.data.pushMode] Announcements/polls only. Defines
   * how the campaign is pushed. Valid values are: * `real-time`: Never ending
   * campaign, the campaign will be delivered  to your existing users and also to
   * your new users. * `one-shot`: In this mode, the campaign will be delivered
   * only to your existing users (campaign will stop after that). * `manual`: In
   * this mode, the campaign will not be pushed automatically to devices. You
   * will have to use the Push campaign command to push the campaign to your
   * end-users. Campaigns can be pushed multiple times to the same device.
   * . Possible values include: 'real-time', 'one-shot', 'manual'
   *
   * @param {string} [parameters.data.type] Applicable only to announcements and
   * data pushes. Type of announcement. Valid values are: * `text/plain`:
   * Text-only announcement: `body` property should only contain plain text. *
   * `text/html`: HTML announcement: `body` attribute can contain HTML code. *
   * `only_notif`: Notification-only announcement. With this kind of
   * announcements, the `body`, `title`, `actionButtonText` and `exitButtonText`
   * are ignored. Type of data push. Valid values are: * `text/plain`: Text only
   * data push: `body` property must be plain text. * `text/base64`: Base 64 data
   * push: `body` property must be encoded in base 64.
   * . Possible values include: 'text/plain', 'text/html', 'only_notif',
   * 'text/base64'
   *
   * @param {string} [parameters.data.deliveryTime] Announcements/polls only.
   * Defines when the campaign should be delivered. Valid values are: * `any`:
   * Campaign will be delivered as soon as possible. * `background`: iOS only.
   * Campaign will be only delivered when the application is in background (out
   * of app). * `session`: Campaign will be delivered when the application is
   * running.
   * . Possible values include: 'any', 'background', 'session'
   *
   * @param {array} [parameters.data.deliveryActivities] Announcements/polls
   * only. Array containing the list of activities in which the campaign can be
   * delivered. deliveryTime must be set to session. If the platform is iOS, this
   * option can also be set if deliveryTime is set to any. In that case, if the
   * campaign is received when the application is launched, it will be delivered
   * only in the specified list of activities.
   *
   *
   * @param {string} [parameters.data.startTime] The date at which the campaign
   * should be started. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. * If you set pushMode property to manual, this
   * attribute will be ignored. * If you set pushMode property to one-shot, then
   * the timezone attribute must be specified. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.data.endTime] The date at which the campaign
   * should be finished. The date shall conform to the following format:
   * `yyyy-MM-ddTHH:mm:ssZ`. Example: `2011-11-21 15:23Z`
   *
   *
   * @param {string} [parameters.data.timezone] The id of the time zone to use
   * for the startTime and endTime dates. If not provided, the two date
   * attributes will be expressed using the device timezone. Example:
   * America/Los_Angeles
   *
   *
   * @param {string} [parameters.data.notificationType] Android only. Defines how
   * the notification should be displayed. Valid values are: * `system`: Display
   * the notification using a standard system notification. * `popup`: Display
   * the notification using a in-app banner notification.
   * . Possible values include: 'system', 'popup'
   *
   * @param {boolean} [parameters.data.notificationIcon] A flag indicating
   * whether or not you want to display the resource icon in notification
   * content.
   *
   * @param {boolean} [parameters.data.notificationCloseable] A flag indicating
   * whether or not you want the notification to be closeable.
   *
   * @param {boolean} [parameters.data.notificationVibrate] Android only. A flag
   * indicating whether or not you want the system notification to make a
   * vibration. The notificationType property must be set to system.
   *
   * @param {boolean} [parameters.data.notificationSound] * `Android`: A flag
   * indicating whether or not you want the system notification to make a sound.
   * The `notificationType` property must be set to `system`. * `iOS`: A flag
   * indicating whether or not you want the native Apple Push notification to
   * make a sound. The `deliveryTime` property must be set to `any` or
   * `background`. This will play the 'default' sound. If you want to play a
   * custom sound, see the `notificationOptions` property. * `Windows`: A flag
   * indicating whether or not you want the native Windows Notification Service
   * to make a sound. The `deliveryTime` property must be set to `any`.
   *
   *
   * @param {boolean} [parameters.data.notificationBadge] A flag indicating
   * whether or not you want the native Apple Push notification to update the
   * badge icon to the number of unread messages. The `deliveryTime` property
   * must be set to `any` or `background`.
   *
   *
   * @param {object} [parameters.data.localization] Push campaigns can be
   * localized using an optional JSON object. The JSON key is a two-character
   * language code as specified by the ISO 639-1 standard. The corresponding
   * value is an object containing the localizable properties.
   *
   *
   * @param {array} [parameters.data.questions] Poll questions.
   *
   * @param {string} [parameters.data.notificationTitle] Title of the
   * notification. This field supports appInfo markers.
   *
   * @param {string} [parameters.data.notificationMessage] Message of the
   * notification. This field supports appInfo markers.
   *
   * @param {buffer} [parameters.data.notificationImage] Optional image encoded
   * in base 64. Usually included in the right part of in app notifications (or
   * as a banner if there is neither text nor content icon). For Android system
   * notifications, the image is used as the large icon (displayed only on
   * Android 3+).
   *
   *
   * @param {object} [parameters.data.notificationOptions] Additional platform
   * specific options.
   *
   * @param {string} [parameters.data.notificationOptions.bigText] Android 4.1+
   * only. Multi line message shown in expanded notifications on Android 4.1+
   * devices. The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.bigPicture] URL of a
   * remote image displayed in expanded notifications on
   * Android 4.1+ devices with the following constraints:
   * * The URL length is limited to 2000 characters.
   * * The image size must be less than 4 MiB.
   * * The following MIME types are supported:
   * ** image/png
   * ** image/jpeg
   * ** image/gif
   * ** image/webp
   * ** image/bmp
   * ** image/x-bmp
   * ** image/x-ms-bmp
   * * URL scheme must be HTTP or HTTPS (with valid SSL certificate).
   * * Incompatible with `bigText`, only one of the fields can be set.
   * * The `notificationType` property must be set to `system`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.sound] iOS only. The
   * name of a sound file in the application bundle. The sound in this file is
   * played as an alert. If the sound file doesn’t exist or default is specified
   * as the value, the default alert sound is played. The audio must be in one of
   * the audio data formats that are compatible with system sounds. The
   * `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.data.notificationOptions.actionText] The action
   * text is the title of the right button of the alert or the value of the
   * unlock slider, where the value replaces 'unlock' in 'slide to unlock'.
   * 'View' (localized to the preferred language) is used as the default value.
   * The `deliveryTime` property must be set to `any` or `background`.
   *
   *
   * @param {string} [parameters.data.title] Title of the announcement or poll.
   * This field supports appInfo markers.
   *
   * @param {string} [parameters.data.body] Body of the text/web announcement,
   * poll or data push. This field supports appInfo markers.
   *
   * @param {string} [parameters.data.actionButtonText] Text of the action button
   * for text/web announcements and polls (answer button).
   *
   * @param {string} [parameters.data.exitButtonText] Text of the exit button for
   * text/web announcements and polls.
   *
   * @param {string} [parameters.data.actionUrl] URL to launch when the
   * announcement is actioned.
   *
   * @param {object} [parameters.data.payload] Native push payload.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignPushResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignPushResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  push(resourceGroupName, appCollection, appName, kind, id, parameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._push(resourceGroupName, appCollection, appName, kind, id, parameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._push(resourceGroupName, appCollection, appName, kind, id, parameters, options, optionalCallback);
    }
  }

  /**
   * Get all the campaign statistics.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignStatisticsResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getStatisticsWithHttpOperationResponse(kind, id, resourceGroupName, appCollection, appName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getStatistics(kind, id, resourceGroupName, appCollection, appName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Get all the campaign statistics.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignStatisticsResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignStatisticsResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getStatistics(kind, id, resourceGroupName, appCollection, appName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getStatistics(kind, id, resourceGroupName, appCollection, appName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getStatistics(kind, id, resourceGroupName, appCollection, appName, options, optionalCallback);
    }
  }

  /**
   * Finish a push campaign previously activated by a call to Activate campaign.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignStateResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  finishWithHttpOperationResponse(resourceGroupName, appCollection, appName, kind, id, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._finish(resourceGroupName, appCollection, appName, kind, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Finish a push campaign previously activated by a call to Activate campaign.
   *
   * @param {string} resourceGroupName The name of the resource group.
   *
   * @param {string} appCollection Application collection.
   *
   * @param {string} appName Application resource name.
   *
   * @param {string} kind Campaign kind. Possible values include:
   * 'announcements', 'polls', 'dataPushes', 'nativePushes'
   *
   * @param {number} id Campaign identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignStateResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignStateResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  finish(resourceGroupName, appCollection, appName, kind, id, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._finish(resourceGroupName, appCollection, appName, kind, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._finish(resourceGroupName, appCollection, appName, kind, id, options, optionalCallback);
    }
  }

  /**
   * Get the list of campaigns.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CampaignsListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Get the list of campaigns.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CampaignsListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CampaignsListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listNext(nextPageLink, options, optionalCallback);
    }
  }

}

module.exports = Campaigns;
